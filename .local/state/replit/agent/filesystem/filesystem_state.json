{"file_contents":{"bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport logging\nimport asyncio\nimport re\n\nlogger = logging.getLogger(__name__)\n\nclass DiscordBot(commands.Bot):\n    def __init__(self):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        super().__init__(command_prefix='gs.', intents=intents)\n        \n        # Target channel ID\n        self.target_channel_id = 1401169397850308708\n        \n        # WFL pattern (case-insensitive)\n        self.wfl_pattern = re.compile(r'\\bwfl\\b', re.IGNORECASE)\n        \n        # Rate limiting\n        self.last_reaction_time = {}\n        self.reaction_cooldown = 1  # 1 second cooldown between reactions\n        \n        # Pet weight formula - base weights at each age\n        self.base_weights = {\n            1: 1.00, 2: 1.09, 3: 1.18, 4: 1.27, 5: 1.36, 6: 1.45, 7: 1.55, 8: 1.64, 9: 1.73, 10: 1.82,\n            11: 1.91, 12: 2.00, 13: 2.09, 14: 2.18, 15: 2.27, 16: 2.36, 17: 2.45, 18: 2.55, 19: 2.64, 20: 2.73,\n            21: 2.82, 22: 2.91, 23: 3.00, 24: 3.09, 25: 3.18, 26: 3.27, 27: 3.36, 28: 3.45, 29: 3.55, 30: 3.64,\n            31: 3.73, 32: 3.82, 33: 3.91, 34: 4.00, 35: 4.09, 36: 4.18, 37: 4.27, 38: 4.36, 39: 4.45, 40: 4.55,\n            41: 4.64, 42: 4.73, 43: 4.82, 44: 4.91, 45: 5.00, 46: 5.09, 47: 5.18, 48: 5.27, 49: 5.36, 50: 5.45,\n            51: 5.55, 52: 5.64, 53: 5.73, 54: 5.82, 55: 5.91, 56: 6.00, 57: 6.09, 58: 6.18, 59: 6.27, 60: 6.36,\n            61: 6.45, 62: 6.55, 63: 6.64, 64: 6.73, 65: 6.82, 66: 6.91, 67: 7.00, 68: 7.09, 69: 7.18, 70: 7.27,\n            71: 7.36, 72: 7.45, 73: 7.55, 74: 7.64, 75: 7.73, 76: 7.82, 77: 7.91, 78: 8.00, 79: 8.09, 80: 8.18,\n            81: 8.27, 82: 8.36, 83: 8.45, 84: 8.55, 85: 8.64, 86: 8.73, 87: 8.82, 88: 8.91, 89: 9.00, 90: 9.09,\n            91: 9.18, 92: 9.27, 93: 9.36, 94: 9.45, 95: 9.55, 96: 9.64, 97: 9.73, 98: 9.82, 99: 9.91, 100: 10.00\n        }\n        \n\n\n    async def on_ready(self):\n        \"\"\"Called when the bot is ready\"\"\"\n        logger.info(f'{self.user} has connected to Discord!')\n        logger.info(f'Bot is in {len(self.guilds)} guilds')\n        \n        # Verify target channel exists\n        target_channel = self.get_channel(self.target_channel_id)\n        if target_channel:\n            logger.info(f'Monitoring channel: {target_channel.name} ({target_channel.id})')\n        else:\n            logger.warning(f'Target channel {self.target_channel_id} not found')\n\n    async def on_message(self, message):\n        \"\"\"Handle incoming messages\"\"\"\n        # Ignore bot messages\n        if message.author.bot:\n            return\n        \n        # Process commands first\n        await self.process_commands(message)\n        \n        # Check if message is in target channel for WFL reactions\n        if message.channel.id != self.target_channel_id:\n            return\n        \n        # Check if message contains \"wfl\" (case-insensitive)\n        if not self.wfl_pattern.search(message.content):\n            return\n        \n        # Rate limiting check\n        current_time = asyncio.get_event_loop().time()\n        if (message.channel.id in self.last_reaction_time and \n            current_time - self.last_reaction_time[message.channel.id] < self.reaction_cooldown):\n            logger.debug(f'Rate limit: Skipping reaction for message {message.id}')\n            return\n        \n        self.last_reaction_time[message.channel.id] = current_time\n        \n        # React with W, F, L emojis\n        await self.add_wfl_reactions(message)\n\n    async def add_wfl_reactions(self, message):\n        \"\"\"Add W, F, L reactions to a message\"\"\"\n        reactions = ['W1', 'F1', 'L1']  # Custom server emojis for W, F, L\n        \n        try:\n            for emoji_name in reactions:\n                # Try to find the custom emoji in the server\n                emoji = discord.utils.get(message.guild.emojis, name=emoji_name)\n                if emoji:\n                    await message.add_reaction(emoji)\n                    logger.info(f'Added reaction :{emoji_name}: to message {message.id} in {message.channel.name}')\n                else:\n                    logger.warning(f'Custom emoji :{emoji_name}: not found in server {message.guild.name}')\n                # Small delay between reactions to avoid rate limits\n                await asyncio.sleep(0.5)\n                \n        except discord.HTTPException as e:\n            if e.status == 429:  # Rate limited\n                logger.warning(f'Rate limited while adding reactions to message {message.id}')\n            else:\n                logger.error(f'HTTP error adding reactions to message {message.id}: {e}')\n        except discord.Forbidden:\n            logger.error(f'Missing permissions to add reactions to message {message.id}')\n        except discord.NotFound:\n            logger.error(f'Message {message.id} not found when trying to add reactions')\n        except Exception as e:\n            logger.error(f'Unexpected error adding reactions to message {message.id}: {e}')\n\n    async def on_error(self, event, *args, **kwargs):\n        \"\"\"Handle errors\"\"\"\n        logger.error(f'Error in event {event}', exc_info=True)\n\n    async def on_command_error(self, ctx, error):\n        \"\"\"Handle command errors\"\"\"\n        logger.error(f'Command error: {error}', exc_info=True)\n\n    def calculate_weight_multiplier(self, current_age, current_weight):\n        \"\"\"Calculate the multiplier based on current age and weight\"\"\"\n        if current_age not in self.base_weights:\n            return None\n        \n        base_weight_at_current_age = self.base_weights[current_age]\n        multiplier = current_weight / base_weight_at_current_age\n        return multiplier\n\n    def predict_weights(self, current_age, current_weight, target_ages=None):\n        \"\"\"Predict weights for specified ages based on current data\"\"\"\n        multiplier = self.calculate_weight_multiplier(current_age, current_weight)\n        if multiplier is None:\n            return None\n        \n        if target_ages is None:\n            target_ages = list(range(1, 101))\n        \n        predictions = {}\n        for age in target_ages:\n            if age in self.base_weights:\n                predicted_weight = self.base_weights[age] * multiplier\n                predictions[age] = round(predicted_weight, 2)\n        \n        return predictions\n\n    @commands.command()\n    async def petweight(self, ctx, current_age: int, current_weight: float, target_age: int = None):\n        \"\"\"Calculate pet weight at different ages\n        Usage: gs.petweight <current_age> <current_weight> [target_age]\n        Example: gs.petweight 5 2.5 10\n        \"\"\"\n        try:\n            # Validate input\n            if current_age < 1 or current_age > 100:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Age must be between 1 and 100\")\n                return\n            \n            if current_weight <= 0:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Weight must be greater than 0\")\n                return\n            \n            # If target_age is specified, calculate for that age only\n            if target_age is not None:\n                if target_age < 1 or target_age > 100:\n                    await ctx.send(\"<:GsWrong:1414561861352816753>   Target age must be between 1 and 100\")\n                    return\n                \n                predictions = self.predict_weights(current_age, current_weight, [target_age])\n                if predictions is None:\n                    await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid age provided\")\n                    return\n                \n                predicted_weight = predictions[target_age]\n                \n                embed = discord.Embed(\n                    title=\" Pet Weight Prediction\",\n                    color=0x4CAF50\n                )\n                embed.add_field(\n                    name=\"Current Info\",\n                    value=f\"Age: {current_age} | Weight: {current_weight} kg\",\n                    inline=False\n                )\n                embed.add_field(\n                    name=f\"Predicted Weight at Age {target_age}\",\n                    value=f\"**{predicted_weight} kg**\",\n                    inline=False\n                )\n                \n                await ctx.send(embed=embed)\n            \n            else:\n                # Show weight progression for key ages\n                predictions = self.predict_weights(current_age, current_weight)\n                if predictions is None:\n                    await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid age provided\")\n                    return\n                \n                # Show current age + next 10 ages\n                key_ages = []\n                for age in range(current_age, min(current_age + 50, 101)):\n                    if age in predictions:\n                        key_ages.append(age)\n                \n                # If we don't have 10 ages ahead, show some before\n                if len(key_ages) < 10:\n                    for age in range(max(1, current_age - 5), current_age):\n                        if age in predictions and age not in key_ages:\n                            key_ages.insert(0, age)\n                \n                key_ages = sorted(key_ages)[:50]  # Limit to 10 ages\n                \n                embed = discord.Embed(\n                    title=\"🐾 Pet Weight Progression\",\n                    color=0x2196F3\n                )\n                embed.add_field(\n                    name=\"Current Info\",\n                    value=f\"Age: {current_age} | Weight: {current_weight} kg\",\n                    inline=False\n                )\n                \n                weight_text = \"\"\n                for age in key_ages:\n                    marker = \" ← **Current**\" if age == current_age else \"\"\n                    weight_text += f\"Age {age}: {predictions[age]} kg{marker}\\n\"\n                \n                embed.add_field(\n                    name=\"GS Pet Weight Predictions\",\n                    value=weight_text,\n                    inline=False\n                )\n                embed.add_field(\n                    name=\"💡 Tip\",\n                    value=\"Use `gs.petweight <age> <weight> <target_age>` to predict weight at a specific age\",\n                    inline=False\n                )\n                \n                await ctx.send(embed=embed)\n                \n        except ValueError:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Please provide valid numbers for age and weight\")\n        except Exception as e:\n            logger.error(f\"Error in petweight command: {e}\")\n            await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while calculating weights\")\n\n    async def close(self):\n        \"\"\"Clean shutdown\"\"\"\n        logger.info('Shutting down Discord bot...')\n        await super().close()\n","size_bytes":10889},"database.py":{"content":"import os\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\nfrom datetime import datetime, timedelta\nimport logging\nimport discord\n\nlogger = logging.getLogger(__name__)\n\nclass ModerationDB:\n    def __init__(self):\n        self.db_url = os.getenv('DATABASE_URL')\n        if not self.db_url:\n            raise ValueError(\"DATABASE_URL environment variable not set\")\n        \n    def get_connection(self):\n        \"\"\"Get database connection with retry logic\"\"\"\n        max_retries = 3\n        for attempt in range(max_retries):\n            try:\n                return psycopg2.connect(self.db_url, cursor_factory=RealDictCursor)\n            except Exception as e:\n                logger.error(f\"Database connection attempt {attempt + 1} failed: {e}\")\n                if attempt == max_retries - 1:\n                    raise\n                import time\n                time.sleep(1)\n    \n    def init_database(self):\n        \"\"\"Initialize database tables\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                # Create moderation_actions table\n                cur.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS moderation_actions (\n                        id SERIAL PRIMARY KEY,\n                        user_id BIGINT NOT NULL,\n                        moderator_id BIGINT NOT NULL,\n                        server_id BIGINT NOT NULL,\n                        action_type VARCHAR(20) NOT NULL,\n                        reason TEXT NOT NULL,\n                        duration_minutes INTEGER,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        expires_at TIMESTAMP,\n                        is_active BOOLEAN DEFAULT TRUE,\n                        removed_by BIGINT,\n                        removed_at TIMESTAMP,\n                        removal_reason TEXT\n                    )\n                \"\"\")\n                \n                # Create indexes for better performance\n                cur.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_moderation_user_id \n                    ON moderation_actions(user_id)\n                \"\"\")\n                cur.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_moderation_server_id \n                    ON moderation_actions(server_id)\n                \"\"\")\n                cur.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_moderation_active \n                    ON moderation_actions(is_active, expires_at)\n                \"\"\")\n                \n                conn.commit()\n                logger.info(\"Database tables initialized successfully\")\n    \n    def add_moderation_action(self, user_id, moderator_id, server_id, action_type, reason, duration_minutes=None):\n        \"\"\"Add a new moderation action\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                expires_at = None\n                if duration_minutes:\n                    expires_at = datetime.utcnow() + timedelta(minutes=duration_minutes)\n                \n                cur.execute(\"\"\"\n                    INSERT INTO moderation_actions \n                    (user_id, moderator_id, server_id, action_type, reason, duration_minutes, expires_at)\n                    VALUES (%s, %s, %s, %s, %s, %s, %s)\n                    RETURNING id\n                \"\"\", (user_id, moderator_id, server_id, action_type, reason, duration_minutes, expires_at))\n                \n                action_id = cur.fetchone()['id']\n                conn.commit()\n                return action_id\n    \n    def get_user_record(self, user_id, server_id):\n        \"\"\"Get all moderation actions for a user\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    SELECT * FROM moderation_actions \n                    WHERE user_id = %s AND server_id = %s\n                    ORDER BY created_at DESC\n                \"\"\", (user_id, server_id))\n                \n                return cur.fetchall()\n    \n    def get_active_actions(self, user_id, server_id, action_type=None):\n        \"\"\"Get active moderation actions for a user\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                query = \"\"\"\n                    SELECT * FROM moderation_actions \n                    WHERE user_id = %s AND server_id = %s AND is_active = TRUE\n                    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n                \"\"\"\n                params = [user_id, server_id]\n                \n                if action_type:\n                    query += \" AND action_type = %s\"\n                    params.append(action_type)\n                \n                query += \" ORDER BY created_at DESC\"\n                cur.execute(query, params)\n                \n                return cur.fetchall()\n    \n    def remove_moderation_action(self, action_id, removed_by, removal_reason):\n        \"\"\"Remove/revoke a moderation action\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    UPDATE moderation_actions \n                    SET is_active = FALSE, removed_by = %s, removed_at = CURRENT_TIMESTAMP, \n                        removal_reason = %s\n                    WHERE id = %s AND is_active = TRUE\n                    RETURNING *\n                \"\"\", (removed_by, removal_reason, action_id))\n                \n                result = cur.fetchone()\n                conn.commit()\n                return result\n    \n    def cleanup_expired_actions(self):\n        \"\"\"Clean up expired moderation actions\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    UPDATE moderation_actions \n                    SET is_active = FALSE \n                    WHERE is_active = TRUE \n                    AND expires_at IS NOT NULL \n                    AND expires_at <= CURRENT_TIMESTAMP\n                    RETURNING id, user_id, action_type\n                \"\"\")\n                \n                expired_actions = cur.fetchall()\n                conn.commit()\n                return expired_actions\n\n# Global instance\nmod_db = ModerationDB()","size_bytes":6286},"fixed_bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport logging\nimport asyncio\nimport re\nfrom typing import Optional\nimport json\nimport os\nfrom datetime import datetime, timedelta\nfrom database import mod_db\nimport difflib\nimport random\nimport operator\n\nlogger = logging.getLogger(__name__)\n\n# In-memory pet database  \nPET_DATABASE = {}\nPET_DATA_FILE = os.path.join(os.path.dirname(__file__), \"pet_values.json\")\n\n# Pet data will be loaded after function definitions\n\n# Chat guide message system\nchannel_message_counts = {}  # Track messages per channel for chat guide\nchat_guide_cooldown = {}     # Prevent spam/duplicates per channel\nCHAT_GUIDE_MESSAGE = \"**Make sure to check out the [Chat Guide](https://discord.com/channels/1370086525210984458/1410921626241073173) & you are following the guidelines whilst chatting!**\"\nCHAT_GUIDE_INTERVAL = 100    # Send every 100 messages\nCHAT_GUIDE_CHANNEL_ID = 1370086532433838102  # Only send in this specific channel\n\n# Load existing pet data on startup\ndef load_pet_data():\n    global PET_DATABASE\n    try:\n        logger.info(f\"🔄 Attempting to load pet data from {PET_DATA_FILE}\")\n        if os.path.exists(PET_DATA_FILE):\n            logger.info(f\"✅ File {PET_DATA_FILE} exists, loading...\")\n            with open(PET_DATA_FILE, 'r') as f:\n                PET_DATABASE = json.load(f)\n            logger.info(f\"🐾 Successfully loaded {len(PET_DATABASE)} pets from database\")\n        else:\n            PET_DATABASE = {}\n            logger.error(f\"❌ File {PET_DATA_FILE} not found, starting with empty database\")\n    except Exception as e:\n        logger.error(f\"💥 Error loading pet data: {e}\")\n        logger.error(f\"📁 Current working directory: {os.getcwd()}\")\n        logger.error(f\"📂 Contents of directory: {os.listdir('.')}\")\n        PET_DATABASE = {}\n\n# Save pet data to file\ndef save_pet_data():\n    try:\n        with open(PET_DATA_FILE, 'w') as f:\n            json.dump(PET_DATABASE, f, indent=2)\n        logger.info(f\"Saved {len(PET_DATABASE)} pets to database\")\n    except Exception as e:\n        logger.error(f\"Error saving pet data: {e}\")\n\n# Enhanced pet name detection patterns - Updated for your exact format\nPET_PATTERNS = [\n    # Primary pattern for the new format: \"(Petname)- (Value)┆ Demand: (demand) ┆Image:https://...\"\n    r'\\(([^)]+)\\)\\s*-\\s*([^┆\\n]+?)┆\\s*Demand:\\s*([^┆\\n]+?)\\s*┆\\s*Image:\\s*(https?://[^\\s\\n]+)',\n    # Fallback without image\n    r'\\(([^)]+)\\)\\s*-\\s*([^┆\\n]+?)┆\\s*Demand:\\s*([^┆\\n]+)',\n    # Legacy patterns for compatibility\n    r'([A-Za-z\\s]+?)\\s*-\\s*([^┆\\n]+?)┆\\s*Demand:\\s*([^┆\\n]+?)┆\\s*Image:\\s*(https?://[^\\s\\n]+)',\n    r'([A-Za-z\\s]+?)\\s*-\\s*([^┆\\n]+?)┆\\s*Demand:\\s*([^┆\\n]+)',\n]\n\ndef get_similarity_score(name1, name2):\n    \"\"\"Enhanced similarity scoring with fuzzy matching\"\"\"\n    name1 = name1.lower().strip()\n    name2 = name2.lower().strip()\n\n    # Exact match\n    if name1 == name2:\n        return 100\n\n    # Check if search term is contained in pet name\n    if name1 in name2 or name2 in name1:\n        return 95\n\n    # Check word overlap\n    words1 = set(name1.split())\n    words2 = set(name2.split())\n    common_words = words1.intersection(words2)\n\n    if common_words:\n        overlap_ratio = len(common_words) / max(len(words1), len(words2))\n        if overlap_ratio >= 0.4:\n            return int(overlap_ratio * 85)\n\n    # Fuzzy string matching\n    from difflib import SequenceMatcher\n    ratio = SequenceMatcher(None, name1, name2).ratio()\n    if ratio >= 0.6:\n        return int(ratio * 80)\n\n    # Partial matches\n    if any(word in name2 for word in words1 if len(word) > 2):\n        return 60\n\n    return 0\n\ndef find_best_pet_matches(search_name, max_results=5):\n    \"\"\"Find best matching pets with improved scoring\"\"\"\n    matches = []\n\n    for key, pet_data in PET_DATABASE.items():\n        score = get_similarity_score(search_name, pet_data['name'])\n        if score > 40:  # Lower threshold for better results\n            matches.append((pet_data, score))\n\n    # Sort by similarity score (highest first)\n    matches.sort(key=lambda x: x[1], reverse=True)\n    return matches[:max_results]\n\nasync def process_pet_value_message(message, provided_image_url=None):\n    \"\"\"Enhanced pet value processing with instant updates and proper image extraction\"\"\"\n    content = message.content\n\n    # Skip messages from games like Wordbomb, Trivia, etc.\n    if any(game_word in content.lower() for game_word in [\n        'wordbomb', 'trivia', 'akinator', 'pokemon', 'countryball', 'higher lower',\n        'word chain', 'rhyme time', 'scramble', 'hangman', 'twenty questions',\n        'truth or dare', 'never have i ever', 'would you rather', 'counting',\n        'rock paper scissors', 'tic tac toe', 'connect 4', 'chess', 'checkers'\n    ]):\n        logger.info(f\"Skipping game message: {content[:50]}...\")\n        return\n\n    # Skip messages that are just random words without pet context\n    if not any(keyword in content.lower() for keyword in [\n        'value', 'demand', 'pet', '🐾', '🪙', 'high', 'medium', 'low', 'extremely', 'image:', '┆'\n    ]):\n        return\n\n    # Collect all images from the message\n    image_urls = []\n\n    if message.attachments:\n        for attachment in message.attachments:\n            if attachment.content_type and attachment.content_type.startswith('image/'):\n                image_url = attachment.url\n                image_urls.append(image_url)\n                logger.info(f\"Found attachment image: {attachment.filename}\")\n\n    if message.embeds:\n        for embed in message.embeds:\n            if embed.image and embed.image.url:\n                image_url = embed.image.url\n                image_urls.append(image_url)\n            elif embed.thumbnail and embed.thumbnail.url:\n                image_url = embed.thumbnail.url\n                image_urls.append(image_url)\n\n    if provided_image_url:\n        image_urls.append(provided_image_url)\n\n    # Enhanced pattern matching with image extraction\n    found_pets = []\n    for pattern in PET_PATTERNS:\n        matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)\n        for match in matches:\n            if len(match) >= 3:\n                pet_name = match[0].strip()\n                value = match[1].strip()\n                demand = match[2].strip()\n\n                # Check if this pattern includes image URL (4th group)\n                extracted_image_url = None\n                if len(match) >= 4 and match[3]:\n                    extracted_image_url = match[3].strip()\n                    # Remove 'lossless' parameter if present\n                    if 'quality=lossless' in extracted_image_url:\n                        extracted_image_url = extracted_image_url.replace('&quality=lossless', '').replace('quality=lossless&', '').replace('quality=lossless', '')\n                    logger.info(f\"Extracted image URL from text: {extracted_image_url[:50]}...\")\n\n                # Clean pet name - remove \"lossless\" prefix if present\n                original_name = pet_name\n                pet_name = re.sub(r'^(lossless\\s*)', '', pet_name, flags=re.IGNORECASE).strip()\n                pet_name = re.sub(r'[^\\w\\s]', '', pet_name).strip()\n\n                # Skip if cleaning removed everything or left only short/invalid names\n                if (not pet_name or\n                    pet_name.lower() in ['lossless', 'losless', 'loss', 'less'] or\n                    len(pet_name) < 2):\n                    logger.info(f\"Skipping invalid pet name after cleaning: '{original_name}' -> '{pet_name}'\")\n                    continue\n\n                if len(pet_name) >= 2:\n                    found_pets.append((pet_name, value, demand, extracted_image_url))\n\n    # Store pets with images - FIXED assignment logic\n    for i, pet_data in enumerate(found_pets):\n        pet_name, value, demand = pet_data[:3]\n        extracted_image_url = pet_data[3] if len(pet_data) > 3 else None\n\n        assigned_image = None\n\n        # Priority 1: Image URL extracted from the message text (most accurate)\n        if extracted_image_url:\n            assigned_image = extracted_image_url\n            logger.info(f\"Using extracted image URL for {pet_name}: {assigned_image[:50]}...\")\n        # Priority 2: Only assign attachment images if there's exactly ONE pet and ONE image\n        elif len(found_pets) == 1 and len(image_urls) == 1:\n            assigned_image = image_urls[0]\n            logger.info(f\"Assigning single attachment image to {pet_name}: {assigned_image[:50]}...\")\n        else:\n            logger.info(f\"No suitable image found for {pet_name}\")\n\n        pet_key = pet_name.lower().replace(' ', '_')\n\n        # Store pet data with instant update - preserve existing image if no new one\n        existing_image = PET_DATABASE.get(pet_key, {}).get('image_url')\n        final_image = assigned_image if assigned_image else existing_image\n\n        PET_DATABASE[pet_key] = {\n            'name': pet_name,\n            'value': value,\n            'demand': demand,\n            'last_updated': message.created_at.isoformat(),\n            'message_id': message.id,\n            'image_url': final_image\n        }\n\n        logger.info(f\"Updated pet: {pet_name} - Value: {value} - Demand: {demand} - Image: {'Yes' if assigned_image else 'No'}\")\n\n    # Save data immediately for instant updates\n    if found_pets:\n        save_pet_data()\n        logger.info(f\"INSTANT UPDATE: Processed {len(found_pets)} pets and saved to database\")\n\n# Pet weight formula\nBASE_WEIGHTS = {\n    1: 1.00, 2: 1.09, 3: 1.18, 4: 1.27, 5: 1.36, 6: 1.45, 7: 1.55, 8: 1.64, 9: 1.73, 10: 1.82,\n    11: 1.91, 12: 2.00, 13: 2.09, 14: 2.18, 15: 2.27, 16: 2.36, 17: 2.45, 18: 2.55, 19: 2.64, 20: 2.73,\n    21: 2.82, 22: 2.91, 23: 3.00, 24: 3.09, 25: 3.18, 26: 3.27, 27: 3.36, 28: 3.45, 29: 3.55, 30: 3.64,\n    31: 3.73, 32: 3.82, 33: 3.91, 34: 4.00, 35: 4.09, 36: 4.18, 37: 4.27, 38: 4.36, 39: 4.45, 40: 4.55,\n    41: 4.64, 42: 4.73, 43: 4.82, 44: 4.91, 45: 5.00, 46: 5.09, 47: 5.18, 48: 5.27, 49: 5.36, 50: 5.45,\n    51: 5.55, 52: 5.64, 53: 5.73, 54: 5.82, 55: 5.91, 56: 6.00, 57: 6.09, 58: 6.18, 59: 6.27, 60: 6.36,\n    61: 6.45, 62: 6.55, 63: 6.64, 64: 6.73, 65: 6.82, 66: 6.91, 67: 7.00, 68: 7.09, 69: 7.18, 70: 7.27,\n    71: 7.36, 72: 7.45, 73: 7.55, 74: 7.64, 75: 7.73, 76: 7.82, 77: 7.91, 78: 8.00, 79: 8.09, 80: 8.18,\n    81: 8.27, 82: 8.36, 83: 8.45, 84: 8.55, 85: 8.64, 86: 8.73, 87: 8.82, 88: 8.91, 89: 9.00, 90: 9.09,\n    91: 9.18, 92: 9.27, 93: 9.36, 94: 9.45, 95: 9.55, 96: 9.64, 97: 9.73, 98: 9.82, 99: 9.91, 100: 10.00\n}\n\nintents = discord.Intents.default()\nintents.message_content = True\nbot = commands.Bot(command_prefix=['gs.', 'gs '], intents=intents)\n\n# Channel IDs\nTARGET_CHANNEL_ID = 1401169397850308708\nPET_VALUES_CHANNEL_IDS = [\n    1406716276373590117,  # PRISMATIC CATEGORY\n    1406716328697659583,  # DIVINE CATEGORY\n    1406716530326241451,  # MYTHIC CATEGORY\n    1406716596302385323,  # LEGENDARY CATEGORY\n    1406716645921263787,  # RARE CATEGORY\n    1406716717870223360,  # UNCOMMON CATEGORY\n    1406716764368404520   # COMMON CATEGORY\n]\nREPORT_CHANNEL_ID = 1403179951431094404\nAUTOMOD_REPORT_CHANNEL_ID = 1405317544507609180\n\n# Automod banned words\nBANNED_WORDS = [\n    'negr', 'gay', 'epstiened', 'fatass', 'dildo', 'vagina', '@everyone', 'nudes', 'epstein', 'diddy',\n    'fetish', 'bitch ass', 'bitchass', 'doxx', 'chong', 'nigga', 'anal', 'asshole', 'boob', 'didy',\n    'femboy', '𝗇𝗂𝗀𝗀𝖺', 'horny', 'whore', 'diddle', 'slut', 'sybau', 'lgbtq', 'drug', 'penis',\n    'goon', 'dick', 'pussy', 'twerk', 'porn', 'niger', 'fag', 'lgbt', 'slag', 'blackie',\n    'prostitute', 'nigger', 'retard', 'diddled', 'niggas', 'dih', 'feet', 'schlong'\n]\n\n# Country guessing game data\nCOUNTRIES_FLAGS = {\n    \"🇺🇸\": \"United States\", \"🇬🇧\": \"United Kingdom\", \"🇨🇦\": \"Canada\", \"🇦🇺\": \"Australia\", \"🇩🇪\": \"Germany\",\n    \"🇫🇷\": \"France\", \"🇮🇹\": \"Italy\", \"🇪🇸\": \"Spain\", \"🇯🇵\": \"Japan\", \"🇰🇷\": \"South Korea\", \"🇨🇳\": \"China\",\n    \"🇧🇷\": \"Brazil\", \"🇲🇽\": \"Mexico\", \"🇦🇷\": \"Argentina\", \"🇮🇳\": \"India\", \"🇷🇺\": \"Russia\", \"🇿🇦\": \"South Africa\",\n    \"🇪🇬\": \"Egypt\", \"🇳🇬\": \"Nigeria\", \"🇰🇪\": \"Kenya\", \"🇸🇪\": \"Sweden\", \"🇳🇴\": \"Norway\", \"🇩🇰\": \"Denmark\",\n    \"🇫🇮\": \"Finland\", \"🇳🇱\": \"Netherlands\", \"🇧🇪\": \"Belgium\", \"🇨🇭\": \"Switzerland\", \"🇦🇹\": \"Austria\",\n    \"🇵🇱\": \"Poland\", \"🇨🇿\": \"Czech Republic\", \"🇭🇺\": \"Hungary\", \"🇬🇷\": \"Greece\", \"🇹🇷\": \"Turkey\",\n    \"🇮🇪\": \"Ireland\", \"🇵🇹\": \"Portugal\", \"🇮🇸\": \"Iceland\", \"🇱🇺\": \"Luxembourg\", \"🇲🇹\": \"Malta\",\n    \"🇨🇾\": \"Cyprus\", \"🇧🇬\": \"Bulgaria\", \"🇷🇴\": \"Romania\", \"🇭🇷\": \"Croatia\", \"🇸🇮\": \"Slovenia\",\n    \"🇸🇰\": \"Slovakia\", \"🇪🇪\": \"Estonia\", \"🇱🇻\": \"Latvia\", \"🇱🇹\": \"Lithuania\", \"🇺🇦\": \"Ukraine\",\n    \"🇧🇾\": \"Belarus\", \"🇲🇩\": \"Moldova\", \"🇷🇸\": \"Serbia\", \"🇧🇦\": \"Bosnia and Herzegovina\", \"🇲🇪\": \"Montenegro\",\n    \"🇲🇰\": \"North Macedonia\", \"🇦🇱\": \"Albania\", \"🇽🇰\": \"Kosovo\", \"🇮🇱\": \"Israel\", \"🇯🇴\": \"Jordan\",\n    \"🇱🇧\": \"Lebanon\", \"🇸🇾\": \"Syria\", \"🇮🇶\": \"Iraq\", \"🇮🇷\": \"Iran\", \"🇸🇦\": \"Saudi Arabia\", \"🇦🇪\": \"UAE\",\n    \"🇰🇼\": \"Kuwait\", \"🇶🇦\": \"Qatar\", \"🇧🇭\": \"Bahrain\", \"🇴🇲\": \"Oman\", \"🇾🇪\": \"Yemen\", \"🇦🇫\": \"Afghanistan\",\n    \"🇵🇰\": \"Pakistan\", \"🇧🇩\": \"Bangladesh\", \"🇱🇰\": \"Sri Lanka\", \"🇳🇵\": \"Nepal\", \"🇧🇹\": \"Bhutan\",\n    \"🇲🇻\": \"Maldives\", \"🇹🇭\": \"Thailand\", \"🇻🇳\": \"Vietnam\", \"🇰🇭\": \"Cambodia\", \"🇱🇦\": \"Laos\",\n    \"🇲🇾\": \"Malaysia\", \"🇸🇬\": \"Singapore\", \"🇮🇩\": \"Indonesia\", \"🇵🇭\": \"Philippines\", \"🇧🇳\": \"Brunei\",\n    \"🇹🇱\": \"East Timor\", \"🇲🇳\": \"Mongolia\", \"🇰🇿\": \"Kazakhstan\", \"🇺🇿\": \"Uzbekistan\", \"🇰🇬\": \"Kyrgyzstan\",\n    \"🇹🇯\": \"Tajikistan\", \"🇹🇲\": \"Turkmenistan\", \"🇬🇪\": \"Georgia\", \"🇦🇲\": \"Armenia\", \"🇦🇿\": \"Azerbaijan\",\n    \"🇲🇦\": \"Morocco\", \"🇹🇳\": \"Tunisia\", \"🇩🇿\": \"Algeria\", \"🇱🇾\": \"Libya\", \"🇸🇩\": \"Sudan\", \"🇪🇭\": \"Western Sahara\",\n    \"🇲🇷\": \"Mauritania\", \"🇲🇱\": \"Mali\", \"🇧🇫\": \"Burkina Faso\", \"🇳🇪\": \"Niger\", \"🇹🇩\": \"Chad\",\n    \"🇸🇳\": \"Senegal\", \"🇬🇲\": \"Gambia\", \"🇬🇼\": \"Guinea-Bissau\", \"🇬🇳\": \"Guinea\", \"🇸🇱\": \"Sierra Leone\",\n    \"🇱🇷\": \"Liberia\", \"🇨🇮\": \"Ivory Coast\", \"🇬🇭\": \"Ghana\", \"🇹🇬\": \"Togo\", \"🇧🇯\": \"Benin\",\n    \"🇨🇲\": \"Cameroon\", \"🇨🇫\": \"Central African Republic\", \"🇹🇩\": \"Chad\", \"🇸🇸\": \"South Sudan\",\n    \"🇪🇹\": \"Ethiopia\", \"🇪🇷\": \"Eritrea\", \"🇩🇯\": \"Djibouti\", \"🇸🇴\": \"Somalia\", \"🇺🇬\": \"Uganda\",\n    \"🇷🇼\": \"Rwanda\", \"🇧🇮\": \"Burundi\", \"🇹🇿\": \"Tanzania\", \"🇲🇼\": \"Malawi\", \"🇿🇲\": \"Zambia\",\n    \"🇿🇼\": \"Zimbabwe\", \"🇧🇼\": \"Botswana\", \"🇳🇦\": \"Namibia\", \"🇱🇸\": \"Lesotho\", \"🇸🇿\": \"Eswatini\",\n    \"🇲🇬\": \"Madagascar\", \"🇲🇺\": \"Mauritius\", \"🇸🇨\": \"Seychelles\", \"🇰🇲\": \"Comoros\", \"🇨🇻\": \"Cape Verde\",\n    \"🇸🇹\": \"Sao Tome and Principe\", \"🇬🇶\": \"Equatorial Guinea\", \"🇬🇦\": \"Gabon\", \"🇨🇬\": \"Republic of the Congo\",\n    \"🇨🇩\": \"Democratic Republic of the Congo\", \"🇦🇴\": \"Angola\", \"🇧🇲\": \"Bermuda\", \"🇵🇷\": \"Puerto Rico\"\n}\n\n# Tracking systems\ninvite_cache = {}\nuser_invites = {}\nuser_message_counts = {}\ndaily_reset = None\nweekly_reset = None\nmonthly_reset = None\nWFL_PATTERN = re.compile(r'\\bwfl\\b', re.IGNORECASE)\nlast_reaction_time = {}\nreaction_cooldown = 1\n\n# Country game tracking\nactive_games = {}\n\n# Math game tracking\nactive_math_games = {}\n\n# Group game tracking\nactive_group_math_games = {}\nactive_group_country_games = {}\nactive_group_scramble_games = {}\nactive_group_wordbomb_games = {}\n\n# Word bomb game data\nSCRAMBLE_WORDS = [\n    \"algorithm\", \"computer\", \"keyboard\", \"monitor\", \"software\", \"hardware\", \"network\", \"internet\",\n    \"database\", \"programming\", \"javascript\", \"python\", \"discord\", \"gaming\", \"streaming\", \"challenge\",\n    \"adventure\", \"treasure\", \"mystery\", \"fantasy\", \"rainbow\", \"butterfly\", \"elephant\", \"dolphin\",\n    \"mountain\", \"ocean\", \"forest\", \"desert\", \"volcano\", \"galaxy\", \"planet\", \"asteroid\", \"comet\",\n    \"telescope\", \"microscope\", \"laboratory\", \"experiment\", \"discovery\", \"invention\", \"creativity\",\n    \"imagination\", \"inspiration\", \"motivation\", \"determination\", \"achievement\", \"success\", \"victory\",\n    \"friendship\", \"kindness\", \"happiness\", \"celebration\", \"festival\", \"carnival\", \"fireworks\",\n    \"chocolate\", \"strawberry\", \"pineapple\", \"watermelon\", \"hamburger\", \"sandwich\", \"restaurant\",\n    \"university\", \"library\", \"museum\", \"theater\", \"concert\", \"orchestra\", \"symphony\", \"melody\",\n    \"harmony\", \"rhythm\", \"photography\", \"painting\", \"sculpture\", \"architecture\", \"literature\"\n]\n\nWORDBOMB_SEQUENCES = [\n    \"ing\", \"tion\", \"ent\", \"er\", \"ly\", \"ed\", \"al\", \"an\", \"re\", \"th\", \"in\", \"on\", \"at\", \"st\", \"nd\",\n    \"ch\", \"sh\", \"ck\", \"ll\", \"ss\", \"ff\", \"pp\", \"tt\", \"dd\", \"mm\", \"nn\", \"rr\", \"bb\", \"gg\", \"zz\",\n    \"ough\", \"ight\", \"ould\", \"ance\", \"ence\", \"able\", \"ible\", \"ment\", \"ness\", \"less\", \"ful\", \"ous\"\n]\n\ndef reset_message_counts():\n    \"\"\"Reset message counts based on time periods\"\"\"\n    global daily_reset, weekly_reset, monthly_reset\n    now = discord.utils.utcnow()\n\n    if daily_reset is None or now > daily_reset:\n        for user_id in user_message_counts:\n            user_message_counts[user_id]['daily'] = 0\n        daily_reset = now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n        logger.info(\"Reset daily message counts\")\n\n    if weekly_reset is None or now > weekly_reset:\n        for user_id in user_message_counts:\n            user_message_counts[user_id]['weekly'] = 0\n        days_ahead = 6 - now.weekday()\n        weekly_reset = (now + timedelta(days=days_ahead)).replace(hour=0, minute=0, second=0, microsecond=0)\n        logger.info(\"Reset weekly message counts\")\n\n    if monthly_reset is None or now > monthly_reset:\n        for user_id in user_message_counts:\n            user_message_counts[user_id]['monthly'] = 0\n        if now.month == 12:\n            monthly_reset = now.replace(year=now.year + 1, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)\n        else:\n            monthly_reset = now.replace(month=now.month + 1, day=1, hour=0, minute=0, second=0, microsecond=0)\n        logger.info(\"Reset monthly message counts\")\n\nasync def cache_invites():\n    \"\"\"Cache all current invites\"\"\"\n    global invite_cache\n    try:\n        if bot.guilds:\n            invites = await bot.guilds[0].invites()\n            invite_cache = {invite.code: {'uses': invite.uses, 'inviter': invite.inviter} for invite in invites}\n            logger.info(f\"Cached {len(invite_cache)} invites\")\n    except Exception as e:\n        logger.error(f\"Error caching invites: {e}\")\n\ndef calculate_weight_multiplier(current_age, current_weight):\n    if current_age not in BASE_WEIGHTS:\n        return None\n    base_weight_at_current_age = BASE_WEIGHTS[current_age]\n    multiplier = current_weight / base_weight_at_current_age\n    return multiplier\n\ndef predict_weights(current_age, current_weight, target_ages=None):\n    multiplier = calculate_weight_multiplier(current_age, current_weight)\n    if multiplier is None:\n        return None\n\n    if target_ages is None:\n        target_ages = list(range(1, 101))\n\n    predictions = {}\n    for age in target_ages:\n        if age in BASE_WEIGHTS:\n            predicted_weight = BASE_WEIGHTS[age] * multiplier\n            predictions[age] = round(predicted_weight, 2)\n\n    return predictions\n\n# Automod Ban View\nclass AutomodBanView(discord.ui.View):\n    def __init__(self, user, message_content, channel):\n        super().__init__(timeout=300)\n        self.user = user\n        self.message_content = message_content\n        self.channel = channel\n\n    @discord.ui.button(label=\"🔨 Ban User\", style=discord.ButtonStyle.danger)\n    async def ban_user(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.ban_members:\n            await interaction.response.send_message(\"<:GsWrong:1414561861352816753>   You don't have permission to ban users.\", ephemeral=True)\n            return\n\n        try:\n            await self.user.ban(reason=f\"Automod violation: {self.message_content[:100]}\")\n\n            embed = discord.Embed(\n                title=\"🔨 User Banned Successfully\",\n                description=f\"{self.user.mention} has been banned for automod violation.\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"👮 Moderator\", value=interaction.user.mention, inline=True)\n            embed.add_field(name=\"📋 Reason\", value=f\"Automod violation: {self.message_content[:100]}\", inline=False)\n            embed.set_footer(text=\"🔥 Game Services Automod System\")\n\n            await interaction.edit_original_response(embed=embed, view=None)\n\n        except Exception as e:\n            await interaction.response.send_message(f\"<:GsWrong:1414561861352816753>   Error banning user: {str(e)}\", ephemeral=True)\n    @discord.ui.button(label=\"<:GsWrong:1414561861352816753> Dismiss\", style=discord.ButtonStyle.secondary)\n    async def dismiss_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.kick_members:\n            await interaction.response.send_message(\"<:GsWrong:1414561861352816753>   You don't have permission to dismiss reports.\", ephemeral=True)\n            return\n\n        embed = discord.Embed(\n            title=\"<:GsWrong:1414561861352816753>  Automod Report Dismissed\",\n            description=\"The automod report has been dismissed by a moderator.\",\n            color=0x808080,\n            timestamp=discord.utils.utcnow()\n        )\n        embed.add_field(name=\"👮 Dismissed By\", value=interaction.user.mention, inline=True)\n        embed.set_footer(text=\"🔥 Game Services Automod System\")\n\n        await interaction.edit_original_response(embed=embed, view=None)\n\n@bot.event\nasync def on_ready():\n    logger.info(f'{bot.user} has connected to Discord!')\n    logger.info(f'Bot is in {len(bot.guilds)} guilds')\n    \n    # Debug: List all registered commands\n    logger.info(f\"Total commands registered: {len(list(bot.commands))}\")\n    logger.info(f\"Registered commands: {[cmd.name for cmd in bot.commands]}\")\n    logger.info(f\"Commands with aliases: {[(cmd.name, cmd.aliases) for cmd in bot.commands if cmd.aliases]}\")\n    \n    # Test if petvalue command specifically exists\n    petvalue_cmd = bot.get_command('petvalue')\n    v_cmd = bot.get_command('v')\n    logger.info(f\"petvalue command found: {petvalue_cmd is not None}\")\n    logger.info(f\"v alias found: {v_cmd is not None}\")\n    \n    # Test command loading\n    if len(list(bot.commands)) == 0:\n        logger.error(\"🚨 CRITICAL: No commands registered! This is the problem!\")\n    else:\n        logger.info(f\"<:GsRight:1414593140156792893>  Commands successfully registered: {len(list(bot.commands))} total\")\n\n    # Initialize database tables\n    try:\n        mod_db.init_database()\n        logger.info(\"Database tables initialized successfully\")\n    except Exception as e:\n        logger.error(f\"Error initializing database: {e}\")\n\n    load_pet_data()\n    await cache_invites()\n    reset_message_counts()\n\n    target_channel = bot.get_channel(TARGET_CHANNEL_ID)\n    if target_channel:\n        logger.info(f'Monitoring channel: {target_channel.name} ({target_channel.id})')\n\n    logger.info(f'Pet database loaded with {len(PET_DATABASE)} pets (auto-scanning disabled)')\n    \n    # Debug command registration at the end\n    logger.info(\"🔍 FINAL COMMAND DEBUG:\")\n    logger.info(f\"Total commands registered: {len(list(bot.commands))}\")\n    logger.info(f\"Registered commands: {[cmd.name for cmd in bot.commands]}\")\n    logger.info(f\"Commands with aliases: {[(cmd.name, cmd.aliases) for cmd in bot.commands if cmd.aliases]}\")\n    \n    # Test specific commands\n    petvalue_cmd = bot.get_command('petvalue')\n    v_cmd = bot.get_command('v')\n    logger.info(f\"petvalue command found: {petvalue_cmd is not None}\")\n    logger.info(f\"v alias found: {v_cmd is not None}\")\n    \n    if len(list(bot.commands)) == 0:\n        logger.error(\"🚨 CRITICAL: No commands registered at end of on_ready!\")\n    else:\n        logger.info(f\"<:GsRight:1414593140156792893>  ON_READY COMPLETE: {len(list(bot.commands))} commands active\")\n\n@bot.event\nasync def on_disconnect():\n    logger.warning(\"Bot disconnected from Discord!\")\n\n@bot.event\nasync def on_resumed():\n    logger.info(\"Bot reconnected to Discord!\")\n\n@bot.event\nasync def on_message(message):\n    if message.author.bot:\n        return\n\n    # Track message counts\n    user_id = message.author.id\n    if user_id not in user_message_counts:\n        user_message_counts[user_id] = {'daily': 0, 'weekly': 0, 'monthly': 0, 'last_message': discord.utils.utcnow()}\n\n    reset_message_counts()\n\n    user_message_counts[user_id]['daily'] += 1\n    user_message_counts[user_id]['weekly'] += 1\n    user_message_counts[user_id]['monthly'] += 1\n    user_message_counts[user_id]['last_message'] = discord.utils.utcnow()\n\n    # Chat guide message system - only track messages in the specific channel\n    channel_id = message.channel.id\n    if channel_id == CHAT_GUIDE_CHANNEL_ID:\n        if channel_id not in channel_message_counts:\n            channel_message_counts[channel_id] = 0\n\n        channel_message_counts[channel_id] += 1\n\n        # Check if we should send chat guide message\n        if channel_message_counts[channel_id] % CHAT_GUIDE_INTERVAL == 0:\n            # Check cooldown to prevent spam (5 minute cooldown)\n            current_time = discord.utils.utcnow()\n            if channel_id not in chat_guide_cooldown or \\\n               (current_time - chat_guide_cooldown[channel_id]).total_seconds() > 300:\n                try:\n                    await message.channel.send(CHAT_GUIDE_MESSAGE)\n                    chat_guide_cooldown[channel_id] = current_time\n                    logger.info(f\"Sent chat guide message in {message.channel.name} after {channel_message_counts[channel_id]} messages\")\n                except Exception as e:\n                    logger.error(f\"Error sending chat guide message: {e}\")\n\n    # Automoderation check (skip admins)\n    is_admin = message.author.guild_permissions.manage_guild or message.author.guild_permissions.administrator\n\n    if not is_admin:\n        message_lower = message.content.lower()\n        for banned_word in BANNED_WORDS:\n            if banned_word.lower() in message_lower:\n                try:\n                    # Delete the message with error handling\n                    try:\n                        await message.delete()\n                        message_deleted = True\n                    except discord.NotFound:\n                        logger.info(f\"Message already deleted by {message.author}\")\n                        message_deleted = False\n                    except discord.Forbidden:\n                        logger.warning(f\"No permission to delete message by {message.author}\")\n                        message_deleted = False\n                    except Exception as del_error:\n                        logger.error(f\"Error deleting message: {del_error}\")\n                        message_deleted = False\n\n                    # Warn and mute the user with permission checks\n                    duration_minutes = 10\n                    timeout_duration = timedelta(minutes=duration_minutes)\n\n                    # Check if bot can timeout users\n                    bot_member = message.guild.get_member(bot.user.id)\n                    if not bot_member or not bot_member.guild_permissions.moderate_members:\n                        logger.error(f\"Bot missing moderate_members permission for automod\")\n                        continue\n\n                    # Check role hierarchy\n                    if message.author.top_role >= bot_member.top_role:\n                        logger.warning(f\"Cannot automod {message.author} - role hierarchy\")\n                        continue\n\n                    try:\n                        await message.author.timeout(timeout_duration, reason=f\"Automod: Used banned word '{banned_word}'\")\n                        timeout_success = True\n                    except discord.Forbidden as timeout_error:\n                        logger.error(f\"Permission error timing out {message.author}: {timeout_error}\")\n                        timeout_success = False\n                    except Exception as timeout_error:\n                        logger.error(f\"Error timing out {message.author}: {timeout_error}\")\n                        timeout_success = False\n\n                    # Log in database with error handling\n                    try:\n                        action_id = mod_db.add_moderation_action(\n                            user_id=message.author.id,\n                            moderator_id=bot.user.id,\n                            server_id=message.guild.id,\n                            action_type=\"warn\",\n                            reason=f\"Automod: Used banned word '{banned_word}'\"\n                        )\n\n                        if timeout_success:\n                            mod_db.add_moderation_action(\n                                user_id=message.author.id,\n                                moderator_id=bot.user.id,\n                                server_id=message.guild.id,\n                                action_type=\"mute\",\n                                reason=f\"Automod: Used banned word '{banned_word}'\",\n                                duration_minutes=duration_minutes\n                            )\n                        database_logged = True\n                    except Exception as db_error:\n                        logger.error(f\"Database error in automod: {db_error}\")\n                        database_logged = False\n\n                    # Send to automod report channel\n                    automod_channel = bot.get_channel(AUTOMOD_REPORT_CHANNEL_ID)\n                    if automod_channel:\n                        embed = discord.Embed(\n                            title=\"⚠️ Automod Violation Detected\",\n                            description=f\"User {message.author.mention} has been automatically warned and muted.\",\n                            color=0xFFC916,\n                            timestamp=discord.utils.utcnow()\n                        )\n                        embed.add_field(name=\"👤 User\", value=f\"{message.author.mention} ({message.author})\", inline=False)\n                        embed.add_field(name=\"📍 Channel\", value=f\"{message.channel.mention}\", inline=True)\n                        embed.add_field(name=\"🚫 Triggered Word\", value=f\"||{banned_word}||\", inline=True)\n                        embed.add_field(name=\"💬 Message Content\", value=f\"||{message.content[:500]}||\", inline=False)\n                        actions_taken = []\n                        if database_logged:\n                            actions_taken.append(\"• Warned user\")\n                        if timeout_success:\n                            actions_taken.append(\"• Muted for 10 minutes\")\n                        if message_deleted:\n                            actions_taken.append(\"• Message deleted\")\n\n                        if not actions_taken:\n                            actions_taken.append(\"• No actions taken (permission errors)\")\n\n                        embed.add_field(name=\"⚡ Actions Taken\", value=\"\\n\".join(actions_taken), inline=False)\n                        embed.set_footer(text=\"🔥 Game Services Automod System\")\n\n                        view = AutomodBanView(message.author, message.content, message.channel)\n                        await automod_channel.send(embed=embed, view=view)\n\n                    # DM the user (only if any action was taken)\n                    if timeout_success or database_logged:\n                        try:\n                            dm_embed = discord.Embed(\n                                title=\"⚠️ Automod Warning\",\n                                description=\"Your message contained inappropriate content and has been removed.\",\n                                color=0xFFC916,\n                                timestamp=discord.utils.utcnow()\n                            )\n                            dm_embed.add_field(name=\"🏠 Server\", value=f\"{message.guild.name}\", inline=True)\n                            if timeout_success:\n                                dm_embed.add_field(name=\"⏱️ Mute Duration\", value=\"10 minutes\", inline=True)\n                            dm_embed.add_field(name=\"📋 Reason\", value=f\"Used inappropriate word: ||{banned_word}||\", inline=False)\n                            dm_embed.add_field(name=\"🚨 Appeal\", value=\"If you believe this was a mistake, contact staff in our appeals server:\\nhttps://discord.gg/ahharETNNR\", inline=False)\n                            dm_embed.set_footer(text=\"🔥 Game Services Automod System\")\n\n                            await message.author.send(embed=dm_embed)\n                        except discord.Forbidden:\n                            logger.info(f\"Cannot DM {message.author} - DMs disabled\")\n                        except Exception as dm_error:\n                            logger.error(f\"Error sending automod DM: {dm_error}\")\n\n                except Exception as e:\n                    logger.error(f\"Unexpected error in automod for {message.author}: {e}\")\n                    # Continue processing other banned words\n\n                return  # Stop processing if automod triggered\n\n    # Check for group math game answers\n    if message.channel.id in active_group_math_games:\n        game = active_group_math_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            if message.content.strip().replace('-', '').isdigit():\n                user_answer = int(message.content.strip())\n                if user_answer == game['answer']:\n                    # Award point\n                    if user_id not in game['players']:\n                        game['players'][user_id] = 0\n                    game['players'][user_id] += 1\n                    game['answered_this_round'].add(user_id)\n\n                    # React to show it was correct\n                    try:\n                        await message.add_reaction('<:GsRight:1414593140156792893> ')\n                    except:\n                        pass\n\n    # Check for group country game answers\n    if message.channel.id in active_group_country_games:\n        game = active_group_country_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            if message.content.lower().strip() == game['country'].lower():\n                # Award point\n                if user_id not in game['players']:\n                    game['players'][user_id] = 0\n                game['players'][user_id] += 1\n                game['answered_this_round'].add(user_id)\n\n                # React to show it was correct\n                try:\n                    await message.add_reaction('<:GsRight:1414593140156792893>')\n                except:\n                    pass\n\n    # Check for group scramble game answers\n    if message.channel.id in active_group_scramble_games:\n        game = active_group_scramble_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            if message.content.lower().strip() == game['word'].lower():\n                # Award point\n                if user_id not in game['players']:\n                    game['players'][user_id] = 0\n                game['players'][user_id] += 1\n                game['answered_this_round'].add(user_id)\n\n                # React to show it was correct\n                try:\n                    await message.add_reaction('<:GsRight:1414593140156792893> ')\n                except:\n                    pass\n\n    # Check for group wordbomb game answers\n    if message.channel.id in active_group_wordbomb_games:\n        game = active_group_wordbomb_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            answer = message.content.lower().strip()\n            # Enhanced validation for proper words\n            if (len(answer) >= 3 and\n                game['sequence'].lower() in answer and\n                answer.isalpha() and\n                answer not in game['used_words'] and\n                is_valid_word(answer, game['sequence'])):\n\n                # Award point\n                if user_id not in game['players']:\n                    game['players'][user_id] = 0\n                game['players'][user_id] += 1\n                game['answered_this_round'].add(user_id)\n                game['used_words'].add(answer)\n\n                # React to show it was correct\n                try:\n                    await message.add_reaction('<:GsRight:1414593140156792893> ')\n                except:\n                    pass\n\n    # Process commands\n    await bot.process_commands(message)\n\n    # WFL reactions\n    if message.channel.id == TARGET_CHANNEL_ID:\n        if WFL_PATTERN.search(message.content):\n            current_time = asyncio.get_event_loop().time()\n            if (message.channel.id in last_reaction_time and\n                current_time - last_reaction_time[message.channel.id] < reaction_cooldown):\n                return\n\n            last_reaction_time[message.channel.id] = current_time\n\n            reactions = ['W1', 'F1', 'L1']\n            try:\n                for emoji_name in reactions:\n                    emoji = discord.utils.get(message.guild.emojis, name=emoji_name)\n                    if emoji:\n                        await message.add_reaction(emoji)\n                    await asyncio.sleep(0.5)\n            except Exception as e:\n                logger.error(f'Error adding reactions: {e}')\n\n@bot.command()\nasync def petweight(ctx, current_age: int, current_weight: float, target_age: Optional[int] = None):\n    \"\"\"🐾 Calculate pet weight at different ages\"\"\"\n    try:\n        if current_age < 1 or current_age > 100:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Pet Age must be between 1 and 100\")\n            return\n\n        if current_weight <= 0:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Pet Weight must be greater than 0\")\n            return\n\n        if target_age is not None:\n            if target_age < 1 or target_age > 100:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Pet Target age must be between 1 and 100\")\n                return\n\n            predictions = predict_weights(current_age, current_weight, [target_age])\n            if predictions is None:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid Pet age provided\")\n                return\n            predicted_weight = predictions[target_age]\n            embed = discord.Embed(\n                title=\"Petweight Prediction\",\n                url=\"https://discord.gg/4Jy4R8kMaf\",  # <- clickable title link\n                color=0xFFC916\n            )\n            embed.add_field(name=\"Current Info:\", value=f\"**Age:** {current_age} \\n**Weight:** {current_weight} <:KG:1414601553167519864>  \", inline=False)\n            \n            embed.add_field(name=f\"Predicted Weight at Age {target_age}\", value=f\"**{predicted_weight} <:KG:1414601553167519864> ** \", inline=False)\n            \n            embed.set_footer(text=\"🔥 Game Services • Pet Weight Calculator\")\n            \n            await ctx.reply(embed=embed, mention_author=True)\n            await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n\n        else:\n            predictions = predict_weights(current_age, current_weight)\n            if predictions is None:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid age provided\")\n                return\n\n            key_ages = []\n            for age in range(current_age, min(current_age + 11, 101)):\n                if age in predictions:\n                    key_ages.append(age)\n\n            if len(key_ages) < 10:\n                for age in range(max(1, current_age - 5), current_age):\n                    if age in predictions and age not in key_ages:\n                        key_ages.insert(0, age)\n\n            key_ages = sorted(key_ages)[:10]\n\n            embed = discord.Embed(\n                title=\"Petweight Prediction\",\n                url=\"https://discord.gg/4Jy4R8kMaf\",  # <- clickable title link\n                color=0xFFC916\n            )\n            embed.add_field(name=\" Current Info:\", value=f\"**Age:** {current_age} 📅\\n**Weight:** {current_weight} <:KG:1414601553167519864> \", inline=False)\n\n            weight_text = \"\"\n            for age in key_ages:\n                marker = \" ← **Current**\" if age == current_age else \"\"\n                weight_text += f\"**Age {age}:** {predictions[age]} kg{marker}\\n\"\n\n            embed.add_field(name=\"Weight Predictions:\", value=weight_text, inline=False)\n            embed.add_field(name=\"Tip:\", value=\"Use `gs.petweight <age> <weight> <target_age>` to predict weight at a specific age\", inline=False)\n            embed.set_footer(text=\"🔥 Game Services • Pet Weight Calculator\")\n\n            await ctx.reply(embed=embed, mention_author=True)\n            await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n\n    except ValueError:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   Please provide valid numbers for age and weight\")\n    except Exception as e:\n        logger.error(f\"Error in petweight command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while calculating weights\")\n\n@bot.command(aliases=['v', 'value', 'val'])\nasync def petvalue(ctx, *, pet_name: str):\n    \"\"\"🐾 Look up pet value information\"\"\"\n    try:\n        # Lazy fallback: Load pets if database is empty \n        if not PET_DATABASE:\n            logger.warning(\"PET_DATABASE is empty, attempting to reload...\")\n            load_pet_data()\n            \n        logger.info(f\"🔍 Pet value lookup for '{pet_name}' - Database has {len(PET_DATABASE)} pets\")\n        # Enhanced search\n        clean_name = re.sub(r'[^\\w\\s]', '', pet_name).strip().lower().replace(' ', '_')\n\n        # Direct match first\n        exact_match = None\n        for key, pet_data in PET_DATABASE.items():\n            if key == clean_name or pet_data['name'].lower() == pet_name.lower():\n                exact_match = pet_data\n                break\n\n        if exact_match:\n            embed = discord.Embed(\n                title=exact_match['name'],\n                url=\"https://discord.gg/4Jy4R8kMaf\",  # <- clickable title link\n                color=0xFFC916\n            )\n            embed.set_author(\n                name=\"Game Services Values\",\n                icon_url=\"https://images-ext-1.discordapp.net/external/o1Y_94Itjl4AeBMbyiY7Xow1UI36KpW2nqWOJ1bZcT0/%3Fsize%3D1024/https/cdn.discordapp.com/avatars/1381546186183278612/19ed5075b4b08f29a41dd99d080c31e9.png?format=webp&quality=lossless\"  # <- must be a direct image link\n            )\n\n            embed.add_field(name=\"<:ExclamationMark:1412880724809482260>  Pets are valued based on Mimic  <:MimicOctopus:1412404639164403752>\", value=\"> 1KG Mimic = 100 Value\", inline=False)\n            \n            embed.add_field(name=\"Value\", value=f\"{exact_match['value']} <:Sheckles:1412881740099223582>  \", inline=True)\n            \n            embed.add_field(name=\"Demand\", value=f\"{exact_match['demand']}\", inline=True)\n\n            embed.add_field(\n                name=\"Trend\",\n                value=exact_match.get(\"trend\") or \"Adding\",\n                inline=True\n            )\n            embed.add_field(\n                name=\"Tier\",\n                value=exact_match.get(\"tier\") or \"Adding\",\n                inline=True\n            )\n            embed.add_field(\n                name=\"Obtained By\",\n                value=exact_match.get(\"obtainement\") or \"Adding\",\n                inline=True\n            )\n\n            if 'image_url' in exact_match and exact_match['image_url']:\n                try:\n                    # Clean the image URL and ensure it's properly formatted\n                    image_url = exact_match['image_url'].strip()\n                    # Remove 'lossless' parameter if present\n                    if 'quality=lossless' in image_url:\n                        image_url = image_url.replace('&quality=lossless', '').replace('quality=lossless&', '').replace('quality=lossless', '')\n                    embed.set_thumbnail(url=image_url)\n                    logger.info(f\"<:GsRight:1414593140156792893>  Successfully displaying image for {exact_match['name']}\")\n                except Exception as e:\n                    logger.error(f\"<:GsWrong:1414561861352816753>   Error setting image for {exact_match['name']}: {e}\")\n            else:\n                logger.warning(f\"No image available for {exact_match['name']}\")\n\n            embed.set_footer(text=\"🔥 Game Services • Info: (100% match)\")\n\n            from discord.ui import View, Button\n\n            # build ONE link-button view\n            view = View()\n\n            # first button\n            view.add_item(Button(\n                label=\"Suggest Values\",\n                url=\"https://discord.com/channels/1370086525210984458/1391747223884136590\",\n                style=discord.ButtonStyle.link\n            ))\n\n            # second button\n            view.add_item(Button(\n                label=\"Values Explained\",\n                url=\"https://discord.com/channels/1370086525210984458/1370101881308713193/1406781226018406450\",\n                style=discord.ButtonStyle.link\n            ))\n            # send a single reply with the embed + button\n            try:\n                reply_msg = await ctx.reply(embed=embed, view=view, mention_author=True)\n            except Exception as e:\n                # fallback if sending with a view fails for any reason\n                print(f\"\")\n                reply_msg = await ctx.reply(embed=embed, mention_author=True)\n\n            # add reaction to the original message (the one that triggered the command)\n            try:\n                await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n            except Exception as e:\n                # Ignore/log permission/emoji errors\n                print(f\"\")\n\n            return\n\n\n\n        # Fuzzy search\n        best_matches = find_best_pet_matches(pet_name, max_results=5)\n        if best_matches:\n            # Auto-select best match\n            top_match = best_matches[0]\n            pet_data = top_match[0]  # dict for the pet\n\n            embed = discord.Embed(\n                title=pet_data[\"name\"],  \n                url=\"https://discord.gg/4Jy4R8kMaf\",\n                color=0xFFC916\n            )\n\n            embed.set_author(\n                name=\"Game Services Values\",\n                icon_url=\"https://cdn.discordapp.com/avatars/1381546186183278612/19ed5075b4b08f29a41dd99d080c31e9.png?size=1024\"\n            )\n\n            embed.add_field(\n                name=\"<:ExclamationMark:1412880724809482260>  Pets are valued based on Mimic  <:MimicOctopus:1412404639164403752>\",\n                value=\"> 1KG Mimic = 100 Value\",\n                inline=False\n            )\n\n            embed.add_field(\n                name=\"Value\",\n                value=f\"{pet_data['value']} <:Sheckles:1412881740099223582>\",\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Demand\",\n                value=pet_data[\"demand\"],\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Trend\",\n                value=pet_data[\"trend\"],\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Tier\",\n                value=pet_data[\"tier\"],\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Obtained By\",\n                value=pet_data[\"obtainement\"],\n                inline=True\n            )\n\n            # <:GsRight:1414593140156792893>  Add thumbnail if available\n            if 'image_url' in pet_data and pet_data['image_url']:\n                try:\n                    image_url = pet_data['image_url'].strip()\n                    if 'quality=lossless' in image_url:\n                        image_url = image_url.replace('&quality=lossless', '').replace('quality=lossless&', '').replace('quality=lossless', '')\n                    embed.set_thumbnail(url=image_url)\n                    logger.info(f\"<:GsRight:1414593140156792893>  Successfully displaying image for {pet_data['name']}\")\n                except Exception as e:\n                    logger.error(f\"<:GsWrong:1414561861352816753>   Error setting image for {pet_data['name']}: {e}\")\n            else:\n                logger.warning(f\"No image available for {pet_data['name']}\")\n\n            # <:GsRight:1414593140156792893>  Add footer after match quality\n            footer_text = \"🔥 Game Services • INSTANT UPDATES\"\n            if top_match[1] < 100:\n                footer_text = f\"🔥 Game Services • Info: ({top_match[1]}% match)\"\n            embed.set_footer(text=footer_text)\n\n            from discord.ui import View, Button\n\n            # build ONE link-button view\n            view = View()\n\n            # first button\n            view.add_item(Button(\n                label=\"Suggest Values\",\n                url=\"https://discord.com/channels/1370086525210984458/1391747223884136590\",\n                style=discord.ButtonStyle.link\n            ))\n\n            # second button\n            view.add_item(Button(\n                label=\"Values Explained\",\n                url=\"https://discord.com/channels/1370086525210984458/1370101881308713193/1406781226018406450\",\n                style=discord.ButtonStyle.link\n            ))\n            # send a single reply with the embed + button\n            try:\n                reply_msg = await ctx.reply(embed=embed, view=view, mention_author=True)\n            except Exception as e:\n                # fallback if sending with a view fails for any reason\n                print(f\"\")\n                reply_msg = await ctx.reply(embed=embed, mention_author=True)\n\n            # add reaction to the original message (the one that triggered the command)\n            try:\n                await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n            except Exception as e:\n                # Ignore/log permission/emoji errors\n                print(f\"\")\n\n            return\n\n        else:\n            await ctx.reply(f\"**{pet_name}** could not be found\")\n\n            try:\n                await ctx.message.add_reaction('<:GsWrong:1414561861352816753>')\n            except:\n                pass\n\n    except Exception as e:\n        logger.error(f\"Error in petvalue command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while looking up pet values\")\n\n@bot.command(name=\"forceupdate\", aliases=['force', 'refresh'])\nasync def force_update_pets(ctx):\n    \"\"\"🔄 Force update pet database by rescanning all pet value channels (Admin only)\"\"\"\n    if not ctx.author.guild_permissions.administrator:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You need administrator permissions to force update the database.\")\n        return\n\n@bot.command(aliases=['pets', 'list'])\nasync def petlist(ctx, page: int = 1):\n    \"\"\"📋 List all pets in the database\"\"\"\n    try:\n        if not PET_DATABASE:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   No pets found in database\")\n            return\n\n        pets_per_page = 15\n        total_pets = len(PET_DATABASE)\n        total_pages = (total_pets + pets_per_page - 1) // pets_per_page\n\n        if page < 1 or page > total_pages:\n            await ctx.send(f\"<:GsWrong:1414561861352816753>   Invalid page number. Pages available: 1-{total_pages}\")\n            return\n\n        start_idx = (page - 1) * pets_per_page\n        end_idx = start_idx + pets_per_page\n\n        pets = list(PET_DATABASE.values())[start_idx:end_idx]\n\n        embed = discord.Embed(title=\"🐾 Pet Database\", color=0xFFC916)\n        embed.add_field(name=\"📊 Total Pets\", value=f\"**{total_pets}** pets 🎯\", inline=True)\n        embed.add_field(name=\"📄 Page\", value=f\"**{page}/{total_pages}** 📋\", inline=True)\n        embed.add_field(name=\"🔄 Auto-Updated\", value=\"**Real-time** ⚡\", inline=True)\n\n        pet_list = \"\"\n        for pet in pets:\n            demand_emoji = {\"High\": \"🔥\", \"Medium\": \"📈\", \"Low\": \"📉\", \"Extremely High\": \"💎\", \"Terrible\": \"💀\"}.get(pet['demand'], \"📊\")\n            pet_list += f\"• **{pet['name']}** - {pet['value']} | {pet['demand']} {demand_emoji}\\n\"\n\n        embed.add_field(name=\"🐾 Pets\", value=pet_list or \"No pets on this page\", inline=False)\n\n        if page < total_pages:\n            embed.add_field(name=\"💡 Navigation\", value=f\"Use `gs.petlist {page + 1}` for next page ➡️\\nUse `gs.v <name>` to get detailed info 🔍\", inline=False)\n        else:\n            embed.add_field(name=\"💡 Usage\", value=\"Use `gs.v <name>` to get detailed pet info 🔍\", inline=False)\n\n        embed.set_footer(text=\"🔥 Game Services • AUTO-SCAN ALL MESSAGES\")\n        await ctx.send(embed=embed)\n\n    except Exception as e:\n        logger.error(f\"Error in petlist command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while listing pets\")\n\n@bot.command(aliases=['country', 'flag', 'guess'])\nasync def countryguess(ctx):\n    \"\"\"🌍 Start a country guessing game\"\"\"\n    if ctx.channel.id in active_games:\n        await ctx.send(\"🎮 A game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Select random country\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    active_games[ctx.channel.id] = {\n        'country': country,\n        'players': {},\n        'round': 1,\n        'max_rounds': 5,\n        'start_time': discord.utils.utcnow()\n    }\n\n    embed = discord.Embed(\n        title=\"🌍 Country Guessing Game Started!\",\n        description=f\"**Round 1/5:** What country does this flag belong to? 🤔\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"15 seconds per round ⏱️\", inline=True)\n    embed.add_field(name=\"🎯 How to Play\", value=\"Just type the country name! 💬\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"First correct answer gets a point! 🥇\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Anyone can play!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.lower().strip() == country.lower())\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        # Award point\n        user_id = winner_msg.author.id\n        if user_id not in active_games[ctx.channel.id]['players']:\n            active_games[ctx.channel.id]['players'][user_id] = 0\n        active_games[ctx.channel.id]['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"🎉 {winner_msg.author.mention} got it right! That's **{country}**.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Great job!\")\n        await ctx.send(embed=embed)\n\n        # Continue game or end\n        if active_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_games[ctx.channel.id]['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"⏰ Time's Up!\",\n            description=f\"No one got it! The answer was **{country}** {flag}\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Better luck next time!\")\n        await ctx.send(embed=embed)\n\n        if active_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_games[ctx.channel.id]['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\nasync def continue_country_game(ctx):\n    \"\"\"Continue the country guessing game\"\"\"\n    if ctx.channel.id not in active_games:\n        return\n\n    game = active_games[ctx.channel.id]\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    game['country'] = country\n\n    embed = discord.Embed(\n        title=\"🌍 Country Guessing Game\",\n        description=f\"**Round {game['round']}/5:** What country does this flag belong to? 🤔\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"15 seconds ⏱️\", inline=True)\n    embed.add_field(name=\"🏆 Current Scores\", value=\"\\n\".join([f\"<@{uid}>: {score} 🎯\" for uid, score in game['players'].items()]) if game['players'] else \"No scores yet 📊\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Keep guessing!\")\n\n    await ctx.send(embed=embed)\n\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.lower().strip() == country.lower())\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        user_id = winner_msg.author.id\n        if user_id not in game['players']:\n            game['players'][user_id] = 0\n        game['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"🎉 {winner_msg.author.mention} got it right! That's **{country}**.\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"⏰ Time's Up!\",\n            description=f\"No one got it! The answer was **{country}** {flag}\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\nasync def end_country_game(ctx):\n    \"\"\"End the country guessing game and show results\"\"\"\n    if ctx.channel.id not in active_games:\n        return\n\n    game = active_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"🎮 Game Over!\",\n            description=\"No one scored any points! Better luck next time! 😅\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            leaderboard += f\"{medal} <@{user_id}>: **{score}** points\\n\"\n\n        embed = discord.Embed(\n            title=\"🎮 Game Over! Final Scores:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"🏆 Winner\", value=f\"🎉 <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"🔄 Play Again\", value=\"Use `gs.countryguess` to start a new game! 🌍\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_games[ctx.channel.id]\n\n@bot.command(name=\"mathquestions\", aliases=['math', 'mathgame', 'mathquiz'])\nasync def mathquestions(ctx):\n    \"\"\"🧮 Start a math questions game\"\"\"\n    if ctx.channel.id in active_math_games:\n        await ctx.send(\"🎮 A math game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Generate first math question\n    num1, num2, operation, answer = generate_math_question()\n    active_math_games[ctx.channel.id] = {\n        'answer': answer,\n        'players': {},\n        'round': 1,\n        'max_rounds': 5,\n        'start_time': discord.utils.utcnow()\n    }\n\n    embed = discord.Embed(\n        title=\"🧮 Math Questions Game Started!\",\n        description=f\"**Round 1/5:** What is the answer to this equation? 🤔\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"15 seconds per round ⏱️\", inline=True)\n    embed.add_field(name=\"🎯 How to Play\", value=\"Just type the number! 💬\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"First correct answer gets a point! 🥇\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Anyone can play!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.strip().replace('-', '').isdigit() and\n                int(m.content.strip()) == answer)\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        # Award point\n        user_id = winner_msg.author.id\n        if user_id not in active_math_games[ctx.channel.id]['players']:\n            active_math_games[ctx.channel.id]['players'][user_id] = 0\n        active_math_games[ctx.channel.id]['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"🎉 {winner_msg.author.mention} got it right! The answer was **{answer}**.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Great job!\")\n        await ctx.send(embed=embed)\n\n        # Continue game or end\n        if active_math_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_math_games[ctx.channel.id]['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"⏰ Time's Up!\",\n            description=f\"No one got it! The answer was **{answer}**\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Better luck next time!\")\n        await ctx.send(embed=embed)\n\n        if active_math_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_math_games[ctx.channel.id]['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\ndef generate_math_question():\n    \"\"\"Generate a random math question\"\"\"\n    operations = ['+', '-', '*', '/']\n    operation = random.choice(operations)\n\n    if operation == '+':\n        num1 = random.randint(10, 100)\n        num2 = random.randint(10, 100)\n        answer = num1 + num2\n    elif operation == '-':\n        num1 = random.randint(20, 100)\n        num2 = random.randint(10, num1)  # Ensure positive result\n        answer = num1 - num2\n    elif operation == '*':\n        num1 = random.randint(2, 15)\n        num2 = random.randint(2, 15)\n        answer = num1 * num2\n    else:  # division\n        answer = random.randint(2, 20)\n        num2 = random.randint(2, 12)\n        num1 = answer * num2  # Ensure clean division\n        operation = '÷'\n\n    return num1, num2, operation, answer\n\nasync def continue_math_game(ctx):\n    \"\"\"Continue the math game\"\"\"\n    if ctx.channel.id not in active_math_games:\n        return\n\n    game = active_math_games[ctx.channel.id]\n    num1, num2, operation, answer = generate_math_question()\n    game['answer'] = answer\n\n    embed = discord.Embed(\n        title=\"🧮 Math Questions Game\",\n        description=f\"**Round {game['round']}/5:** What is the answer to this equation? 🤔\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"15 seconds ⏱️\", inline=True)\n    embed.add_field(name=\"🏆 Current Scores\", value=\"\\n\".join([f\"<@{uid}>: {score} 🎯\" for uid, score in game['players'].items()]) if game['players'] else \"No scores yet 📊\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Keep calculating!\")\n\n    await ctx.send(embed=embed)\n\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.strip().replace('-', '').isdigit() and\n                int(m.content.strip()) == answer)\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        user_id = winner_msg.author.id\n        if user_id not in game['players']:\n            game['players'][user_id] = 0\n        game['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"🎉 {winner_msg.author.mention} got it right! The answer was **{answer}**.\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"⏰ Time's Up!\",\n            description=f\"No one got it! The answer was **{answer}**\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\nasync def end_math_game(ctx):\n    \"\"\"End the math game and show results\"\"\"\n    if ctx.channel.id not in active_math_games:\n        return\n\n    game = active_math_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"🎮 Game Over!\",\n            description=\"No one scored any points! Better luck next time! 😅\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            leaderboard += f\"{medal} <@{user_id}>: **{score}** points\\n\"\n\n        embed = discord.Embed(\n            title=\"🎮 Game Over! Final Scores:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"🏆 Winner\", value=f\"🎉 <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"🔄 Play Again\", value=\"Use `gs.mathquestions` to start a new game! 🧮\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_math_games[ctx.channel.id]\n\n@bot.command(name=\"groupmath\", aliases=['gmath', 'groupmathgame', 'mgame'])\nasync def group_math_game(ctx):\n    \"\"\"🧮 Start a group math game where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_math_games:\n        await ctx.send(\"🎮 A group math game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"🧮 Group Math Game - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the group math challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"🎯 How to Play\", value=\"Answer math questions as fast as you can! 💬\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"1 point for each correct answer! 🥇\", inline=True)\n    embed.add_field(name=\"📊 Rounds\", value=\"10 questions total 📝\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Generate first math question\n    num1, num2, operation, answer = generate_math_question()\n    active_group_math_games[ctx.channel.id] = {\n        'answer': answer,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"🧮 Group Math Game Started!\",\n        description=f\"**Round 1/10:** 🤔\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"20 seconds per round ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(participants)} joined! 🎯\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"1 point for each correct answer! 🥇\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Group Math Challenge!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(20)  # Give 20 seconds for everyone to answer\n    await continue_group_math_game(ctx)\n\n@bot.command(name=\"groupcountriesquiz\", aliases=['gcountry', 'groupcountry', 'gcountries', 'countrygame', 'countries', 'flags'])\nasync def group_country_quiz(ctx):\n    \"\"\"🌍 Start a group countries quiz where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_country_games:\n        await ctx.send(\"🎮 A group countries quiz is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"🌍 Group Countries Quiz - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the geography challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"🎯 How to Play\", value=\"Guess country names from flags! 🏳️\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"1 point for each correct guess! 🥇\", inline=True)\n    embed.add_field(name=\"📊 Rounds\", value=\"10 flags total 🌍\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Select random country\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    active_group_country_games[ctx.channel.id] = {\n        'country': country,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"🌍 Group Countries Quiz Started!\",\n        description=f\"**Round 1/10:** Guess this country! 🤔\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"20 seconds per round ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(participants)} joined! 🎯\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"1 point for each correct answer! 🥇\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Group Geography Challenge!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(20)  # Give 20 seconds for everyone to answer\n    await continue_group_country_game(ctx)\n\nasync def continue_group_math_game(ctx):\n    \"\"\"Continue the group math game\"\"\"\n    if ctx.channel.id not in active_group_math_games:\n        return\n\n    game = active_group_math_games[ctx.channel.id]\n\n    # Show who got the last question right\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answers!\",\n            description=f\"🎉 **{len(correct_users)}** players got it right!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"📊 Answer\", value=f\"**{game['answer']}**\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_math_game(ctx)\n        return\n\n    # Clear answered set for new round\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new question\n    num1, num2, operation, answer = generate_math_question()\n    game['answer'] = answer\n\n    embed = discord.Embed(\n        title=\"🧮 Group Math Game\",\n        description=f\"**Round {game['round']}/10:** What's the answer? 🤔\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"15 seconds ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(game['players'])} participating 🎯\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Keep calculating!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(20)\n    await continue_group_math_game(ctx)\n\nasync def continue_group_country_game(ctx):\n    \"\"\"Continue the group country game\"\"\"\n    if ctx.channel.id not in active_group_country_games:\n        return\n\n    game = active_group_country_games[ctx.channel.id]\n\n    # Show who got the last question right\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answers!\",\n            description=f\"🎉 **{len(correct_users)}** players got it right!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"🌍 Answer\", value=f\"**{game['country']}**\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_country_game(ctx)\n        return\n\n    # Clear answered set for new round\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new country\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    game['country'] = country\n\n    embed = discord.Embed(\n        title=\"🌍 Group Countries Quiz\",\n        description=f\"**Round {game['round']}/10:** What country is this? 🤔\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"15 seconds ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(game['players'])} participating 🎯\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Keep guessing!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(20)\n    await continue_group_country_game(ctx)\n\nasync def end_group_math_game(ctx):\n    \"\"\"End the group math game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_math_games:\n        return\n\n    game = active_group_math_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"🎮 Group Math Game Over!\",\n            description=\"No one participated! Better luck next time! 😅\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            percentage = int((score / game['max_rounds']) * 100)\n            leaderboard += f\"{medal} <@{user_id}>: **{score}/{game['max_rounds']}** ({percentage}%)\\n\"\n\n        embed = discord.Embed(\n            title=\"🎮 Group Math Game Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"🏆 Winner\", value=f\"🎉 <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"📊 Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** questions asked\", inline=True)\n        embed.add_field(name=\"🔄 Play Again\", value=\"Use `gs.groupmath` to start a new game! 🧮\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_math_games[ctx.channel.id]\n\nasync def end_group_country_game(ctx):\n    \"\"\"End the group country game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_country_games:\n        return\n\n    game = active_group_country_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"🎮 Group Countries Quiz Over!\",\n            description=\"No one participated! Better luck next time! 😅\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            percentage = int((score / game['max_rounds']) * 100)\n            leaderboard += f\"{medal} <@{user_id}>: **{score}/{game['max_rounds']}** ({percentage}%)\\n\"\n\n        embed = discord.Embed(\n            title=\"🎮 Group Countries Quiz Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"🏆 Winner\", value=f\"🎉 <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"📊 Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** questions asked\", inline=True)\n        embed.add_field(name=\"🔄 Play Again\", value=\"Use `gs.groupcountriesquiz` to start a new game! 🌍\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_country_games[ctx.channel.id]\n\n@bot.command(name=\"groupscramble\", aliases=['gscramble', 'groupunscramble', 'gunscramble', 'scramble', 'unscramble', 'wordgame'])\nasync def group_scramble_game(ctx):\n    \"\"\"🔤 Start a group word scramble game where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_scramble_games:\n        await ctx.send(\"🎮 A group scramble game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"🔤 Group Word Scramble - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the word scramble challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"🎯 How to Play\", value=\"Unscramble mixed up words! 🔤\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"1 point for each word solved! 🥇\", inline=True)\n    embed.add_field(name=\"📊 Rounds\", value=\"10 words total 📝\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Select random word and scramble it\n    word = random.choice(SCRAMBLE_WORDS)\n    scrambled = scramble_word(word)\n\n    active_group_scramble_games[ctx.channel.id] = {\n        'word': word,\n        'scrambled': scrambled,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"🔤 Group Word Scramble Started!\",\n        description=f\"**Round 1/10:** Unscramble this word! 🤔\\n\\n{scrambled.upper()}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"20 seconds per round ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(participants)} joined! 🎯\", inline=True)\n    embed.add_field(name=\"💡 Hint\", value=f\"The word has **{len(word)}** letters\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Group Word Challenge!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(20)  # Give 20 seconds for everyone to answer\n    await continue_group_scramble_game(ctx)\n\ndef scramble_word(word):\n    \"\"\"Scramble a word by shuffling its letters\"\"\"\n    word_list = list(word)\n    random.shuffle(word_list)\n    scrambled = ''.join(word_list)\n\n    # Make sure it's actually scrambled\n    attempts = 0\n    while scrambled.lower() == word.lower() and attempts < 10:\n        random.shuffle(word_list)\n        scrambled = ''.join(word_list)\n        attempts += 1\n\n    return scrambled\n\ndef is_valid_word(word, sequence):\n    \"\"\"Validate that a word is proper for wordbomb (prevents cheating like 'chhhh')\"\"\"\n    # Basic checks\n    if len(word) < 3:\n        return False\n\n    # Must contain the sequence\n    if sequence.lower() not in word.lower():\n        return False\n\n    # Check for excessive repetition (like \"chhhh\") - STRICT VALIDATION\n    char_counts = {}\n    for char in word:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # For sequences like \"ch\", prevent words like \"chhhh\" by limiting consecutive repeats\n    sequence_chars = set(sequence.lower())\n    for char in sequence_chars:\n        if char in char_counts and char_counts[char] > 2:\n            # Special case: if the sequence is just repeated chars (like \"chhhh\"), reject it\n            if word.lower().count(char * 3) > 0:  # 3+ consecutive same chars\n                return False\n\n    # No single character should appear more than 3 times total\n    max_repeats = max(char_counts.values())\n    if max_repeats > 3:\n        return False\n\n    # Prevent words that are just the sequence repeated\n    if word.lower() == sequence.lower() * (len(word) // len(sequence)):\n        return False\n\n    # Check for reasonable word structure (vowels and consonants)\n    vowels = set('aeiou')\n    has_vowel = any(char in vowels for char in word)\n    has_consonant = any(char not in vowels and char.isalpha() for char in word)\n\n    # Must have at least one vowel and one consonant for longer words\n    if len(word) > 3 and not (has_vowel and has_consonant):\n        return False\n\n    # Prevent nonsense words that are just repeated characters\n    unique_chars = len(set(word.lower()))\n    if unique_chars < 2 and len(word) > 3:  # Words like \"aaaa\" or \"bbbb\"\n        return False\n\n    return True\n\nasync def continue_group_scramble_game(ctx):\n    \"\"\"Continue the group scramble game\"\"\"\n    if ctx.channel.id not in active_group_scramble_games:\n        return\n\n    game = active_group_scramble_games[ctx.channel.id]\n\n    # Show who got the last question right\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answers!\",\n            description=f\"🎉 **{len(correct_users)}** players got it right!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"📝 Answer\", value=f\"**{game['word'].upper()}**\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_scramble_game(ctx)\n        return\n\n    # Clear answered set for new round\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new scramble\n    word = random.choice(SCRAMBLE_WORDS)\n    scrambled = scramble_word(word)\n    game['word'] = word\n    game['scrambled'] = scrambled\n\n    embed = discord.Embed(\n        title=\"🔤 Group Word Scramble\",\n        description=f\"**Round {game['round']}/10:** Unscramble this word! 🤔\\n\\n**{scrambled.upper()}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"20 seconds ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(game['players'])} participating 🎯\", inline=True)\n    embed.add_field(name=\"💡 Hint\", value=f\"The word has **{len(word)}** letters\", inline=False)\n    embed.set_footer(text=\"🔥 Game Services • Keep unscrambling!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(20)\n    await continue_group_scramble_game(ctx)\n\nasync def end_group_scramble_game(ctx):\n    \"\"\"End the group scramble game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_scramble_games:\n        return\n\n    game = active_group_scramble_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"🎮 Group Word Scramble Over!\",\n            description=\"No one participated! Better luck next time! 😅\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            percentage = int((score / game['max_rounds']) * 100)\n            leaderboard += f\"{medal} <@{user_id}>: **{score}/{game['max_rounds']}** ({percentage}%)\\n\"\n\n        embed = discord.Embed(\n            title=\"🎮 Group Word Scramble Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"🏆 Winner\", value=f\"🎉 <@{winner_id}> with **{winner_score}** words!\", inline=False)\n\n        embed.add_field(name=\"📊 Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** words scrambled\", inline=True)\n        embed.add_field(name=\"🔄 Play Again\", value=\"Use `gs.groupscramble` to start a new game! 🔤\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_scramble_games[ctx.channel.id]\n\n@bot.command(name=\"groupwordbomb\", aliases=['gwordbomb', 'groupbomb', 'gbomb', 'wordbomb', 'bomb'])\nasync def group_wordbomb_game(ctx):\n    \"\"\"💣 Start a group word bomb game where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_wordbomb_games:\n        await ctx.send(\"🎮 A group word bomb game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"💣 Group Word Bomb - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the word bomb challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"🎯 How to Play\", value=\"Make words with given letter sequences! 💣\", inline=True)\n    embed.add_field(name=\"🏆 Scoring\", value=\"1 point for each valid word! 🥇\", inline=True)\n    embed.add_field(name=\"📊 Rounds\", value=\"10 sequences total 💥\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Select random letter sequence\n    sequence = random.choice(WORDBOMB_SEQUENCES)\n\n    active_group_wordbomb_games[ctx.channel.id] = {\n        'sequence': sequence,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'used_words': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"💣 Group Word Bomb Started!\",\n        description=f\"**Round 1/10:** Make words containing! 💥\\n\\n**{sequence.upper()}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"25 seconds per round ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(participants)} joined! 🎯\", inline=True)\n    embed.add_field(name=\"📋 Rules\", value=\"At least 3 letters, no repeats!\", inline=True)\n    embed.set_footer(text=\"🔥 Game Services • Group Word Bomb!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(25)  # Give 25 seconds for everyone to answer\n    await continue_group_wordbomb_game(ctx)\n\nasync def continue_group_wordbomb_game(ctx):\n    \"\"\"Continue the group word bomb game\"\"\"\n    if ctx.channel.id not in active_group_wordbomb_games:\n        return\n\n    game = active_group_wordbomb_games[ctx.channel.id]\n\n    # Show who got words this round\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"💥 Words Found!\",\n            description=f\"🎉 **{len(correct_users)}** players found valid words!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"🔤 Sequence\", value=f\"**{game['sequence'].upper()}**\", inline=True)\n        embed.add_field(name=\"📊 Words Found\", value=f\"**{len(game['used_words'])}** total\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_wordbomb_game(ctx)\n        return\n\n    # Clear answered set for new round but keep used words\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new sequence\n    sequence = random.choice(WORDBOMB_SEQUENCES)\n    game['sequence'] = sequence\n    game['used_words'].clear()  # Reset used words for new sequence\n\n    embed = discord.Embed(\n        title=\"💣 Group Word Bomb\",\n        description=f\"**Round {game['round']}/10:** Make words containing! 💥\\n\\n**{sequence.upper()}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"⏰ Time Limit\", value=\"25 seconds ⏱️\", inline=True)\n    embed.add_field(name=\"👥 Players\", value=f\"{len(game['players'])} participating 🎯\", inline=True)\n    embed.add_field(name=\"📋 Remember\", value=\"At least 3 letters, no repeats!\", inline=False)\n    embed.set_footer(text=\"🔥 Game Services • Keep bombing!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(25)\n    await continue_group_wordbomb_game(ctx)\n\nasync def end_group_wordbomb_game(ctx):\n    \"\"\"End the group word bomb game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_wordbomb_games:\n        return\n\n    game = active_group_wordbomb_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"🎮 Group Word Bomb Over!\",\n            description=\"No one participated! Better luck next time! 😅\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            leaderboard += f\"{medal} <@{user_id}>: **{score}** words found\\n\"\n\n        embed = discord.Embed(\n            title=\"🎮 Group Word Bomb Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"🏆 Winner\", value=f\"🎉 <@{winner_id}> with **{winner_score}** words!\", inline=False)\n\n        embed.add_field(name=\"📊 Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** sequences bombed\", inline=True)\n        embed.add_field(name=\"🔄 Play Again\", value=\"Use `gs.groupwordbomb` to start a new game! 💣\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services • Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_wordbomb_games[ctx.channel.id]\n\n@bot.command(name=\"c\", aliases=[\"calc\", \"calculator\"])\nasync def calculate(ctx, *, expression: str):\n    \"\"\"🧮 Calculator feature - Calculate math expressions\"\"\"\n    try:\n        # Replace common symbols with Python operators\n        expression = expression.replace('x', '*').replace('X', '*').replace('÷', '/').replace('×', '*')\n\n        # Remove spaces\n        expression = expression.replace(' ', '')\n\n        # Basic validation - only allow numbers, operators, and parentheses\n        allowed_chars = set('0123456789+-*/.,()')\n        if not all(c in allowed_chars for c in expression):\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid characters in expression. Use only numbers and operators (+, -, *, /, x)\")\n            return\n\n        # Evaluate the expression safely\n        try:\n            result = eval(expression)\n\n            # Format result nicely\n            if isinstance(result, float):\n                if result.is_integer():\n                    result = int(result)\n                else:\n                    result = round(result, 6)  # Round to 6 decimal places\n\n            embed = discord.Embed(\n                title=\"🧮 Calculator Result\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"📝 Expression\", value=f\"`{expression}`\", inline=False)\n            embed.add_field(name=\"🎯 Result\", value=f\"**{result}**\", inline=False)\n            embed.add_field(name=\"💡 Usage\", value=\"Try: `gs.c 4+11`, `gs.c 4/11`, `gs.c 4x11`, `gs.c (5+3)*2`\", inline=False)\n            embed.set_footer(text=\"🔥 Game Services • Calculator\")\n\n            await ctx.send(embed=embed)\n\n        except ZeroDivisionError:\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Calculation Error\",\n                description=\"Cannot divide by zero!\",\n                color=0xFFC916\n            )\n            embed.add_field(name=\"📝 Expression\", value=f\"`{expression}`\", inline=False)\n            embed.set_footer(text=\"🔥 Game Services • Calculator\")\n            await ctx.send(embed=embed)\n\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Calculation Error\",\n                description=\"Invalid mathematical expression!\",\n                color=0xFFC916\n            )\n            embed.add_field(name=\"📝 Expression\", value=f\"`{expression}`\", inline=False)\n            embed.add_field(name=\"💡 Tip\", value=\"Make sure your expression is valid. Example: `gs.c 4+11`\", inline=False)\n            embed.set_footer(text=\"🔥 Game Services • Calculator\")\n            await ctx.send(embed=embed)\n\n    except Exception as e:\n        logger.error(f\"Error in calculator command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while calculating the expression.\")\n\n@bot.command(name=\"m\", aliases=[\"messages\", \"msgs\"])\nasync def show_messages(ctx, user: discord.Member = None):\n    \"\"\"📊 Show message statistics for a user\"\"\"\n    target_user = user or ctx.author\n    user_id = target_user.id\n\n    if user_id not in user_message_counts:\n        user_message_counts[user_id] = {'daily': 0, 'weekly': 0, 'monthly': 0, 'last_message': discord.utils.utcnow()}\n\n    data = user_message_counts[user_id]\n\n    embed = discord.Embed(title=\"📊 Message Statistics\", color=0xFFC916, timestamp=discord.utils.utcnow())\n    embed.set_thumbnail(url=target_user.display_avatar.url)\n\n    embed.add_field(name=\"📅 Daily Messages\", value=f\"**{data['daily']}** messages 📝\", inline=True)\n    embed.add_field(name=\"📄 Weekly Messages\", value=f\"**{data['weekly']}** messages 📚\", inline=True)\n    embed.add_field(name=\"📚 Monthly Messages\", value=f\"**{data['monthly']}** messages 📖\", inline=True)\n\n    if data['last_message']:\n        last_msg_time = data['last_message']\n        time_ago = discord.utils.utcnow() - last_msg_time\n        if time_ago.days > 0:\n            last_msg_str = f\"{time_ago.days} days ago 📅\"\n        elif time_ago.seconds > 3600:\n            last_msg_str = f\"{time_ago.seconds // 3600} hours ago ⏰\"\n        elif time_ago.seconds > 60:\n            last_msg_str = f\"{time_ago.seconds // 60} minutes ago ⏱️\"\n        else:\n            last_msg_str = \"Just now 🕐\"\n\n        embed.add_field(name=\"⏰ Last Message\", value=last_msg_str, inline=True)\n\n    embed.add_field(name=\"👤 User\", value=f\"{target_user.mention} 🎯\", inline=False)\n    embed.set_footer(text=\"🔥 Game Services • Message Tracking System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"msgtop\", aliases=[\"messageleaderboard\", \"msgleaderboard\"])\nasync def message_leaderboard(ctx, period: str = \"daily\"):\n    \"\"\"🏆 Show top message senders\"\"\"\n    if period.lower() not in ['daily', 'weekly', 'monthly']:\n        embed = discord.Embed(\n            title=\"<:GsWrong:1414561861352816753>   Invalid Period\",\n            description=\"Please specify: `daily`, `weekly`, or `monthly` 📅\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n        return\n\n    if not user_message_counts:\n        embed = discord.Embed(\n            title=f\"📊 {period.title()} Message Leaderboard\",\n            description=\"No message data available yet. 📊\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n        return\n\n    # Sort by the specified period\n    leaderboard = []\n    for user_id, data in user_message_counts.items():\n        count = data[period.lower()]\n        if count > 0:\n            leaderboard.append((user_id, count))\n\n    leaderboard.sort(key=lambda x: x[1], reverse=True)\n    leaderboard = leaderboard[:10]  # Top 10\n\n    embed = discord.Embed(\n        title=f\"🏆 {period.title()} Message Leaderboard\",\n        description=f\"Top 10 most active members ({period.lower()}) 💬\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n\n    leaderboard_text = \"\"\n    for i, (user_id, count) in enumerate(leaderboard, 1):\n        user = bot.get_user(user_id)\n        if user:\n            medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n            leaderboard_text += f\"{medal} {user.mention}: **{count}** messages 📝\\n\"\n\n    if leaderboard_text:\n        embed.add_field(name=\"📋 Rankings\", value=leaderboard_text, inline=False)\n    else:\n        embed.add_field(name=\"📋 Rankings\", value=\"No active users found 😴\", inline=False)\n\n    embed.add_field(name=\"🔄 Refresh\", value=f\"Use `gs.msgtop {period}` to update 📊\", inline=False)\n    embed.set_footer(text=\"🔥 Game Services • Message Tracking System\")\n    await ctx.send(embed=embed)\n\n# Moderation commands and views (kept from original code)\nclass ReportConfirmationView(discord.ui.View):\n    def __init__(self, user, reporter, reason, report_channel, report_embed):\n        super().__init__(timeout=300)\n        self.user = user\n        self.reporter = reporter\n        self.reason = reason\n        self.report_channel = report_channel\n        self.report_embed = report_embed\n        self.confirmed = None\n\n    @discord.ui.button(label=\"Submit Report\", style=discord.ButtonStyle.danger, emoji=\"🚨\")\n    async def submit_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.reporter:\n            try:\n                await interaction.response.send_message(\"Only the reporter can submit this report.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            await interaction.response.defer()\n\n            self.confirmed = True\n\n            # Send to report channel with staff moderation view\n            staff_view = StaffModerationView(self.user, self.reporter, self.reason)\n            await self.report_channel.send(embed=self.report_embed, view=staff_view)\n\n            # Confirmation to reporter\n            confirm_embed = discord.Embed(\n                title=\"<:GsRight:1414593140156792893>  Report Submitted Successfully\",\n                description=f\"Your report against {self.user.mention} has been sent to the moderation team.\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            confirm_embed.add_field(name=\"📋 Reason\", value=self.reason, inline=False)\n            confirm_embed.add_field(name=\"⏱️ Next Steps\",\n                                   value=\"Our moderation team will review this report. Thank you for helping keep our community safe!\",\n                                   inline=False)\n            confirm_embed.set_footer(text=f\"🔥 Game Services Report System • Report ID: {interaction.message.id}\")\n\n            try:\n                await interaction.edit_original_response(embed=confirm_embed, view=None)\n            except discord.errors.NotFound:\n                await interaction.followup.send(embed=confirm_embed, ephemeral=True)\n            self.stop()\n        except Exception as e:\n            logger.error(f\"Error submitting report: {e}\")\n            try:\n                await interaction.followup.send(\"Report submitted successfully!\", ephemeral=True)\n            except:\n                pass\n\n    @discord.ui.button(label=\"Cancel Report\", style=discord.ButtonStyle.secondary, emoji=\"<:GsWrong:1414561861352816753>  \")\n    async def cancel_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.reporter:\n            try:\n                await interaction.response.send_message(\"Only the reporter can cancel this report.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            await interaction.response.defer()\n\n            self.confirmed = False\n            cancel_embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Report Cancelled\",\n                description=\"Your report has been cancelled and will not be sent to the moderation team.\",\n                color=0x808080\n            )\n            try:\n                await interaction.edit_original_response(embed=cancel_embed, view=None)\n            except discord.errors.NotFound:\n                await interaction.followup.send(embed=cancel_embed, ephemeral=True)\n            self.stop()\n        except Exception as e:\n            logger.error(f\"Error cancelling report: {e}\")\n            try:\n                await interaction.followup.send(\"Report cancelled.\", ephemeral=True)\n            except:\n                pass\n\nclass StaffModerationView(discord.ui.View):\n    def __init__(self, reported_user, reporter, reason):\n        super().__init__(timeout=3600)  # 1 hour timeout\n        self.reported_user = reported_user\n        self.reporter = reporter\n        self.reason = reason\n\n    @discord.ui.button(label=\"Approve Report\", style=discord.ButtonStyle.success, emoji=\"<:GsRight:1414593140156792893>\")\n    async def approve_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.kick_members:\n            try:\n                await interaction.response.send_message(\"You don't have permission to moderate reports.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            # Create moderation action view\n            mod_view = QuickModerationView(self.reported_user, interaction.user, self.reason)\n\n            embed = discord.Embed(\n                title=\"<:GsRight:1414593140156792893>  Report Approved - Choose Action\",\n                description=f\"Report against {self.reported_user.mention} has been approved by {interaction.user.mention}\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"📋 Original Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"👤 Reporter\", value=self.reporter.mention, inline=True)\n            embed.add_field(name=\"👮 Reviewing Staff\", value=interaction.user.mention, inline=True)\n            embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            await interaction.response.edit_message(embed=embed, view=mod_view)\n        except Exception as e:\n            logger.error(f\"Error approving report: {e}\")\n            try:\n                await interaction.response.defer()\n                await interaction.followup.send(\"Report approved successfully!\", ephemeral=True)\n            except:\n                pass\n\n    @discord.ui.button(label=\"Deny Report\", style=discord.ButtonStyle.danger, emoji=\"<:GsWrong:1414561861352816753>  \")\n    async def deny_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.kick_members:\n            try:\n                await interaction.response.send_message(\"You don't have permission to moderate reports.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Report Denied\",\n                description=f\"Report against {self.reported_user.mention} has been denied by {interaction.user.mention}\",\n                color=0x808080,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"📋 Original Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"👤 Reporter\", value=self.reporter.mention, inline=True)\n            embed.add_field(name=\"👮 Reviewing Staff\", value=interaction.user.mention, inline=True)\n            embed.add_field(name=\"📝 Status\", value=\"No action taken - Report deemed invalid\", inline=False)\n            embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            await interaction.response.edit_message(embed=embed, view=None)\n        except Exception as e:\n            logger.error(f\"Error denying report: {e}\")\n            try:\n                await interaction.response.defer()\n                await interaction.followup.send(\"Report denied successfully!\", ephemeral=True)\n            except:\n                pass\n\nclass QuickModerationView(discord.ui.View):\n    def __init__(self, user, moderator, reason, reporter=None):\n        super().__init__(timeout=1800)  # 30 minutes timeout\n        self.user = user\n        self.moderator = moderator\n        self.reason = f\"Report violation: {reason}\"\n        self.reporter = reporter\n\n    @discord.ui.button(label=\"Warn\", style=discord.ButtonStyle.secondary, emoji=\"⚠️\")\n    async def quick_warn(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"warn\")\n\n    @discord.ui.button(label=\"Mute 5m\", style=discord.ButtonStyle.primary, emoji=\"🔇\")\n    async def quick_mute_5m(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"mute\", \"5m\")\n\n    @discord.ui.button(label=\"Mute 10m\", style=discord.ButtonStyle.primary, emoji=\"🔇\")\n    async def quick_mute_10m(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"mute\", \"10m\")\n\n    @discord.ui.button(label=\"Mute 20m\", style=discord.ButtonStyle.primary, emoji=\"🔇\")\n    async def quick_mute_20m(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"mute\", \"20m\")\n\n    @discord.ui.button(label=\"Kick\", style=discord.ButtonStyle.danger, emoji=\"👢\")\n    async def quick_kick(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"kick\")\n\n    async def execute_quick_action(self, interaction, action_type, duration=None):\n        try:\n            if action_type == \"warn\":\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"warn\",\n                    reason=self.reason\n                )\n\n            elif action_type == \"mute\":\n                duration_minutes = parse_duration(duration)\n                if duration_minutes and duration_minutes > 0:\n                    # Discord timeout max is 28 days, ensure we don't exceed it\n                    max_minutes = 28 * 24 * 60  # 28 days in minutes\n                    duration_minutes = min(duration_minutes, max_minutes)\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=duration_minutes)\n                    await self.user.timeout(timeout_until, reason=self.reason)\n                else:\n                    # Default to 10 minutes if parsing fails\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=10)\n                    await self.user.timeout(timeout_until, reason=self.reason)\n                    duration_minutes = 10\n\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"mute\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            elif action_type == \"kick\":\n                await interaction.guild.kick(self.user, reason=self.reason)\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"kick\",\n                    reason=self.reason\n                )\n\n            # Send DM to user\n            dm_success = await self.send_dm_notification(action_type, duration)\n\n            # Create success embed\n            if action_type == \"warn\": title = \"⚠️ Warning Issued\"\n            elif action_type == \"mute\": title = f\"🔇 User Muted for {duration}\"\n            elif action_type == \"kick\": title = \"👢 User Kicked\"\n\n            embed = discord.Embed(\n                title=f\"{title} Successfully\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"👤 User\", value=f\"{self.user.mention} ({self.user})\", inline=False)\n            embed.add_field(name=\"👮 Moderator\", value=f\"{self.moderator.mention}\", inline=True)\n            embed.add_field(name=\"📋 Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"🆔 Action ID\", value=f\"#{action_id}\", inline=True)\n            embed.add_field(name=\"💬 DM Status\", value=\"<:GsRight:1414593140156792893>  Sent\" if dm_success else \"<:GsWrong:1414561861352816753>   Failed\", inline=True)\n            embed.add_field(name=\"📊 Database\", value=\"<:GsRight:1414593140156792893>  Logged\", inline=True)\n            if self.reporter:\n                embed.add_field(name=\"👤 Original Reporter\", value=self.reporter.mention, inline=True)\n            embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            await interaction.edit_original_response(embed=embed, view=None)\n\n        except Exception as e:\n            logger.error(f\"Error executing quick action {action_type}: {e}\")\n            await interaction.response.send_message(f\"Error executing {action_type}: {str(e)}\", ephemeral=True)\n\n    async def send_dm_notification(self, action_type, duration=None):\n        \"\"\"Send DM notification to the user and return success status\"\"\"\n        try:\n            if action_type == \"warn\":\n                title = \"⚠️ You Have Been Warned\"\n                description = \"You have been warned in the server\"\n            elif action_type == \"mute\":\n                title = \"🔇 You Have Been Muted\"\n                description = \"You have been muted from the server\"\n            elif action_type == \"kick\":\n                title = \"👢 You Have Been Kicked\"\n                description = \"You have been kicked from the server\"\n            else:\n                title = f\"You have been {action_type}\"\n                description = f\"You have been {action_type} from the server\"\n\n            embed = discord.Embed(\n                title=title,\n                description=description,\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"🏠 Server\", value=f\"{self.moderator.guild.name} (Roblox)\", inline=True)\n            embed.add_field(name=\"👤 Moderator\", value=f\"{self.moderator} (on study arc)\", inline=True)\n            if duration:\n                embed.add_field(name=\"⏱️ Duration\", value=duration, inline=True)\n            embed.add_field(name=\"📋 Reason\", value=self.reason, inline=False)\n            embed.add_field(\n                name=\"🚨 Appeal Process\",\n                value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\\n🔗 https://discord.gg/ahharETNNR\",\n                inline=False\n            )\n            embed.set_footer(text=\"🔥 Game Services Moderation System • Today at \" + discord.utils.utcnow().strftime(\"%I:%M %p\"))\n\n            await self.user.send(embed=embed)\n            return True\n        except Exception as e:\n            logger.error(f\"Error sending DM to {self.user}: {e}\")\n            return False\n\n# Confirmation View for moderation actions\nclass ConfirmationView(discord.ui.View):\n    def __init__(self, action_type, user, moderator, reason, duration=None):\n        super().__init__(timeout=300)\n        self.action_type = action_type\n        self.user = user\n        self.moderator = moderator\n        self.reason = reason\n        self.duration = duration\n\n    @discord.ui.button(label=\"Confirm\", style=discord.ButtonStyle.danger, emoji=\"<:GsRight:1414593140156792893> \")\n    async def confirm_action(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.moderator:\n            try:\n                await interaction.response.send_message(\"Only the moderator can confirm this action.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            # Acknowledge the interaction first\n            await interaction.response.defer()\n\n            # Check bot permissions first\n            bot_member = interaction.guild.get_member(interaction.client.user.id)\n            if not bot_member:\n                await interaction.followup.send(\"<:GsWrong:1414561861352816753>   Error: Bot member not found in guild.\", ephemeral=True)\n                return\n\n            # Check if bot can perform the action\n            permission_check = self.check_bot_permissions(bot_member, interaction.guild)\n            if not permission_check[\"success\"]:\n                await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Bot Missing Permissions**\\n{permission_check['error']}\", ephemeral=True)\n                return\n\n            # Check role hierarchy\n            if self.user.top_role >= bot_member.top_role:\n                await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Role Hierarchy Error**\\nI cannot {self.action_type} {self.user.mention} because their role is equal to or higher than mine.\\n\\n**Solution:** Move my role above theirs in Server Settings → Roles.\", ephemeral=True)\n                return\n\n            if self.action_type == \"warn\":\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"warn\",\n                    reason=self.reason\n                )\n\n            elif self.action_type == \"mute\":\n                duration_minutes = parse_duration(self.duration)\n                if duration_minutes and duration_minutes > 0:\n                    # Discord timeout max is 28 days, ensure we don't exceed it\n                    max_minutes = 28 * 24 * 60  # 28 days in minutes\n                    duration_minutes = min(duration_minutes, max_minutes)\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=duration_minutes)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n• Bot missing `Moderate Members` permission\\n• Target user has higher role than bot\\n• Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                else:\n                    # Default to 10 minutes if parsing fails\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=10)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n• Bot missing `Moderate Members` permission\\n• Target user has higher role than bot\\n• Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                    duration_minutes = 10\n\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"mute\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            elif self.action_type == \"kick\":\n                try:\n                    await interaction.guild.kick(self.user, reason=self.reason)\n                except discord.Forbidden as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot kick {self.user.mention}\\n\\n**Possible causes:**\\n• Bot missing `Kick Members` permission\\n• Target user has higher role than bot\\n• Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                    return\n                except Exception as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Kick Failed**: {str(e)}\", ephemeral=True)\n                    return\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"kick\",\n                    reason=self.reason\n                )\n\n            elif self.action_type == \"ban\":\n                duration_minutes = None\n                if self.duration and self.duration != \"permanent\":\n                    duration_minutes = parse_duration(self.duration)\n\n                try:\n                    await interaction.guild.ban(self.user, reason=self.reason)\n                except discord.Forbidden as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot ban {self.user.mention}\\n\\n**Possible causes:**\\n• Bot missing `Ban Members` permission\\n• Target user has higher role than bot\\n• Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                    return\n                except Exception as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Ban Failed**: {str(e)}\", ephemeral=True)\n                    return\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"ban\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            elif self.action_type == \"mutewarn\":\n                # First apply the warning\n                warn_action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"warn\",\n                    reason=self.reason\n                )\n\n                # Then apply the mute\n                duration_minutes = parse_duration(self.duration)\n                if duration_minutes and duration_minutes > 0:\n                    # Discord timeout max is 28 days, ensure we don't exceed it\n                    max_minutes = 28 * 24 * 60  # 28 days in minutes\n                    duration_minutes = min(duration_minutes, max_minutes)\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=duration_minutes)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n• Bot missing `Moderate Members` permission\\n• Target user has higher role than bot\\n• Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                else:\n                    # Default to 10 minutes if parsing fails\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=10)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n• Bot missing `Moderate Members` permission\\n• Target user has higher role than bot\\n• Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                    duration_minutes = 10\n\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"mute\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            # Send DM to user\n            dm_success = await self.send_dm_notification()\n\n            # Create success embed\n            action_titles = {\n                \"warn\": \"⚠️ Warning Issued\",\n                \"mute\": f\"🔇 User Muted for {self.duration}\",\n                \"kick\": \"👢 User Kicked\",\n                \"ban\": f\"🔨 User Banned ({self.duration})\",\n                \"mutewarn\": f\"⚠️🔇 User Warned + Muted for {self.duration}\"\n            }\n\n            embed = discord.Embed(\n                title=f\"{action_titles[self.action_type]} Successfully\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"👤 User\", value=f\"{self.user.mention} ({self.user})\", inline=False)\n            embed.add_field(name=\"👮 Moderator\", value=f\"{self.moderator.mention}\", inline=True)\n            embed.add_field(name=\"🏠 Server\", value=f\"{interaction.guild.name}\", inline=True)\n            embed.add_field(name=\"📋 Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"🆔 Action ID\", value=f\"#{action_id}\", inline=True)\n            embed.add_field(name=\"💬 DM Status\", value=\"<:GsRight:1414593140156792893>  Sent\" if dm_success else \"<:GsWrong:1414561861352816753>   Failed\", inline=True)\n            embed.add_field(name=\"📊 Database\", value=\"<:GsRight:1414593140156792893>  Logged\", inline=True)\n\n            if self.duration and self.action_type in [\"mute\", \"ban\", \"mutewarn\"]:\n                embed.add_field(name=\"⏱️ Duration\", value=self.duration, inline=True)\n\n            embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            try:\n                await interaction.edit_original_response(embed=embed, view=None)\n            except discord.errors.NotFound:\n                # If edit fails, try to send a new message\n                await interaction.followup.send(embed=embed, ephemeral=True)\n\n        except Exception as e:\n            logger.error(f\"Error executing {self.action_type}: {e}\")\n            try:\n                await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Unexpected Error**\\nFailed to execute {self.action_type}: {str(e)}\", ephemeral=True)\n            except:\n                pass\n\n    def check_bot_permissions(self, bot_member, guild):\n        \"\"\"Check if bot has required permissions for the action\"\"\"\n        required_perms = {\n            \"warn\": [\"send_messages\"],\n            \"mute\": [\"moderate_members\"],\n            \"kick\": [\"kick_members\"],\n            \"ban\": [\"ban_members\"],\n            \"mutewarn\": [\"moderate_members\"]\n        }\n\n        permissions_needed = required_perms.get(self.action_type, [])\n        missing_perms = []\n\n        for perm in permissions_needed:\n            if not getattr(bot_member.guild_permissions, perm, False):\n                missing_perms.append(perm.replace('_', ' ').title())\n\n        if missing_perms:\n            perm_list = ', '.join(missing_perms)\n            return {\n                \"success\": False,\n                \"error\": f\"I'm missing these permissions: **{perm_list}**\\n\\n**How to fix:**\\n1. Go to Server Settings → Roles\\n2. Find my role and edit permissions\\n3. Enable the missing permissions above\"\n            }\n\n        return {\"success\": True, \"error\": None}\n\n    @discord.ui.button(label=\"Cancel\", style=discord.ButtonStyle.secondary, emoji=\"<:GsWrong:1414561861352816753>  \")\n    async def cancel_action(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.moderator:\n            try:\n                await interaction.response.send_message(\"Only the moderator can cancel this action.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            await interaction.response.defer()\n\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Action Cancelled\",\n                description=f\"The {self.action_type} action has been cancelled.\",\n                color=0x808080\n            )\n            embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            try:\n                await interaction.edit_original_response(embed=embed, view=None)\n            except discord.errors.NotFound:\n                await interaction.followup.send(embed=embed, ephemeral=True)\n        except Exception as e:\n            logger.error(f\"Error cancelling action: {e}\")\n            try:\n                await interaction.followup.send(\"<:GsWrong:1414561861352816753>   Error occurred while cancelling, but action was not executed.\", ephemeral=True)\n            except:\n                pass\n\n    async def send_dm_notification(self):\n        \"\"\"Send DM notification to the user and return success status\"\"\"\n        try:\n            action_titles = {\n                \"warn\": \"⚠️ You Have Been Warned\",\n                \"mute\": \"🔇 You Have Been Muted\",\n                \"kick\": \"👢 You Have Been Kicked\",\n                \"ban\": \"🔨 You Have Been Banned\",\n                \"mutewarn\": \"⚠️🔇 You Have Been Warned + Muted\"\n            }\n\n            action_descriptions = {\n                \"warn\": \"You have been warned in the server\",\n                \"mute\": \"You have been muted from the server\",\n                \"kick\": \"You have been kicked from the server\",\n                \"ban\": \"You have been banned from the server\",\n                \"mutewarn\": \"You have been warned and muted from the server\"\n            }\n\n            embed = discord.Embed(\n                title=action_titles[self.action_type],\n                description=action_descriptions[self.action_type],\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"🏠 Server\", value=f\"{self.moderator.guild.name}\", inline=True)\n            embed.add_field(name=\"👤 Moderator\", value=f\"{self.moderator}\", inline=True)\n\n            if self.duration and self.action_type in [\"mute\", \"ban\", \"mutewarn\"]:\n                embed.add_field(name=\"⏱️ Duration\", value=self.duration, inline=True)\n\n            embed.add_field(name=\"📋 Reason\", value=self.reason, inline=False)\n            embed.add_field(\n                name=\"🚨 Appeal Process\",\n                value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\\n🔗 https://discord.gg/ahharETNNR\",\n                inline=False\n            )\n            embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            await self.user.send(embed=embed)\n            return True\n        except Exception as e:\n            logger.error(f\"Error sending DM to {self.user}: {e}\")\n            return False\n\n# Utility functions\ndef parse_duration(duration_str):\n    \"\"\"Parse duration string like '1h', '30m', '2d' into minutes\"\"\"\n    if not duration_str:\n        return 10  # Default 10 minutes\n\n    duration_str = duration_str.lower().strip()\n    if duration_str == \"permanent\":\n        return None\n\n    # Extract number and unit\n    match = re.match(r'(\\d+)([mhd])', duration_str)\n    if not match:\n        return 10  # Default 10 minutes\n\n    number, unit = match.groups()\n    number = int(number)\n\n    # Ensure positive number\n    if number <= 0:\n        return 10\n\n    if unit == 'm':\n        return number\n    elif unit == 'h':\n        return number * 60\n    elif unit == 'd':\n        return number * 24 * 60\n\n    return 10\n\ndef format_duration(minutes):\n    \"\"\"Format minutes into readable duration\"\"\"\n    if not minutes:\n        return \"Permanent\"\n\n    if minutes < 60:\n        return f\"{minutes} minute{'s' if minutes != 1 else ''}\"\n    elif minutes < 1440:  # Less than a day\n        hours = minutes // 60\n        remaining_minutes = minutes % 60\n        if remaining_minutes:\n            return f\"{hours} hour{'s' if hours != 1 else ''} {remaining_minutes} minute{'s' if remaining_minutes != 1 else ''}\"\n        else:\n            return f\"{hours} hour{'s' if hours != 1 else ''}\"\n    else:  # Days\n        days = minutes // 1440\n        remaining_hours = (minutes % 1440) // 60\n        if remaining_hours:\n            return f\"{days} day{'s' if days != 1 else ''} {remaining_hours} hour{'s' if remaining_hours != 1 else ''}\"\n        else:\n            return f\"{days} day{'s' if days != 1 else ''}\"\n\n# Moderation commands\n@bot.command(name=\"warn\", aliases=[\"w\"])\nasync def warn_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Warn a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"You don't have permission to warn users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot warn users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"⚠️ Confirm Warning\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"🔥 Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"warn\", user, ctx.author, reason)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"mute\", aliases=[\"timeout\"])\nasync def mute_user(ctx, user: discord.Member, duration=\"1h\", *, reason=\"No reason provided\"):\n    \"\"\"Mute a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.moderate_members:\n        await ctx.send(\"You don't have permission to mute users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot mute users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"🔇 Confirm Mute\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Duration\", value=duration, inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"🔥 Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"mute\", user, ctx.author, reason, duration)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"ban\", aliases=[\"b\"])\nasync def ban_user(ctx, user: discord.Member, duration=\"permanent\", *, reason=\"No reason provided\"):\n    \"\"\"Ban a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.ban_members:\n        await ctx.send(\"You don't have permission to ban users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot ban users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"🔨 Confirm Ban\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Duration\", value=duration, inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"🔥 Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"ban\", user, ctx.author, reason, duration)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"kick\", aliases=[\"k\"])\nasync def kick_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Kick a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"You don't have permission to kick users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot kick users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"👢 Confirm Kick\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"🔥 Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"kick\", user, ctx.author, reason)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"mutewarn\", aliases=[\"mw\"])\nasync def mutewarn_user(ctx, user: discord.Member, duration=\"1h\", *, reason=\"No reason provided\"):\n    \"\"\"Warn and mute a user simultaneously with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.moderate_members:\n        await ctx.send(\"You don't have permission to mute and warn users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot warn/mute users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"⚠️🔇 Confirm Warn + Mute\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Duration\", value=duration, inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.add_field(name=\"Actions\", value=\"Will apply **both** warning and mute\", inline=False)\n    embed.set_footer(text=\"🔥 Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"mutewarn\", user, ctx.author, reason, duration)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"unmute\", aliases=[\"um\"])\nasync def unmute_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Unmute a user\"\"\"\n    if not ctx.author.guild_permissions.moderate_members:\n        await ctx.send(\"You don't have permission to unmute users.\")\n        return\n\n    try:\n        if not user.is_timed_out():\n            await ctx.send(f\"{user.mention} is not currently muted.\")\n            return\n\n        # Remove timeout\n        await user.timeout(None, reason=f\"Unmuted by {ctx.author}: {reason}\")\n\n        # Create success embed\n        embed = discord.Embed(\n            title=\"🔊 User Unmuted\",\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n        embed.add_field(name=\"🏠 Server\", value=f\"{ctx.guild.name}\", inline=True)\n        embed.add_field(name=\"👤 Moderator\", value=f\"{ctx.author} (on study arc)\", inline=True)\n        embed.add_field(name=\"📋 Reason\", value=reason, inline=False)\n        embed.add_field(\n            name=\"🚨 Appeal Process\",\n            value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\",\n            inline=False\n        )\n        embed.set_footer(text=\"🔥 Game Services Moderation System • Today at \" + discord.utils.utcnow().strftime(\"%I:%M %p\"))\n\n        await ctx.send(embed=embed)\n\n        # DM the user\n        try:\n            dm_embed = discord.Embed(\n                title=\"🔊 You Have Been Unmuted\",\n                description=\"You have been unmuted from the server\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            dm_embed.add_field(name=\"🏠 Server\", value=f\"{ctx.guild.name}\", inline=True)\n            dm_embed.add_field(name=\"👤 Moderator\", value=f\"{ctx.author} (on study arc)\", inline=True)\n            dm_embed.add_field(name=\"📋 Reason\", value=reason, inline=False)\n            dm_embed.add_field(\n                name=\"🚨 Appeal Process\",\n                value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\\n🔗 https://discord.gg/ahharETNNR\",\n                inline=False\n            )\n            dm_embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n            await user.send(embed=dm_embed)\n        except discord.Forbidden:\n            logger.info(f\"Could not DM {user} - DMs disabled\")\n\n    except Exception as e:\n        logger.error(f\"Error unmuting user: {e}\")\n        await ctx.send(f\"Error unmuting {user.mention}: {str(e)}\")\n\n@bot.command(name=\"removewarn\", aliases=[\"unwarn\", \"rw\"])\nasync def remove_warn(ctx, action_id_str: str, *, removal_reason=\"No reason provided\"):\n    \"\"\"Remove a moderation action\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"You don't have permission to remove moderation actions.\")\n        return\n\n    # Try to convert action_id_str to integer\n    try:\n        action_id = int(action_id_str)\n    except ValueError:\n        embed = discord.Embed(\n            title=\"<:GsWrong:1414561861352816753>   Invalid Action ID\",\n            description=\"Please provide a valid action ID number.\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"💡 Usage\", value=\"`gs.removewarn <action_id> [reason]`\", inline=False)\n        embed.add_field(name=\"📋 Example\", value=\"`gs.removewarn 123 mistake by staff`\", inline=False)\n        embed.add_field(name=\"🔍 How to find Action ID\", value=\"Use `gs.warns @user` to see action IDs\", inline=False)\n        embed.set_footer(text=\"🔥 Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    # Remove from database\n    removed_action = mod_db.remove_moderation_action(action_id, ctx.author.id, removal_reason)\n\n    if not removed_action:\n        await ctx.send(\"No active moderation action found with that ID.\")\n        return\n\n    embed = discord.Embed(\n        title=\"<:GsRight:1414593140156792893>  Moderation Action Removed Successfully\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"🆔 Action ID\", value=f\"#{action_id}\", inline=True)\n    embed.add_field(name=\"🏷️ Original Action\", value=removed_action['action_type'].title(), inline=True)\n    embed.add_field(name=\"👤 Target User\", value=f\"<@{removed_action['user_id']}>\", inline=True)\n    embed.add_field(name=\"👮 Original Moderator\", value=f\"<@{removed_action['moderator_id']}>\", inline=True)\n    embed.add_field(name=\"🗑️ Removed By\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"📊 Database\", value=\"<:GsRight:1414593140156792893>  Updated\", inline=True)\n    embed.add_field(name=\"📝 Removal Reason\", value=removal_reason, inline=False)\n    embed.add_field(name=\"📋 Original Reason\", value=removed_action['reason'], inline=False)\n    embed.set_footer(text=\"🔥 Game Services Moderation System\")\n\n    await ctx.send(embed=embed)\n\n    # If it was a mute, remove the timeout\n    if removed_action['action_type'] == 'mute':\n        try:\n            user = ctx.guild.get_member(removed_action['user_id'])\n            if user and user.is_timed_out():\n                await user.timeout(None, reason=f\"Mute removed by {ctx.author}\")\n        except Exception as e:\n            logger.error(f\"Error removing timeout: {e}\")\n\n@bot.command(name=\"warns\", aliases=[\"warnlist\"])\nasync def user_warns(ctx, user: discord.Member = None):\n    \"\"\"Show warning history for a user in this server\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    warn_records = [r for r in records if r['action_type'] == 'warn' and r['is_active']]\n\n    if not warn_records:\n        embed = discord.Embed(\n            title=\"📋 No Warning History\",\n            description=f\"{user.mention} has no warning history in **{ctx.guild.name}**.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"⚠️ Warning History for {user.display_name}\",\n        description=f\"Server: **{ctx.guild.name}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_warns = []\n    active_warns = [r for r in warn_records if r['is_active']]\n\n    embed.add_field(name=\"📊 Summary\", value=f\"**{len(active_warns)}** active warnings\", inline=True)\n    embed.add_field(name=\"📈 Total\", value=f\"**{len(warn_records)}** total warnings\", inline=True)\n    embed.add_field(name=\"🏠 Server\", value=f\"**{ctx.guild.name}**\", inline=True)\n\n    for record in warn_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_warns.append(\n            f\"**#{record['id']}** Warning - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_warns:\n        embed.add_field(name=\"📝 Recent Warnings\",\n                       value=\"\\n\".join(recent_warns),\n                       inline=False)\n\n    embed.set_footer(text=\"🔥 Game Services Moderation System • Server-Specific Data\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"mutes\", aliases=[\"mutelist\"])\nasync def user_mutes(ctx, user: discord.Member = None):\n    \"\"\"Show mute history for a user\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    mute_records = [r for r in records if r['action_type'] == 'mute']\n\n    if not mute_records:\n        embed = discord.Embed(\n            title=\"📋 No Mute History\",\n            description=f\"{user.mention} has no mute history.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"🔇 Mute History for {user.display_name}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_mutes = []\n    for record in mute_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_mutes.append(\n            f\"**#{record['id']}** Mute - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_mutes:\n        embed.add_field(name=\"📝 Recent Mutes\",\n                       value=\"\\n\".join(recent_mutes),\n                       inline=False)\n\n    embed.set_footer(text=\"🔥 Game Services Moderation System\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"bans\", aliases=[\"ba\"])\nasync def user_bans(ctx, user: discord.Member = None):\n    \"\"\"Show ban history for a user\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    ban_records = [r for r in records if r['action_type'] == 'ban']\n\n    if not ban_records:\n        embed = discord.Embed(\n            title=\"📋 No Ban History\",\n            description=f\"{user.mention} has no ban history.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"🔥 Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"🔨 Ban History for {user.display_name}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_bans = []\n    for record in ban_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_bans.append(\n            f\"**#{record['id']}** Ban - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_bans:\n        embed.add_field(name=\"📝 Recent Bans\",\n                       value=\"\\n\".join(recent_bans),\n                       inline=False)\n\n    embed.set_footer(text=\"🔥 Moderation System\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"gs.kicks\", aliases=[\"kicks\"])\nasync def user_kicks(ctx, user: discord.Member = None):\n    \"\"\"Show kick history for a user\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    kick_records = [r for r in records if r['action_type'] == 'kick']\n\n    if not kick_records:\n        embed = discord.Embed(\n            title=\"📋 No Kick History\",\n            description=f\"{user.mention} has no kick history.\",\n            color=0x00FF00\n        )\n        embed.set_footer(text=\"🔥 Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"👢 Kick History for {user.display_name}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_kicks = []\n    for record in kick_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n\n        recent_kicks.append(\n            f\"**#{record['id']}** Kick - {created_at}\\n\"\n            f\"By: <@{moderator_id}>\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_kicks:\n        embed.add_field(name=\"📝 Recent Kicks\",\n                       value=\"\\n\".join(recent_kicks),\n                       inline=False)\n\n    embed.set_footer(text=\"🔥 Game Services Moderation System\")\n    await ctx.send(embed=embed)\n\n# Roblox Server Commands\n@bot.command(name=\"gagps\", aliases=[\"gs.gagps\"])\nasync def grow_a_garden_ps(ctx):\n    \"\"\"🌱 Get Grow-A-Garden Private Server link\"\"\"\n    embed = discord.Embed(\n        title=\"🌱 Grow-A-Garden Private Server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"Private Server Link:\",\n        value=\"https://www.roblox.com/share?code=46f8e0e94513bc41a1bf7314925f5420&type=Server\",\n        inline=False\n    )\n    embed.set_footer(text=\"🔥 Game Services\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"sabps\", aliases=[\"gs.sabps\"])\nasync def steal_a_brainrot_ps(ctx):\n    \"\"\"🧠 Get Steal-A-Brainrot Private Server link\"\"\"\n    embed = discord.Embed(\n        title=\"🧠 Steal-A-Brainrot Private Server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"Private Server Link:\",\n        value=\"https://www.roblox.com/share?code=75f26e5ffe139f42807227d149126668&type=Server\",\n        inline=False\n    )\n    embed.set_footer(text=\"🔥 Game Services\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"tutorial\", aliases=[\"gs.tutorial\"])\nasync def invite_tutorial(ctx):\n    \"\"\"📚 Learn how to create your own invite link\"\"\"\n    embed = discord.Embed(\n        title=\"📚 Tutorial\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"How to generate your own invite link:\",\n        value=\"https://youtu.be/UkyljZT6lFg?si=G-C6biADCokHOM70\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"📝 What you'll learn:\",\n        value=\"• How to create non-vanity server invite links\\n• Step-by-step guide\\n• Easy to follow tutorial\",\n        inline=False\n    )\n    embed.set_footer(text=\"🔥 Game Services\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"secretsabps\", aliases=[\"gs.secretsabps\"])\nasync def mal_sabps(ctx):\n    \"\"\"🧠 Get Secret Steal-A-Brainrot Private Server link\"\"\"\n    embed = discord.Embed(\n        title=\"🧠 Secret Steal-A-Brainrot Private Server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"Private Server Link:\",\n        value=\"https://www.roblox.com/share?code=9aa554d3133c214293a36fcf6b027ce3&type=Server\",\n        inline=False\n    )\n    embed.set_footer(text=\"🔥 Game Services\")\n    await ctx.send(embed=embed)\n@bot.command(name=\"serverlinks\", aliases=[\"gs.serverlinks\"])\nasync def server_links(ctx):\n    \"\"\"🔗 Get all server invite links (Admin only)\"\"\"\n    # Check if user has administrator permission\n    if not ctx.author.guild_permissions.administrator:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You need administrator permissions to use this command.\")\n        return\n\n    server_count = len(bot.guilds)\n\n    embed = discord.Embed(\n        title=\"🔗 Server Information & Links\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"📊 Bot Statistics\",\n        value=f\"**{server_count}** servers connected\",\n        inline=False\n    )\n\n    server_info = \"\"\n    for guild in bot.guilds[:10]:  # Limit to first 10 servers\n        member_count = guild.member_count or 0\n        try:\n            # Try to create an invite\n            text_channels = [channel for channel in guild.text_channels if channel.permissions_for(guild.me).create_instant_invite]\n            if text_channels:\n                invite = await text_channels[0].create_invite(max_age=0, max_uses=0)\n                server_info += f\"**{guild.name}** ({member_count} members)\\n{invite.url}\\n\\n\"\n            else:\n                server_info += f\"**{guild.name}** ({member_count} members)\\n*No invite permission*\\n\\n\"\n        except:\n            server_info += f\"**{guild.name}** ({member_count} members)\\n*Cannot create invite*\\n\\n\"\n\n    if server_info:\n        embed.add_field(\n            name=\"🏰 Server Invites\",\n            value=server_info[:1020] + (\"...\" if len(server_info) > 1020 else \"\"),\n            inline=False\n        )\n\n    if server_count > 10:\n        embed.add_field(\n            name=\"ℹ️ Note\",\n            value=f\"Showing first 10 of {server_count} servers\",\n            inline=False\n        )\n\n    embed.set_footer(text=\"🔥 Game Services • Admin Command\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"chatguide\", aliases=[\"gs.chatguide\", \"guide\"])\nasync def send_chat_guide(ctx):\n    \"\"\"📋 Manually send the chat guide message (only works in designated channel)\"\"\"\n    channel_id = ctx.channel.id\n\n    # Only allow in the specific channel\n    if channel_id != CHAT_GUIDE_CHANNEL_ID:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   This command only works in <#1370086532433838102>.\")\n        return\n\n    current_time = discord.utils.utcnow()\n\n    # Check cooldown to prevent spam (1 minute cooldown for manual command)\n    if channel_id in chat_guide_cooldown and \\\n       (current_time - chat_guide_cooldown[channel_id]).total_seconds() < 60:\n        remaining = 60 - (current_time - chat_guide_cooldown[channel_id]).total_seconds()\n        await ctx.send(f\"⏰ Chat guide message is on cooldown. Try again in {int(remaining)} seconds.\")\n        return\n\n    try:\n        await ctx.send(CHAT_GUIDE_MESSAGE)\n        chat_guide_cooldown[channel_id] = current_time\n        logger.info(f\"Manually sent chat guide message in {ctx.channel.name} by {ctx.author}\")\n    except Exception as e:\n        logger.error(f\"Error manually sending chat guide message: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   Failed to send chat guide message.\")\n\n@bot.command(name=\"messagecounter\", aliases=[\"gs.msgcount\", \"msgcount\"])\nasync def message_counter_status(ctx):\n    \"\"\"📊 Check message counter status for this channel (Admin only)\"\"\"\n    if not ctx.author.guild_permissions.manage_messages:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You need manage messages permission to use this command.\")\n        return\n\n    channel_id = ctx.channel.id\n    message_count = channel_message_counts.get(channel_id, 0)\n    remaining = CHAT_GUIDE_INTERVAL - (message_count % CHAT_GUIDE_INTERVAL)\n\n    embed = discord.Embed(\n        title=\"📊 Chat Guide Message Counter\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"💬 Messages in Channel\",\n        value=f\"**{message_count}** total messages\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"⏰ Next Guide Message\",\n        value=f\"In **{remaining}** messages\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"🔄 Interval\",\n        value=f\"Every **{CHAT_GUIDE_INTERVAL}** messages\",\n        inline=False\n    )\n\n    if channel_id in chat_guide_cooldown:\n        last_sent = chat_guide_cooldown[channel_id]\n        time_since = discord.utils.utcnow() - last_sent\n        embed.add_field(\n            name=\"📅 Last Sent\",\n            value=f\"{int(time_since.total_seconds() / 60)} minutes ago\",\n            inline=False\n        )\n\n    embed.set_footer(text=\"🔥 Game Services • Message Counter System\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"gs.history\", aliases=[\"history\"])\nasync def user_full_history(ctx, user: discord.Member = None):\n    \"\"\"Show complete moderation history for a user in this server\"\"\"\n    if not user:\n        user = ctx.author\n\n    # Get user's record for this server only\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n\n    if not records:\n        embed = discord.Embed(\n            title=\"📋 Clean Record\",\n            description=f\"{user.mention} has no moderation history in **{ctx.guild.name}**.\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"🏠 Server\", value=f\"**{ctx.guild.name}**\", inline=True)\n        embed.set_footer(text=\"🔥 Game Services Moderation System • Server-Specific Data\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"📋 Complete Moderation History for {user.display_name}\",\n        description=f\"Server: **{ctx.guild.name}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    # Count actions (active and inactive)\n    warns = len([r for r in records if r['action_type'] == 'warn'])\n    mutes = len([r for r in records if r['action_type'] == 'mute'])\n    bans = len([r for r in records if r['action_type'] == 'ban'])\n    kicks = len([r for r in records if r['action_type'] == 'kick'])\n\n    # Count active actions\n    active_warns = len([r for r in records if r['action_type'] == 'warn' and r['is_active']])\n    active_mutes = len([r for r in records if r['action_type'] == 'mute' and r['is_active']])\n    active_bans = len([r for r in records if r['action_type'] == 'ban' and r['is_active']])\n\n    embed.add_field(name=\"📊 Total Actions\",\n                   value=f\"Warnings: {warns}\\nMutes: {mutes}\\nBans: {bans}\\nKicks: {kicks}\",\n                   inline=True)\n\n    embed.add_field(name=\"⚡ Active Actions\",\n                   value=f\"Warnings: {active_warns}\\nMutes: {active_mutes}\\nBans: {active_bans}\\nKicks: 0\",\n                   inline=True)\n\n    embed.add_field(name=\"🏠 Server\",\n                   value=f\"**{ctx.guild.name}**\\nID: {ctx.guild.id}\",\n                   inline=True)\n\n    # Show recent actions (last 8)\n    recent_actions = []\n    for record in records[:8]:\n        action_type = record['action_type'].title()\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:45] + \"...\" if len(record['reason']) > 45 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_actions.append(\n            f\"**#{record['id']}** {action_type} - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_actions:\n        embed.add_field(name=\"📝 Recent Actions\",\n                       value=\"\\n\".join(recent_actions),\n                       inline=False)\n\n    embed.set_footer(text=\"🔥 Game Services Moderation System • Server-Specific Data\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"gs.report\", aliases=[\"report\"])\nasync def report_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Report a user to moderators\"\"\"\n    # Prevent self-reporting\n    if user == ctx.author:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot report yourself.\")\n        return\n\n    # Prevent reporting bots\n    if user.bot:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot report bots.\")\n        return\n\n    # Get the report channel\n    report_channel = bot.get_channel(REPORT_CHANNEL_ID)\n    if not report_channel:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   Report channel not found. Please contact an administrator.\")\n        return\n\n    # Create report embed\n    report_embed = discord.Embed(\n        title=\"🚨 User Report Alert\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    report_embed.add_field(name=\"🎯 Reported User\", value=f\"{user.mention} ({user})\\nID: {user.id}\", inline=False)\n    report_embed.add_field(name=\"👤 Reporter\", value=f\"{ctx.author.mention} ({ctx.author})\\nID: {ctx.author.id}\", inline=False)\n    report_embed.add_field(name=\"📍 Channel\", value=f\"{ctx.channel.mention} ({ctx.channel.name})\", inline=True)\n    report_embed.add_field(name=\"🏠 Server\", value=f\"{ctx.guild.name}\", inline=True)\n    report_embed.add_field(name=\"📋 Reason\", value=reason, inline=False)\n\n    # Add user info\n    now = discord.utils.utcnow()\n    account_age = (now - user.created_at).days\n    server_join = (now - user.joined_at).days if user.joined_at else \"Unknown\"\n    report_embed.add_field(name=\"📊 User Info\",\n                          value=f\"Account Age: {account_age} days\\nServer Member: {server_join} days\",\n                          inline=True)\n\n    report_embed.set_thumbnail(url=user.display_avatar.url)\n    report_embed.set_footer(text=f\"🔥 Game Services Report System • Report ID: {ctx.message.id}\")\n\n    # Create confirmation embed with warning\n    confirm_embed = discord.Embed(\n        title=\"🚨 Confirm Report Submission\",\n        description=f\"You are about to report {user.mention} to the moderation team.\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    confirm_embed.add_field(name=\"📋 Reason\", value=reason, inline=False)\n    confirm_embed.add_field(name=\"⚠️ **WARNING**\",\n                           value=\"**FALSE REPORTS WILL GET YOU MUTED**\\nOnly submit this report if you have a legitimate concern.\",\n                           inline=False)\n    confirm_embed.add_field(name=\"❓ Are you sure?\",\n                           value=\"Click Submit Report to send this to staff, or Cancel to dismiss.\",\n                           inline=False)\n    confirm_embed.set_footer(text=\"🔥 Game Services Report System\")\n\n    # Create view with confirmation buttons\n    view = ReportConfirmationView(user, ctx.author, reason, report_channel, report_embed)\n    await ctx.send(embed=confirm_embed, view=view)\n\n# Invite tracking commands\n@bot.command(name=\"invites\", aliases=[\"inv\", \"gs.invites\"])\nasync def show_invites(ctx, user: discord.Member = None):\n    \"\"\"Show invite statistics for a user\"\"\"\n    target_user = user or ctx.author\n    user_id = target_user.id\n\n    if user_id not in user_invites:\n        user_invites[user_id] = {'invites': 0, 'fake': 0, 'rejoins': 0, 'bonus': 0}\n\n    data = user_invites[user_id]\n    total = data['invites'] + data['bonus'] - data['fake'] - data['rejoins']\n\n    embed = discord.Embed(\n        title=\"📊 Invite Statistics\",\n        description=f\"Invite data for {target_user.mention}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n\n    embed.add_field(name=\"<:GsRight:1414593140156792893>  Valid Invites\", value=str(data['invites']), inline=True)\n    embed.add_field(name=\"🚫 Fake Invites\", value=str(data['fake']), inline=True)\n    embed.add_field(name=\"🔄 Rejoins\", value=str(data['rejoins']), inline=True)\n    embed.add_field(name=\"🎁 Bonus Invites\", value=str(data['bonus']), inline=True)\n    embed.add_field(name=\"📈 Total Score\", value=str(total), inline=True)\n    embed.add_field(name=\"👤 User\", value=f\"{target_user} ({target_user.id})\", inline=False)\n\n    embed.set_thumbnail(url=target_user.display_avatar.url)\n    embed.set_footer(text=\"🔥 Game Services Invite System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"addinvite\", aliases=[\"addinv\"])\nasync def add_invite(ctx, user: discord.Member, amount: int = 1):\n    \"\"\"Add bonus invites to a user (Moderators only)\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You don't have permission to manage invites.\")\n        return\n\n    if user.id not in user_invites:\n        user_invites[user.id] = {'invites': 0, 'fake': 0, 'rejoins': 0, 'bonus': 0}\n\n    user_invites[user.id]['bonus'] += amount\n\n    embed = discord.Embed(\n        title=\"<:GsRight:1414593140156792893>  Bonus Invites Added\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"👤 User\", value=user.mention, inline=True)\n    embed.add_field(name=\"🎁 Added\", value=f\"+{amount} bonus invites\", inline=True)\n    embed.add_field(name=\"👮 Moderator\", value=ctx.author.mention, inline=True)\n    embed.add_field(name=\"📊 New Bonus Total\", value=str(user_invites[user.id]['bonus']), inline=False)\n    embed.set_footer(text=\"🔥 Game Services Invite System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"removeinvite\", aliases=[\"reminv\"])\nasync def remove_invite(ctx, user: discord.Member, amount: int = 1):\n    \"\"\"Remove bonus invites from a user (Moderators only)\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You don't have permission to manage invites.\")\n        return\n\n    if user.id not in user_invites:\n        user_invites[user.id] = {'invites': 0, 'fake': 0, 'rejoins': 0, 'bonus': 0}\n\n    user_invites[user.id]['bonus'] = max(0, user_invites[user.id]['bonus'] - amount)\n\n    embed = discord.Embed(\n        title=\"➖ Bonus Invites Removed\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"👤 User\", value=user.mention, inline=True)\n    embed.add_field(name=\"🔻 Removed\", value=f\"-{amount} bonus invites\", inline=True)\n    embed.add_field(name=\"👮 Moderator\", value=ctx.author.mention, inline=True)\n    embed.add_field(name=\"📊 New Bonus Total\", value=str(user_invites[user.id]['bonus']), inline=False)\n    embed.set_footer(text=\"🔥 Game Services Invite System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"invtop\", aliases=[\"inviteleaderboard\"])\nasync def invite_leaderboard(ctx):\n    \"\"\"Show top inviters\"\"\"\n    if not user_invites:\n        embed = discord.Embed(\n            title=\"📊 Invite Leaderboard\",\n            description=\"No invite data available yet.\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n        return\n\n    # Calculate total scores and sort\n    leaderboard = []\n    for user_id, data in user_invites.items():\n        total = data['invites'] + data['bonus'] - data['fake'] - data['rejoins']\n        leaderboard.append((user_id, total, data))\n\n    leaderboard.sort(key=lambda x: x[1], reverse=True)\n    leaderboard = leaderboard[:10]  # Top 10\n\n    embed = discord.Embed(\n        title=\"🏆 Invite Leaderboard\",\n        description=\"Top 10 inviters in the server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n\n    for i, (user_id, total, data) in enumerate(leaderboard, 1):\n        user = bot.get_user(user_id)\n        user_name = user.display_name if user else f\"User {user_id}\"\n\n        medal = \"🥇\" if i == 1 else \"🥈\" if i == 2 else \"🥉\" if i == 3 else f\"{i}.\"\n\n        embed.add_field(\n            name=f\"{medal} {user_name}\",\n            value=f\"**{total}** total invites\\n<:GsRight:1414593140156792893>  {data['invites']} • 🚫 {data['fake']} • 🔄 {data['rejoins']} • 🎁 {data['bonus']}\",\n            inline=False\n        )\n\n    embed.set_footer(text=\"🔥 Game Services Invite System\")\n    await ctx.send(embed=embed)\n\n# Message tracking commands\n\n# --- Echo Command (Admins Only) ---\n@bot.command(name=\"echo\")\n@commands.has_permissions(administrator=True)\nasync def echo_command(ctx, *, message: str = None):\n    reference = ctx.message.reference\n    try:\n        await ctx.message.delete()  # delete the command message\n    except discord.Forbidden:\n        pass  # ignore if bot has no perms\n\n    if not message and not reference:\n        error = await ctx.send(\"<:GsWrong:1414561861352816753>   You must provide a message or reply to one.\")\n        await asyncio.sleep(5)\n        await error.delete()\n        return\n\n    # Determine final message to send\n    final_message = message or \"\"\n\n    # Add user info if NOT in excluded server\n    if ctx.guild and ctx.guild.id != 1370086525210984458:\n        final_message = f\"💬 {ctx.author} echoed:\\n{final_message}\"\n\n    if reference:\n        replied_message = await ctx.channel.fetch_message(reference.message_id)\n        await replied_message.reply(final_message)\n    else:\n        await ctx.send(final_message)\n# --- AnonymousEcho (Admins Only) ---\n@bot.command(name=\"anonymousecho\")\n@commands.has_permissions(administrator=True)\nasync def echo_command(ctx, *, message: str = None):\n    reference = ctx.message.reference\n    try:\n        await ctx.message.delete()  # delete the command message\n    except discord.Forbidden:\n        pass  # ignore if bot has no perms\n\n    if not message and not reference:\n        error = await ctx.send(\"<:GsWrong:1414561861352816753>   You must provide a message or reply to one.\")\n        await asyncio.sleep(5)\n        await error.delete()\n        return\n\n    # Determine final message to send\n    final_message = message or \"\"\n\n    # Add user info if NOT in excluded server\n    if ctx.guild and ctx.guild.id != 1370086525210984458:\n        final_message = f\"💬 Someone Anonymously Echoed:\\n{final_message}\"\n\n    if reference:\n        replied_message = await ctx.channel.fetch_message(reference.message_id)\n        await replied_message.reply(final_message)\n    else:\n        await ctx.send(final_message)\n# --- Fixed Message Command ---\n@bot.command(name=\"arix\")\nasync def arix_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"wowowowow me arix <:CatSmirk:1411643056230498415>\"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n# --- Fixed Message Command ---\n@bot.command(name=\"mal\")\nasync def mal_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"<a:MonkeySpin:1410866007953637428> \"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n# --- Fixed Message Command ---\n@bot.command(name=\"sia\")\nasync def sia_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"hewooo <a:Excited:1390404098616197251>  \"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n# --- Fixed Message Command ---\n@bot.command(name=\"scyther\")\nasync def scyther_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"Hi Guys I Am Scytherino Yaperino <a:MonkeySpin:1410866007953637428>\"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n# --- Auto Ticket Greeting ---\n@bot.event\nasync def on_guild_channel_create(channel):\n    # Only act on text channels\n    if isinstance(channel, discord.TextChannel):\n        if channel.name.lower().startswith(\"ticket\"):\n            try:\n                await channel.send(\"**Hello, please be patient until staff respond to your ticket, meanwhile state why you made it.**\")\n            except Exception as e:\n                print(f\"Error sending ticket greeting: {e}\")\n\n# --- Fake Ban Command (gs.bam) ---\n@bot.command(name=\"bam\", aliases=[\"gs.bam\"])\nasync def bam_command(ctx, member: discord.Member = None):\n    if not member:\n        error = await ctx.send(\"ℹ️ Usage: `gs.bam @user`\")\n        await error.delete(delay=5)\n        return\n\n    embed = discord.Embed(\n        title=\"⚒️ Ban Hammer\",\n        description=f\"Banned **{member.display_name}**\",\n        color=0xFFC916\n    )\n    embed.set_footer(text=\"🎮 Game Services\")\n\n    await ctx.send(embed=embed)\n# --- Clear Command (mods/admins with Manage Messages) ---\n@bot.command(name=\"clear\", aliases=[\"gs.clear\"])\n@commands.has_permissions(manage_messages=True)\nasync def clear(ctx, amount: int = None):\n    # Validate input\n    if amount is None or amount < 1:\n        error = await ctx.send(\"⚠️ Usage: `gs.clear <number>` — number must be 1 or higher.\")\n        await error.delete(delay=5)\n        return\n\n    # We'll try to bulk delete `amount` messages *plus* the command message (if still present)\n    limit = amount + 1\n\n    try:\n        # Prevent removing pinned messages\n        deleted = await ctx.channel.purge(limit=limit, check=lambda m: not m.pinned)\n        # Count deleted messages excluding the command message (if it was included)\n        deleted_count = sum(1 for m in deleted if m.id != ctx.message.id)\n        confirm = await ctx.send(f\"<:GsRight:1414593140156792893>  Deleted {deleted_count} messages.\")\n        await confirm.delete(delay=5)\n\n    except discord.Forbidden:\n        # Bot lacks Manage Messages / Read Message History permissions\n        error = await ctx.send(\"<:GsWrong:1414561861352816753>   I don't have permission to delete messages in this channel.\")\n        await error.delete(delay=5)\n\n    except discord.HTTPException as e:\n        # Bulk delete failed (e.g., messages older than 14 days cannot be bulk-deleted)\n        logger.exception(\"Bulk delete failed\", exc_info=e)\n        err = await ctx.send(\"<:GsWrong:1414561861352816753>   Failed to delete messages. Note: Discord won't bulk-delete messages older than 14 days.\")\n        await err.delete(delay=8)\n\n    except Exception as e:\n        logger.exception(\"Unexpected error in clear command\", exc_info=e)\n        err = await ctx.send(\"<:GsWrong:1414561861352816753>   An unexpected error occurred while trying to clear messages.\")\n        await err.delete(delay=8)\n\n# --- Fixed Message Command ---\n@bot.command(name=\"aarav\")\nasync def aarav_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"Brri brri dicus bombicus- I mean hello !\"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n\n# ---------------- gs.absence command ----------------\nABSENCE_ROLE_ID = 1374481044916408340\n\n@bot.command(name=\"absence\")\n@commands.has_permissions(administrator=True)\nasync def absence(ctx, member: discord.Member, duration: str):\n    \"\"\"\n    Usage: gs.absence @member 10m\n    Only usable by administrators. Cannot target users with equal/higher role or the server owner.\n    \"\"\"\n    # Protect server owner\n    if member == ctx.guild.owner:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot mark the server owner absent.\")\n        return\n\n    # Prevent targeting equal/higher role\n    if member.top_role >= ctx.author.top_role:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot mark this user absent (they have equal or higher role).\")\n        return\n\n    # Parse duration\n    time_units = {\"s\": 1, \"m\": 60, \"h\": 3600, \"d\": 86400}\n    try:\n        unit = duration[-1].lower()\n        amount = int(duration[:-1])\n        seconds = amount * time_units[unit]\n    except Exception:\n        await ctx.send(\"Invalid time format. Use e.g. `10m`, `2h`, `1d`.\")\n        return\n\n    role = ctx.guild.get_role(ABSENCE_ROLE_ID)\n    if not role:\n        await ctx.send(\"Absence role not found!\")\n        return\n\n    try:\n        await member.add_roles(role)\n    except Exception as e:\n        await ctx.send(f\"Failed to add absence role: {e}\")\n        return\n\n    # Plain text start message\n    await ctx.send(f\"📌 {member.mention} is now marked absent for **{duration}**. The role will be removed automatically.\")\n\n    # Schedule role removal\n    async def remove_role_later():\n        await asyncio.sleep(seconds)\n        try:\n            m = ctx.guild.get_member(member.id)\n            if m and role in m.roles:\n                await m.remove_roles(role)\n                # Plain text end message\n                await ctx.send(f\"<:GsRight:1414593140156792893>  {m.mention}'s absence has ended.\")\n        except Exception:\n            pass\n\n    bot.loop.create_task(remove_role_later())\n\n# ---------------- gs.dm command ----------------\n@bot.command(name=\"dm\")\nasync def dm(ctx, member: discord.Member, *, message: str):\n    \"\"\"\n    Usage: gs.dm @member your message\n    Only the user with ID 721063236371480717 can use this command.\n    \"\"\"\n    # Check if the author is the allowed user mo\n    allowed_ids = {721063236371480717, 1344727532972412938}  # <:GsRight:1414593140156792893>  two allowed users\n\n    if ctx.author.id not in allowed_ids:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You are not allowed to use this command.\")\n        return\n\n    try:\n        await member.send(message)\n        await ctx.send(f\"📩 Successfully sent DM to {member.mention}\")\n    except discord.Forbidden:\n        await ctx.send(f\"⚠️ I cannot DM {member.mention}. Their DMs might be closed.\")\n    except Exception as e:\n        await ctx.send(f\"<:GsWrong:1414561861352816753>   Failed to send DM: {e}\")\n\n# ---------------- Missing commands handlers ----------------\n@bot.command(name=\"sabadminabuse\")\nasync def axo_command(ctx):\n    \"\"\"Handle axo command\"\"\"\n    await ctx.send(\"Next Steal A Brainrot Admin Abuse is at Your time: <t:1757451600:F>\")\n\n@bot.command(name=\"countryquiz\", aliases=[\"cquiz\"])\nasync def country_quiz(ctx):\n    \"\"\"Redirect to the correct countries quiz command\"\"\"\n    await ctx.send(\"🌍 Use `gs.groupcountriesquiz` or `gs.countryguess` to play geography games!\")   \n    \n# ---------------- Mal's Gws ----------------\n@bot.command(name=\"giveawayprompt\")\nasync def giveawayprompt_command(ctx):\n    if not any(role.id == 1403093737323761746 for role in ctx.author.roles):\n        await ctx.reply(\"<:GsWrong:1414561861352816753> You don't have permission to use this command.\", mention_author=True)\n        return\n\n    # build the embed\n    embed = discord.Embed(\n        title=\"🎉 Giveaway Info\",\n        description=(\n            \"**1. Prize Details**\\n\"\n            \"● Prize: \\n\"\n            \"● Amount of Winners: \\n\\n\"\n            \"**2. Duration**\\n\"\n            \"● Giveaway Length: \\n\"\n            \"● Claim Time (*Half of the duration +*)\\n\\n\"\n            \"**3. Requirements**\\n\"\n            \"● Any specific requirements\\n\"\n            \"● Any bypassers\"\n        ),\n        color=0xFFC916\n    )\n    embed.set_footer(text=\"🔥 Giveaways\")\n\n    # <:GsRight:1414593140156792893>  reply to the triggering message with embed\n    await ctx.reply(embed=embed, mention_author=True)\n\nimport discord\nfrom discord.ext import commands\nfrom discord.ui import View, Button\nimport asyncio\nimport io\nimport datetime\nimport json\nimport os\nimport re\n\n# ---------------- CONFIG ----------------\nSTAFF_ROLE_ID = 1394686620300476476   # Staff role\nTICKET_CATEGORY_1 = 1372934736330096780  # Buying tickets category\nTICKET_CATEGORY_2 = 1372934887186890903  # Support tickets category\nLOG_CHANNEL_ID = 1414528231834386545     # Ticket logs channel\nPANEL_ALLOWED_USER = 721063236371480717  # only this user can run gs.ticketpanel\nGOLD = 0xFFC916\nDB_FILE = \"tickets.json\"\n\n# ---------------- Bot setup (safe create-if-missing) ----------------\ntry:\n    bot  # if NameError -> not defined\nexcept NameError:\n    intents = discord.Intents.default()\n    intents.message_content = True\n    intents.members = True\n    bot = commands.Bot(command_prefix=['gs.', 'gs '], intents=intents)\n\n# ---------------- Persistent DB helpers ----------------\nDB_LOCK = asyncio.Lock()\n# structure: {\"tickets\": {\"<channel_id>\": {\"creator_id\": int|None, \"claimer_id\": int|None, \"action_message_id\": int|None, \"created_at\": iso}}, \"panels\": [{\"channel_id\": int, \"message_id\": int}, ...]}\n_tickets_db = {\"tickets\": {}, \"panels\": []}\n\ndef load_db():\n    global _tickets_db\n    if os.path.exists(DB_FILE):\n        try:\n            with open(DB_FILE, \"r\", encoding=\"utf-8\") as f:\n                _tickets_db = json.load(f)\n        except Exception:\n            _tickets_db = {\"tickets\": {}, \"panels\": []}\n    else:\n        _tickets_db = {\"tickets\": {}, \"panels\": []}\n\nasync def save_db():\n    async with DB_LOCK:\n        # make a safe write\n        tmp = DB_FILE + \".tmp\"\n        with open(tmp, \"w\", encoding=\"utf-8\") as f:\n            json.dump(_tickets_db, f, indent=2)\n        os.replace(tmp, DB_FILE)\n\nload_db()\n\n# ---------------- Utility: transcript & staff detection ----------------\nasync def make_transcript(channel: discord.TextChannel) -> discord.File:\n    \"\"\"Return a discord.File object containing the channel transcript.\"\"\"\n    transcript_lines = []\n    async for msg in channel.history(limit=None, oldest_first=True):\n        ts = msg.created_at.astimezone().strftime(\"%Y-%m-%d %H:%M:%S\")\n        # include attachments info (simple)\n        att_text = \"\"\n        if msg.attachments:\n            att_text = \" [attachments: \" + \", \".join(a.url for a in msg.attachments) + \"]\"\n        # guard binary / big content by truncating if necessary\n        content = msg.content or \"\"\n        if len(content) > 3000:\n            content = content[:3000] + \"...[truncated]\"\n        transcript_lines.append(f\"[{ts}] {msg.author} ({getattr(msg.author, 'id', 'unknown')}): {content}{att_text}\")\n    data = \"\\n\".join(transcript_lines) or \"(no messages)\"\n    return discord.File(io.BytesIO(data.encode(\"utf-8\")), filename=f\"{channel.name}-transcript.txt\")\n\nasync def gather_staff_who_spoke(channel: discord.TextChannel, staff_role: discord.Role):\n    \"\"\"Return (set of Member, mention_string). Searches message history and finds staff who posted.\"\"\"\n    staff_members = set()\n    async for msg in channel.history(limit=None):\n        if msg.author.bot:\n            continue\n        # msg.author may be Member or User; use roles attr safely\n        roles = getattr(msg.author, \"roles\", [])\n        if staff_role in roles:\n            staff_members.add(msg.author)\n    mentions = \", \".join(m.mention for m in staff_members) if staff_members else \"No staff replied.\"\n    return staff_members, mentions\n\n# ---------------- Persistent Views ----------------\nclass TicketView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n\n    @discord.ui.button(label=\"Buying Tickets\", emoji=\"<:GsBuying:1415290878964142110>\",\n                       style=discord.ButtonStyle.secondary, custom_id=\"panel_buy\")\n    async def buy_button(self, interaction: discord.Interaction, button: Button):\n        await create_ticket(interaction, TICKET_CATEGORY_1, \"buying\")\n\n    @discord.ui.button(label=\"Support Tickets\", emoji=\"<:GsSupport:1415290793681490000>\",\n                       style=discord.ButtonStyle.secondary, custom_id=\"panel_support\")\n    async def support_button(self, interaction: discord.Interaction, button: Button):\n        await create_ticket(interaction, TICKET_CATEGORY_2, \"support\")\n\nclass TicketActionView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n\n    @discord.ui.button(label=\"Close\", style=discord.ButtonStyle.secondary, custom_id=\"ticket_close\")\n    async def close_btn(self, interaction: discord.Interaction, button: Button):\n        # only staff\n        guild = interaction.guild\n        staff_role = guild.get_role(STAFF_ROLE_ID)\n        if not staff_role or staff_role not in interaction.user.roles:\n            return await interaction.response.send_message(embed=discord.Embed(\n                description=\"<:GsWrong:1414561861352816753> You can’t use this.\", color=0x000000), ephemeral=True)\n        # show confirm\n        await show_confirmation(interaction, action=\"close\")\n\n    @discord.ui.button(label=\"Delete\", style=discord.ButtonStyle.secondary, custom_id=\"ticket_delete\")\n    async def delete_btn(self, interaction: discord.Interaction, button: Button):\n        guild = interaction.guild\n        staff_role = guild.get_role(STAFF_ROLE_ID)\n        if not staff_role or staff_role not in interaction.user.roles:\n            return await interaction.response.send_message(embed=discord.Embed(\n                description=\"<:GsWrong:1414561861352816753> You can’t use this.\", color=0x000000), ephemeral=True)\n        await show_confirmation(interaction, action=\"delete\")\n\n    @discord.ui.button(label=\"Claim\", style=discord.ButtonStyle.secondary, custom_id=\"ticket_claim\")\n    async def claim_btn(self, interaction: discord.Interaction, button: Button):\n        guild = interaction.guild\n        staff_role = guild.get_role(STAFF_ROLE_ID)\n        if not staff_role or staff_role not in interaction.user.roles:\n            return await interaction.response.send_message(embed=discord.Embed(\n                description=\"<:GsWrong:1414561861352816753> You can’t use this.\", color=0x000000), ephemeral=True)\n        await show_confirmation(interaction, action=\"claim\")\n\n# helper to show the gold confirmation prompt (edits the same message)\nasync def show_confirmation(interaction: discord.Interaction, action: str):\n    \"\"\"\n    action: \"close\" | \"delete\" | \"claim\"\n    This edits the message the button was on into a confirmation embed (gold),\n    with Yes/No buttons. On cancel it reverts to original embed + TicketActionView.\n    \"\"\"\n    action_readable = {\"close\": \"Close\",\n                       \"delete\": \"Delete\",\n                       \"claim\": \"Claim\"}.get(action, action)\n\n    confirm_embed = discord.Embed(\n        title=\"Confirm action\",\n        description=f\"Are you sure you want to **{action_readable}**?\",\n        color=GOLD\n    )\n\n    original_message = interaction.message\n    original_embed = original_message.embeds[0] if original_message.embeds else None\n\n    # If embed missing, try to recover from persistent DB (use stored action_message_id for this channel)\n    if not original_embed:\n        meta = _tickets_db.get(\"tickets\", {}).get(str(interaction.channel.id))\n        if meta and meta.get(\"action_message_id\"):\n            try:\n                msg = await interaction.channel.fetch_message(meta[\"action_message_id\"])\n                if msg.embeds:\n                    original_embed = msg.embeds[0]\n            except Exception:\n                original_embed = None\n\n    class ConfirmView(View):\n        def __init__(self, action, original_embed):\n            super().__init__(timeout=30)\n            self.action = action\n            self.original_embed = original_embed\n\n        @discord.ui.button(label=\"Yes\", emoji=\"<:GsRight:1414593140156792893>\",\n                           style=discord.ButtonStyle.secondary, custom_id=\"confirm_yes\")\n        async def yes(self, yes_i: discord.Interaction, button: Button):\n            # double-check staff\n            guild = yes_i.guild\n            staff_role = guild.get_role(STAFF_ROLE_ID)\n            if not staff_role or staff_role not in yes_i.user.roles:\n                return await yes_i.response.send_message(embed=discord.Embed(\n                    description=\"<:GsWrong:1414561861352816753> You can’t use this.\", color=0x000000), ephemeral=True)\n\n            # perform the desired action on the channel where the button was pressed\n            channel = yes_i.channel\n            # fetch fresh channel object\n            channel = guild.get_channel(channel.id)\n            # perform\n            if self.action == \"close\":\n                await do_close_ticket(channel, yes_i.user)\n                # confirm to the interactor and remove view\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=f\"<:GsRight:1414593140156792893> Ticket closed (user removed) by {yes_i.user.mention}.\",\n                    color=0x000000), view=None)\n            elif self.action == \"delete\":\n                await do_delete_ticket(channel, yes_i.user)\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=f\"<:GsRight:1414593140156792893> Ticket deleted by {yes_i.user.mention}.\",\n                    color=0x000000), view=None)\n            elif self.action == \"claim\":\n                await do_claim_ticket(channel, yes_i.user)\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=f\"<:GsRight:1414593140156792893> Ticket claimed by {yes_i.user.mention}.\",\n                    color=0x000000), view=None)\n            else:\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=\"Unknown action.\", color=0x000000), view=None)\n\n        @discord.ui.button(label=\"No\", emoji=\"<:GsWrong:1414561861352816753>\",\n                           style=discord.ButtonStyle.secondary, custom_id=\"confirm_no\")\n        async def no(self, no_i: discord.Interaction, button: Button):\n            # revert the original embed + view\n            await no_i.response.edit_message(embed=self.original_embed or discord.Embed(\n                description=\"Ticket actions\", color=0x000000), view=TicketActionView())\n\n    await interaction.response.edit_message(embed=confirm_embed, view=ConfirmView(action, original_embed))\n\n# ---------------- Core action implementations ----------------\nasync def do_close_ticket(channel: discord.TextChannel, action_by: discord.Member):\n    \"\"\"Remove ticket creator's access (do not delete channel), rename to closed-..., produce transcript & log.\"\"\"\n    guild = channel.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n    log_channel = guild.get_channel(LOG_CHANNEL_ID)\n\n    # try to get creator and claimer from DB first\n    meta = _tickets_db.get(\"tickets\", {}).get(str(channel.id), {})\n    creator_id = meta.get(\"creator_id\")\n    claimer_id = meta.get(\"claimer_id\")\n\n    # fallback to topic parsing if DB empty\n    if not creator_id and channel.topic:\n        parts = channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_id = int(parts[0])\n        if len(parts) > 1 and parts[1].isdigit():\n            claimer_id = int(parts[1])\n\n    ticket_creator = guild.get_member(creator_id) if creator_id else None\n\n    # collect staff who replied before changing perms\n    staff_members, staff_mentions = await gather_staff_who_spoke(channel, staff_role)\n\n    # create transcript\n    transcript = await make_transcript(channel)\n\n    # remove creator permissions (revoke view/send)\n    if ticket_creator:\n        try:\n            await channel.set_permissions(ticket_creator, overwrite=discord.PermissionOverwrite(view_channel=False, send_messages=False))\n        except Exception:\n            pass\n\n    # optionally rename channel to indicate closed\n    try:\n        if not channel.name.startswith(\"closed-\"):\n            await channel.edit(name=f\"closed-{channel.name}\")\n    except Exception:\n        pass\n\n    # log embed + ping creators/staff in content to ensure they are notified (embeds don't always ping)\n    embed = discord.Embed(\n        title=\"<:GsTicketsStyle2:1415298853598396509>  Ticket Closed (user removed)\",\n        color=GOLD,\n        timestamp=datetime.datetime.utcnow()\n    )\n    embed.add_field(name=\"Ticket Creator\", value=(ticket_creator.mention if ticket_creator else \"Unknown\"), inline=False)\n    embed.add_field(name=\"Closed By\", value=action_by.mention, inline=False)\n    embed.add_field(name=\"Staff Involved\", value=(staff_mentions), inline=False)\n    if log_channel:\n        content_ping = \"\"\n        if ticket_creator:\n            content_ping += f\"{ticket_creator.mention} \"\n        if staff_members:\n            content_ping += \" \".join(m.mention for m in staff_members)\n        # send content ping and embed & transcript\n        try:\n            await log_channel.send(content=content_ping or None, embed=embed, file=transcript)\n        except Exception:\n            # fallback without content ping\n            await log_channel.send(embed=embed, file=transcript)\n\n    # mark closed in DB (do not delete entry so we can audit later)\n    meta_key = str(channel.id)\n    if meta_key in _tickets_db.get(\"tickets\", {}):\n        _tickets_db[\"tickets\"][meta_key][\"closed\"] = True\n        _tickets_db[\"tickets\"][meta_key][\"closed_at\"] = datetime.datetime.utcnow().isoformat()\n        await save_db()\n\nasync def do_delete_ticket(channel: discord.TextChannel, action_by: discord.Member):\n    \"\"\"Make transcript, log and delete channel.\"\"\"\n    guild = channel.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n    log_channel = guild.get_channel(LOG_CHANNEL_ID)\n\n    # identify creator from DB first\n    creator_id = None\n    meta = _tickets_db.get(\"tickets\", {}).get(str(channel.id), {})\n    if meta:\n        creator_id = meta.get(\"creator_id\")\n\n    # fallback to topic\n    if not creator_id and channel.topic:\n        parts = channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_id = int(parts[0])\n    ticket_creator = guild.get_member(creator_id) if creator_id else None\n\n    staff_members, staff_mentions = await gather_staff_who_spoke(channel, staff_role)\n    transcript = await make_transcript(channel)\n\n    embed = discord.Embed(\n        title=\"<:GsTicketsStyle2:1415298853598396509>  Ticket Deleted\",\n        description=f\"Deleted by {action_by.mention}\",\n        color=GOLD,\n        timestamp=datetime.datetime.utcnow()\n    )\n    embed.add_field(name=\"User\", value=(ticket_creator.mention if ticket_creator else \"Unknown (topic missing)\"), inline=False)\n    embed.add_field(name=\"Staff Involved\", value=staff_mentions, inline=False)\n    if log_channel:\n        content_ping = \"\"\n        if ticket_creator:\n            content_ping += f\"{ticket_creator.mention} \"\n        if staff_members:\n            content_ping += \" \".join(m.mention for m in staff_members)\n        try:\n            await log_channel.send(content=content_ping or None, embed=embed, file=transcript)\n        except Exception:\n            await log_channel.send(embed=embed, file=transcript)\n\n    # remove from DB (if present)\n    meta_key = str(channel.id)\n    if meta_key in _tickets_db.get(\"tickets\", {}):\n        del _tickets_db[\"tickets\"][meta_key]\n        await save_db()\n\n    # delete after logging\n    await channel.delete()\n\nasync def do_claim_ticket(channel: discord.TextChannel, claimer: discord.Member):\n    \"\"\"Give exclusive send permissions to claimer, others staff can view only.\"\"\"\n    guild = channel.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n\n    # find creator id from DB or topic\n    meta_key = str(channel.id)\n    meta = _tickets_db.get(\"tickets\", {}).get(meta_key, {})\n    creator_id = meta.get(\"creator_id\")\n    current_claimer = meta.get(\"claimer_id\")\n\n    if not creator_id and channel.topic:\n        parts = channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_id = int(parts[0])\n    # set staff role send_messages=False (view True)\n    try:\n        await channel.set_permissions(staff_role, view=True, send_messages=False)\n    except Exception:\n        pass\n    # set claimer perms\n    await channel.set_permissions(claimer, view=True, send_messages=True)\n\n    # update channel.topic to include claimer id (creator;claimer)\n    creator_part = str(creator_id) if creator_id else \"\"\n    try:\n        await channel.edit(topic=f\"{creator_part};{claimer.id}\")\n    except Exception:\n        pass\n\n    # update DB\n    _tickets_db.setdefault(\"tickets\", {}).setdefault(meta_key, {})\n    _tickets_db[\"tickets\"][meta_key][\"creator_id\"] = creator_id\n    _tickets_db[\"tickets\"][meta_key][\"claimer_id\"] = claimer.id\n    await save_db()\n\n    # log claim in log channel\n    log_channel = guild.get_channel(LOG_CHANNEL_ID)\n    embed = discord.Embed(title=\"<:GsTicketsStyle2:1415298853598396509>  Ticket Claimed\",\n                          description=f\"Claimed by {claimer.mention}\",\n                          color=GOLD,\n                          timestamp=datetime.datetime.utcnow())\n    if log_channel:\n        await log_channel.send(embed=embed)\n\n# ---------------- Create a ticket (stores creator id in DB & topic), posts ticket-action message inside ticket ----------------\nasync def create_ticket(interaction: discord.Interaction, category_id: int, ticket_type: str):\n    guild = interaction.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n    category = guild.get_channel(category_id)\n    if not staff_role or not category:\n        return await interaction.response.send_message(embed=discord.Embed(\n            description=\"<:GsWrong:1414561861352816753> Ticket system not set up properly. Contact an admin.\",\n            color=0x000000), ephemeral=True)\n\n    # prepare overwrites\n    overwrites = {\n        guild.default_role: discord.PermissionOverwrite(view_channel=False),\n        staff_role: discord.PermissionOverwrite(view_channel=True, send_messages=True),\n        interaction.user: discord.PermissionOverwrite(view_channel=True, send_messages=True)\n    }\n\n    # create channel and set topic to \"creatorID;\" (claimer blank)\n    # sanitize name (keep your original style but avoid illegal chars)\n    safe_name_user = re.sub(r\"[^0-9a-zA-Z-_]\", \"\", f\"{interaction.user.name}\")[:32]\n    name_safe = f\"{ticket_type}-ticket-{safe_name_user}-{interaction.user.discriminator}\"\n    ticket_channel = await guild.create_text_channel(\n        name=name_safe,\n        overwrites=overwrites,\n        category=category,\n        topic=f\"{interaction.user.id};\"  # creatorID ; claimerID (empty)\n    )\n\n    # send initial embed + ticket action buttons (persistent)\n    embed = discord.Embed(\n        title=f\"{ticket_type.capitalize()} Ticket\",\n        description=f\"{interaction.user.mention} this ticket has been created. Use the buttons below (staff only).\",\n        color=GOLD,\n        timestamp=datetime.datetime.utcnow()\n    )\n    # send and capture message so we can persist its id\n    action_msg = await ticket_channel.send(embed=embed, view=TicketActionView())\n\n    # store ticket metadata to DB (persistent)\n    _tickets_db.setdefault(\"tickets\", {})[str(ticket_channel.id)] = {\n        \"creator_id\": interaction.user.id,\n        \"claimer_id\": None,\n        \"action_message_id\": action_msg.id,\n        \"created_at\": datetime.datetime.utcnow().isoformat()\n    }\n    await save_db()\n\n    # respond to user\n    await interaction.response.send_message(embed=discord.Embed(\n        description=f\"{ticket_type.capitalize()} Ticket created: {ticket_channel.mention} <:GsRight:1414593140156792893>\",\n        color=0x000000\n    ), ephemeral=True)\n\n# ---------------- Panel command (restricted to single user) ----------------\n@bot.command(name=\"ticketpanel\")\nasync def ticketpanel(ctx):\n    if ctx.author.id != PANEL_ALLOWED_USER:\n        return await ctx.send(embed=discord.Embed(\n            description=\"<:GsWrong:1414561861352816753> You are not allowed to use this command.\",\n            color=0x000000\n        ))\n    embed = discord.Embed(\n        title=\"<:GsTicketsStyle2:1415298853598396509>  GS Tickets\",\n        description=(\n            \"Choose the type of ticket you want to open below:\\n\\n\"\n            \"<:GsBuying:1415290878964142110> **Buying Tickets** → For purchases and orders.\\n\\n\"\n            \"<:GsSupport:1415290793681490000> **Support Tickets** → For help and general assistance.\"\n        ),\n        color=0x000000\n    )\n    embed.set_thumbnail(url=\"https://media.discordapp.net/attachments/1378099122497785976/1415323351878078474/image.png?format=webp&quality=lossless\")\n    embed.set_image(url=\"https://media.discordapp.net/attachments/1378099122497785976/1415309148697919581/image.png?format=webp&quality=lossless\")\n    panel_msg = await ctx.send(embed=embed, view=TicketView())\n\n    # persist panel message so we can re-attach view after restarts\n    _tickets_db.setdefault(\"panels\", []).append({\"channel_id\": ctx.channel.id, \"message_id\": panel_msg.id})\n    await save_db()\n\n# ---------------- gs.delete command (same flow as Delete button) ----------------\n@bot.command(name=\"delete\")\nasync def delete_cmd(ctx):\n    staff_role = ctx.guild.get_role(STAFF_ROLE_ID)\n    if not staff_role or staff_role not in ctx.author.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> You don’t have permission.\", color=0x000000))\n\n    if not ctx.channel.name.startswith((\"buying-ticket-\", \"support-ticket-\", \"closed-support\", \"closed-buying\")):\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> This command can only be used in a ticket channel.\", color=0x000000))\n\n    # show confirmation inline (reusing show_confirmation by synthesizing an \"interaction-like\" edit)\n    # easiest: send a new confirmation message for the command:\n    confirm_embed = discord.Embed(title=\"Confirm delete\", description=\"Are you sure you want to delete this ticket?\", color=GOLD)\n    class DeleteConfirm(View):\n        @discord.ui.button(label=\"Yes\", emoji=\"<:GsRight:1414593140156792893>\", style=discord.ButtonStyle.secondary)\n        async def yes(self, interaction: discord.Interaction, button: Button):\n            staff_role_local = ctx.guild.get_role(STAFF_ROLE_ID)\n            if staff_role_local not in interaction.user.roles:\n                return await interaction.response.send_message(\"<:GsWrong:1414561861352816753> You can’t use this.\", ephemeral=True)\n            await do_delete_ticket(ctx.channel, interaction.user)\n            await interaction.response.edit_message(embed=discord.Embed(description=\"Deleted.\", color=0x000000), view=None)\n        @discord.ui.button(label=\"No\", emoji=\"<:GsWrong:1414561861352816753>\", style=discord.ButtonStyle.secondary)\n        async def no(self, interaction: discord.Interaction, button: Button):\n            await interaction.response.edit_message(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> Action denied.\", color=0x000000), view=None)\n\n    await ctx.send(embed=confirm_embed, view=DeleteConfirm())\n\n# ---------------- gs.claim command (with gold confirmation) ----------------\n@bot.command(name=\"claim\")\nasync def claim_cmd(ctx):\n    staff_role = ctx.guild.get_role(STAFF_ROLE_ID)\n    if not staff_role or staff_role not in ctx.author.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> You don’t have permission.\", color=0x000000))\n    if not ctx.channel.name.startswith((\"buying-ticket-\", \"support-ticket-\")):\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> This command can only be used in a ticket channel.\", color=0x000000))\n\n    confirm_embed = discord.Embed(title=\"Claim ticket\", description=f\"{ctx.author.mention}, do you want to claim this ticket?\", color=GOLD)\n    class ClaimConfirm(View):\n        @discord.ui.button(label=\"Yes\", emoji=\"<:GsRight:1414593140156792893>\", style=discord.ButtonStyle.secondary)\n        async def yes(self, interaction: discord.Interaction, button: Button):\n            staff_role_local = ctx.guild.get_role(STAFF_ROLE_ID)\n            if staff_role_local not in interaction.user.roles:\n                return await interaction.response.send_message(\"<:GsWrong:1414561861352816753> You can’t use this.\", ephemeral=True)\n            await do_claim_ticket(ctx.channel, interaction.user)\n            await interaction.response.edit_message(embed=discord.Embed(description=f\"<:GsRight:1414593140156792893> Ticket claimed by {interaction.user.mention}.\", color=0x000000), view=None)\n        @discord.ui.button(label=\"No\", emoji=\"<:GsWrong:1414561861352816753>\", style=discord.ButtonStyle.secondary)\n        async def no(self, interaction: discord.Interaction, button: Button):\n            await interaction.response.edit_message(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> Claim cancelled.\", color=0x000000), view=None)\n\n    await ctx.send(embed=confirm_embed, view=ClaimConfirm())\n\n# ---------------- gs.transfer @member (give claim to another staff) ----------------\n@bot.command(name=\"transfer\")\nasync def transfer_cmd(ctx, member: discord.Member):\n    staff_role = ctx.guild.get_role(STAFF_ROLE_ID)\n    if not staff_role or staff_role not in ctx.author.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> You don’t have permission.\", color=0x000000))\n    if not ctx.channel.name.startswith((\"buying-ticket-\", \"support-ticket-\")):\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> This command can only be used in a ticket channel.\", color=0x000000))\n    # target must be staff\n    if staff_role not in member.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> Target is not staff.\", color=0x000000))\n\n    # set staff role perms to view only, make member send_messages True\n    await ctx.channel.set_permissions(staff_role, view=True, send_messages=False)\n    await ctx.channel.set_permissions(member, view=True, send_messages=True)\n    # update topic claimer part while preserving creator id\n    creator_part = \"\"\n    if ctx.channel.topic:\n        parts = ctx.channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_part = parts[0]\n    await ctx.channel.edit(topic=f\"{creator_part};{member.id}\")\n\n    # update DB\n    meta_key = str(ctx.channel.id)\n    _tickets_db.setdefault(\"tickets\", {}).setdefault(meta_key, {})\n    _tickets_db[\"tickets\"][meta_key][\"claimer_id\"] = member.id\n    await save_db()\n\n    await ctx.send(embed=discord.Embed(description=f\"Ticket transferred to {member.mention}.\", color=GOLD))\n\n# ---------------- Register persistent views on_ready and reattach to messages ----------------\nVIEWS_REGISTERED = False\n\n@bot.event\nasync def on_ready():\n    global VIEWS_REGISTERED\n    if not VIEWS_REGISTERED:\n        try:\n            bot.add_view(TicketView())\n            bot.add_view(TicketActionView())\n            VIEWS_REGISTERED = True\n            print(f\"Registered persistent views as {bot.user}\")\n        except Exception as e:\n            print(\"Failed to register persistent views on startup:\", e)\n\n    # re-attach views to existing messages (action messages + panel messages)\n    # This helps the bot \"remember\" embeds and make buttons work after restart\n    # Migrate any existing ticket channels (that use naming convention) into DB if missing\n    try:\n        # migrate channels that look like tickets and are not yet in DB\n        for channel in bot.get_all_channels():\n            if not isinstance(channel, discord.TextChannel):\n                continue\n            if channel.name.startswith((\"buying-ticket-\", \"support-ticket-\")):\n                key = str(channel.id)\n                if key not in _tickets_db.get(\"tickets\", {}):\n                    # try to infer creator/claimer from topic\n                    creator_id = None\n                    claimer_id = None\n                    if channel.topic:\n                        parts = channel.topic.split(\";\")\n                        if parts and parts[0].isdigit():\n                            creator_id = int(parts[0])\n                        if len(parts) > 1 and parts[1].isdigit():\n                            claimer_id = int(parts[1])\n                    # try to find the bot's action message in recent history\n                    action_msg_id = None\n                    async for msg in channel.history(limit=200):\n                        if msg.author == bot.user and msg.embeds:\n                            action_msg_id = msg.id\n                            break\n                    _tickets_db.setdefault(\"tickets\", {})[key] = {\n                        \"creator_id\": creator_id,\n                        \"claimer_id\": claimer_id,\n                        \"action_message_id\": action_msg_id,\n                        \"created_at\": datetime.datetime.utcnow().isoformat()\n                    }\n                    await save_db()\n\n        # reattach views to action messages\n        for ch_id, meta in list(_tickets_db.get(\"tickets\", {}).items()):\n            try:\n                channel = bot.get_channel(int(ch_id))\n                if not channel:\n                    continue\n                msg_id = meta.get(\"action_message_id\")\n                if not msg_id:\n                    continue\n                try:\n                    msg = await channel.fetch_message(int(msg_id))\n                    # attach the persistent view to this message so interactions work after restart\n                    await msg.edit(view=TicketActionView())\n                except Exception as e:\n                    print(f\"Could not reattach TicketActionView to message {msg_id} in channel {ch_id}:\", e)\n            except Exception:\n                continue\n\n        # reattach views to panel messages\n        for panel in _tickets_db.get(\"panels\", []):\n            try:\n                channel = bot.get_channel(int(panel.get(\"channel_id\")))\n                if not channel:\n                    continue\n                msg = await channel.fetch_message(int(panel.get(\"message_id\")))\n                await msg.edit(view=TicketView())\n            except Exception as e:\n                # don't crash startup on bad panels\n                print(\"Could not reattach TicketView to panel message:\", e)\n    except Exception as e:\n        print(\"Error during on_ready reattach/migrate:\", e)\n\n# ---------------- End of Ticket System block ----------------\n# Keep your customizations (emojis, gold color, thumbnails), this version fixes:\n#  - persistent views properly re-registered on_ready\n#  - action / panel message ids stored on-disk so views can be re-attached after restart\n#  - ticket creator/claimer metadata stored on-disk (tickets.json) and migrated from existing channel topics when possible\n#  - show_confirmation will attempt to recover the original embed from the stored action message if the interaction message lacks it\n\n# Note: run the bot as usual: bot.run(\"YOUR_TOKEN\") in your main runner script.\n\n# ---------------- Bot wrapper class ----------------\nclass DiscordBot:\n    def __init__(self):\n        self.bot = bot\n\n    async def start(self, token):\n        await self.bot.start(token)\n\n    async def close(self):\n        await self.bot.close()\n\n# Load pet data immediately when module is imported\ntry:\n    load_pet_data()\nexcept Exception as e:\n    logger.error(f\"Failed to load pet data at module import: {e}\")","size_bytes":216349},"main.py":{"content":"import asyncio\nimport threading\nimport logging\nimport os\nfrom fixed_bot import DiscordBot\nfrom web_server import create_app\nfrom database import mod_db\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('bot.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\ndef run_discord_bot():\n    \"\"\"Run the Discord bot in a separate thread\"\"\"\n    try:\n        import time\n        time.sleep(3)  # Wait 3 seconds before connecting to avoid rate limits\n        \n        bot = DiscordBot()\n        discord_token = os.getenv('DISCORD_TOKEN')\n        if not discord_token:\n            logger.error(\"DISCORD_TOKEN environment variable not found\")\n            return\n        \n        logger.info(\"Starting Discord bot...\")\n        asyncio.run(bot.bot.start(discord_token))\n    except Exception as e:\n        logger.error(f\"Error running Discord bot: {e}\")\n        # Wait before retrying\n        import time\n        time.sleep(10)\n        logger.info(\"Retrying Discord bot connection...\")\n        try:\n            bot = DiscordBot()\n            asyncio.run(bot.bot.start(discord_token))\n        except Exception as retry_error:\n            logger.error(f\"Retry failed: {retry_error}\")\n\ndef run_flask_server():\n    \"\"\"Run the Flask server for uptime monitoring\"\"\"\n    try:\n        app = create_app()\n        logger.info(\"Starting Flask server on port 5000...\")\n        app.run(host='0.0.0.0', port=5000, debug=False)\n    except Exception as e:\n        logger.error(f\"Error running Flask server: {e}\")\n\nif __name__ == \"__main__\":\n    logger.info(\"Starting Discord bot with Flask uptime endpoint...\")\n    \n    # Initialize database tables\n    try:\n        logger.info(\"Initializing database tables...\")\n        mod_db.init_database()\n        logger.info(\"Database tables initialized successfully!\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize database: {e}\")\n        # Continue anyway - bot can still work without moderation features\n    \n    # Start Discord bot in a separate thread\n    discord_thread = threading.Thread(target=run_discord_bot, daemon=True)\n    discord_thread.start()\n    \n    # Start Flask server in the main thread\n    run_flask_server()\n","size_bytes":2324},"pet_calculator.py":{"content":"from flask import Flask, render_template, request, jsonify\nimport math\n\napp = Flask(__name__)\n\n# Pet weight formula - base weights at each age\nBASE_WEIGHTS = {\n    1: 1.00, 2: 1.09, 3: 1.18, 4: 1.27, 5: 1.36, 6: 1.45, 7: 1.55, 8: 1.64, 9: 1.73, 10: 1.82,\n    11: 1.91, 12: 2.00, 13: 2.09, 14: 2.18, 15: 2.27, 16: 2.36, 17: 2.45, 18: 2.55, 19: 2.64, 20: 2.73,\n    21: 2.82, 22: 2.91, 23: 3.00, 24: 3.09, 25: 3.18, 26: 3.27, 27: 3.36, 28: 3.45, 29: 3.55, 30: 3.64,\n    31: 3.73, 32: 3.82, 33: 3.91, 34: 4.00, 35: 4.09, 36: 4.18, 37: 4.27, 38: 4.36, 39: 4.45, 40: 4.55,\n    41: 4.64, 42: 4.73, 43: 4.82, 44: 4.91, 45: 5.00, 46: 5.09, 47: 5.18, 48: 5.27, 49: 5.36, 50: 5.45,\n    51: 5.55, 52: 5.64, 53: 5.73, 54: 5.82, 55: 5.91, 56: 6.00, 57: 6.09, 58: 6.18, 59: 6.27, 60: 6.36,\n    61: 6.45, 62: 6.55, 63: 6.64, 64: 6.73, 65: 6.82, 66: 6.91, 67: 7.00, 68: 7.09, 69: 7.18, 70: 7.27,\n    71: 7.36, 72: 7.45, 73: 7.55, 74: 7.64, 75: 7.73, 76: 7.82, 77: 7.91, 78: 8.00, 79: 8.09, 80: 8.18,\n    81: 8.27, 82: 8.36, 83: 8.45, 84: 8.55, 85: 8.64, 86: 8.73, 87: 8.82, 88: 8.91, 89: 9.00, 90: 9.09,\n    91: 9.18, 92: 9.27, 93: 9.36, 94: 9.45, 95: 9.55, 96: 9.64, 97: 9.73, 98: 9.82, 99: 9.91, 100: 10.00\n}\n\ndef calculate_weight_multiplier(current_age, current_weight):\n    \"\"\"Calculate the multiplier based on current age and weight\"\"\"\n    if current_age not in BASE_WEIGHTS:\n        return None\n    \n    base_weight_at_current_age = BASE_WEIGHTS[current_age]\n    multiplier = current_weight / base_weight_at_current_age\n    return multiplier\n\ndef predict_weights(current_age, current_weight):\n    \"\"\"Predict weights for all ages based on current data\"\"\"\n    multiplier = calculate_weight_multiplier(current_age, current_weight)\n    if multiplier is None:\n        return None\n    \n    predictions = {}\n    for age in range(1, 101):\n        if age in BASE_WEIGHTS:\n            predicted_weight = BASE_WEIGHTS[age] * multiplier\n            predictions[age] = round(predicted_weight, 2)\n    \n    return predictions\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/calculate', methods=['POST'])\ndef calculate():\n    try:\n        data = request.get_json()\n        current_age = int(data['age'])\n        current_weight = float(data['weight'])\n        \n        if current_age < 1 or current_age > 100:\n            return jsonify({'error': 'Age must be between 1 and 100'}), 400\n        \n        if current_weight <= 0:\n            return jsonify({'error': 'Weight must be greater than 0'}), 400\n        \n        predictions = predict_weights(current_age, current_weight)\n        \n        if predictions is None:\n            return jsonify({'error': 'Invalid age provided'}), 400\n        \n        return jsonify({\n            'current_age': current_age,\n            'current_weight': current_weight,\n            'predictions': predictions\n        })\n    \n    except (ValueError, KeyError) as e:\n        return jsonify({'error': 'Invalid input data'}), 400\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000, debug=False)","size_bytes":3051},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"discord-py>=2.6.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-dateutil>=2.9.0.post0\",\n    \"email-validator>=2.3.0\",\n]\n","size_bytes":341},"replit.md":{"content":"# Overview\n\nThis is a Discord bot with triple functionality: it monitors a specific channel for messages containing \"WFL\" (Want For Less - a trading term) and reacts with custom emojis, tracks pet values from a dedicated values channel, and provides a pet weight calculator command. The bot includes a Flask web server for uptime monitoring and health checks, making it suitable for deployment on platforms that require HTTP endpoints to keep services alive.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# Recent Changes\n\n## August 19, 2025 - Successfully Migrated from Replit Agent to Replit\n- **MIGRATION COMPLETE**: Successfully migrated Discord bot project from Replit Agent environment to standard Replit environment\n- **Dependencies Installed**: All required Python packages installed via uv package manager (discord.py, flask, psycopg2-binary, python-dateutil)\n- **Database Setup**: PostgreSQL database created with proper environment variables (DATABASE_URL, PGPORT, PGUSER, etc.)\n- **Discord Token Configuration**: DISCORD_TOKEN secret properly configured in environment variables\n- **Bot Connection Verified**: Discord bot successfully connected and actively processing messages\n- **Pet Database Active**: Bot scanning Discord channels and updating pet database in real-time (103+ pets tracked)\n- **Flask Server Running**: Web server operational on port 5000 for uptime monitoring\n- **All Features Operational**: WFL reactions, pet value tracking, weight calculator, moderation system all working\n- **Migration Benefits**: Enhanced security with proper client/server separation, better environment management, and Replit compatibility\n\n## August 22, 2025 - Successfully Migrated from Replit Agent to Replit\n- **MIGRATION COMPLETE**: Successfully migrated Discord bot project from Replit Agent environment to standard Replit environment\n- **Dependencies Installed**: All required Python packages installed via uv package manager (discord.py, flask, psycopg2-binary, python-dateutil)\n- **Database Setup**: PostgreSQL database created with proper environment variables (DATABASE_URL, PGPORT, PGUSER, etc.)\n- **Discord Token Configuration**: DISCORD_TOKEN secret properly configured in environment variables\n- **Bot Connection Verified**: Discord bot successfully connected and actively processing messages\n- **Pet Database Active**: Bot scanning Discord channels and updating pet database in real-time (103+ pets tracked)\n- **Flask Server Running**: Web server operational on port 5000 for uptime monitoring\n- **All Features Operational**: WFL reactions, pet value tracking, weight calculator, moderation system all working\n- **Migration Benefits**: Enhanced security with proper client/server separation, better environment management, and Replit compatibility\n\n## August 14, 2025 - Complete Bot Enhancement and Admin Protection Update\n- Successfully migrated project from Replit Agent to standard Replit environment\n- FIXED: Pet similarity matching algorithm causing incorrect search results (t-rex vs turtle issue)\n- Enhanced pet search error messages with helpful examples and suggestions\n- Increased similarity threshold from 20% to 50% for more accurate matching\n- Bot now properly handles non-existent pets with clear, actionable error messages\n- FIXED: Auto-pick feature now works for all scenarios - automatically selects best match even when multiple pets have same percentage\n- FIXED: Removed \"lossless\" prefix from appearing in pet names during value scanning\n- Enhanced auto-selection with 5-point threshold and always picks first match when tied\n- Installed all required dependencies: discord.py, flask, psycopg2-binary, python-dateutil\n- Created PostgreSQL database with moderation system tables\n- Configured Discord bot token in environment variables\n- Updated moderation commands with gs. prefix and improved styling:\n  - gs.warn @user reason - Warn a user with confirmation\n  - gs.mute @user duration reason - Mute user with Discord timeout\n  - gs.ban @user duration reason - Ban user with optional duration\n  - gs.kick @user reason - Kick user from server\n  - gs.unmute @user reason - Remove timeout from user\n  - gs.removewarn action_id reason - Remove/revoke moderation actions\n- Added separate history commands:\n  - gs.warns @user - Show warning history only\n  - gs.mutes @user - Show mute history only \n  - gs.bans @user - Show ban history only\n  - gs.kicks @user - Show kick history only\n  - gs.history @user - Show complete moderation history\n- Enhanced DM notifications with Game Services branding and appeal process\n- Added comprehensive user reporting system:\n  - gs.report @user reason - Members can report users to moderation team\n  - **WARNING: \"FALSE REPORTS WILL GET YOU MUTED\"** prominently displayed\n  - Two-step confirmation process with Submit/Cancel buttons\n  - Reports sent to dedicated channel (1403179951431094404) with detailed user information\n  - Staff can Approve/Deny reports with permission checks\n  - When approved, staff get quick action buttons: Warn, Mute (5m/10m/20m), Kick\n  - All actions logged to database with DM notifications and appeal process\n  - Prevents self-reporting and bot reporting with validation\n  - Beautiful gold-styled embeds with account age and server join information\n- Added comprehensive invite tracking system:\n  - Automatic invite detection with fake invite filtering (accounts < 7 days)\n  - Rejoin detection and tracking\n  - Bonus invite management (addinvite/removeinvite commands)\n  - Invite leaderboard (invtop) with top 10 users\n  - Individual invite stats (invites command) showing valid/fake/rejoins/bonus\n- Added message tracking system:\n  - Daily, weekly, and monthly message counting with automatic resets\n  - Message statistics command (gs.m) showing user activity\n  - Message leaderboards (msgtop daily/weekly/monthly) \n  - Last message timestamp tracking\n- All embeds now use consistent gold color scheme (0xFFC916)\n- Added comprehensive game filtering to prevent false pet detections:\n  - Filters out Wordbomb, Trivia, and other Discord game messages\n  - Enhanced message validation requiring pet-related keywords\n  - Fixed issues with random words being counted as pets\n- Implemented <:GsWrong:1414561861352816753>   reaction system for incorrect pet value searches\n- Added admin protection to automoderation system:\n  - Users with manage_guild or administrator permissions bypass automod\n  - Prevents accidental moderation of server administrators\n- Fixed all image handling issues:\n  - Only assigns images to single-pet messages to avoid confusion\n  - Proper Discord CDN URL formatting with size parameters\n  - Multi-pet messages skip image assignment entirely\n- Bot is now fully operational with all features working:\n  - WFL reactions in target channel\n  - Pet value tracking and database (71 pets loaded with proper filtering)\n  - Pet weight calculator commands\n  - Complete moderation system with admin protection\n  - User reporting system with channel integration\n  - Comprehensive invite tracking with fake detection\n  - Message activity tracking and leaderboards\n  - Auto-pick pet matching with 50% similarity threshold\n  - Game message filtering and validation\n  - Flask server for uptime monitoring on port 5000\n\n# System Architecture\n\n## Bot Architecture\n- **Discord.py Framework**: Uses the discord.py library with commands extension for Discord API interaction\n- **Event-Driven Design**: Implements `on_ready` and `on_message` event handlers to respond to Discord events\n- **Regex Pattern Matching**: Uses compiled regex patterns for case-insensitive \"WFL\" detection in messages\n- **Rate Limiting**: Built-in cooldown system to prevent spam reactions (1-second cooldown between reactions)\n\n## Multi-Threading Design\n- **Dual Service Architecture**: Runs Discord bot and Flask server concurrently using Python threading\n- **Thread Separation**: Discord bot runs in a daemon thread while Flask server runs in the main thread\n- **Error Isolation**: Each service has independent error handling to prevent cascading failures\n\n## Web Server Component\n- **Flask Framework**: Lightweight web server for HTTP endpoints\n- **Health Monitoring**: Multiple endpoints (`/`, `/uptime`, `/status`) for different monitoring needs\n- **Uptime Tracking**: Tracks bot start time and calculates running duration\n- **JSON API**: All endpoints return structured JSON responses for easy integration with monitoring tools\n\n## Configuration Management\n- **Environment Variables**: Uses `DISCORD_TOKEN` environment variable for secure token storage\n- **Channel Configuration**: \n  - WFL reactions channel: 1401169397850308708\n  - Pet values monitoring channel: 1391477739680301187\n- **Logging System**: Comprehensive logging to both file (`bot.log`) and console with timestamp formatting\n- **Data Storage**: Pet values stored in `pet_values.json` file\n\n## Message Processing Pipeline\n1. **Message Filtering**: Ignores bot messages and filters by target channel\n2. **Pattern Detection**: Searches for \"WFL\" pattern using case-insensitive regex\n3. **Rate Limiting**: Checks cooldown before processing reactions\n4. **Reaction Application**: Adds custom server emojis (:W1:, :F1:, :L1:) to matching messages\n\n## Command System\n- **Pet Weight Calculator**: `!petweight` command calculates pet weight predictions\n- **Pet Value Lookup**: `!petvalue` (aliases: `!v`, `!value`, `!val`) command looks up pet values from database\n- **Pet Database Listing**: `!petlist` command shows all pets in the database with pagination\n- **Command Processing**: Uses discord.py commands extension for structured command handling\n- **Input Validation**: Validates age (1-100) and weight (>0) parameters for weight calculations\n- **Flexible Output**: Shows weight progression or specific target age predictions\n- **Weight Formula**: Uses predefined formula with base weights from age 1-100\n\n## Pet Values System\n- **Automatic Scanning**: Scans pet values channel on startup for existing pet data\n- **Real-time Monitoring**: Monitors pet values channel (1391477739680301187) for new pet information\n- **Pattern Matching**: Uses multiple regex patterns to extract pet name, value, and demand from messages\n- **Database Storage**: Stores pet data in JSON file with automatic saving\n- **Search Functionality**: Supports exact and partial matching for pet names\n- **Data Persistence**: Pet values persist between bot restarts\n\n# External Dependencies\n\n## Discord Integration\n- **Discord API**: Primary integration through discord.py library for bot functionality\n- **Discord Gateway**: Real-time message event streaming from Discord servers\n- **Bot Permissions**: Requires message content intent and reaction permissions\n\n## Python Libraries\n- **discord.py**: Core Discord bot framework with commands extension\n- **Flask**: Web framework for HTTP server functionality\n- **threading**: Standard library for concurrent execution\n- **logging**: Built-in logging system for monitoring and debugging\n- **re**: Regular expression library for pattern matching\n- **os**: Environment variable access\n- **datetime**: Timestamp and uptime calculations\n\n## Deployment Requirements\n- **Environment Variables**: `DISCORD_TOKEN` must be configured\n- **Port Access**: Requires access to port 8000 for Flask server\n- **File System**: Needs write access for `bot.log` file creation\n- **Network Access**: Requires outbound HTTPS for Discord API communication","size_bytes":11430},"web_server.py":{"content":"from flask import Flask, jsonify\nimport logging\nimport datetime\nimport os\n\nlogger = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure Flask application\"\"\"\n    app = Flask(__name__)\n    \n    # Store bot start time\n    start_time = datetime.datetime.utcnow()\n    \n    @app.route('/')\n    def health_check():\n        \"\"\"Basic health check endpoint\"\"\"\n        return jsonify({\n            'status': 'healthy',\n            'service': 'Discord WFL Bot',\n            'timestamp': datetime.datetime.utcnow().isoformat(),\n            'uptime_seconds': (datetime.datetime.utcnow() - start_time).total_seconds()\n        })\n    \n    @app.route('/uptime')\n    def uptime():\n        \"\"\"Uptime monitoring endpoint\"\"\"\n        uptime_delta = datetime.datetime.utcnow() - start_time\n        uptime_seconds = uptime_delta.total_seconds()\n        \n        return jsonify({\n            'status': 'online',\n            'uptime_seconds': uptime_seconds,\n            'uptime_human': str(uptime_delta),\n            'start_time': start_time.isoformat(),\n            'current_time': datetime.datetime.utcnow().isoformat()\n        })\n    \n    @app.route('/status')\n    def status():\n        \"\"\"Detailed status endpoint\"\"\"\n        return jsonify({\n            'bot_name': 'Discord WFL Bot',\n            'version': '1.0.0',\n            'status': 'running',\n            'monitoring_channel': '1401169397850308708',\n            'reaction_emojis': [':W1:', ':F1:', ':L1:'],\n            'uptime_seconds': (datetime.datetime.utcnow() - start_time).total_seconds(),\n            'environment': {\n                'python_version': os.sys.version.split()[0],\n                'discord_token_configured': bool(os.getenv('DISCORD_TOKEN'))\n            }\n        })\n    \n    @app.route('/ping')\n    def ping():\n        \"\"\"Simple ping endpoint for monitoring\"\"\"\n        return jsonify({\n            'status': 'pong',\n            'timestamp': datetime.datetime.utcnow().isoformat(),\n            'bot_active': True\n        })\n    \n    @app.errorhandler(404)\n    def not_found(error):\n        \"\"\"Handle 404 errors\"\"\"\n        return jsonify({'error': 'Endpoint not found'}), 404\n    \n    @app.errorhandler(500)\n    def internal_error(error):\n        \"\"\"Handle 500 errors\"\"\"\n        logger.error(f'Internal server error: {error}')\n        return jsonify({'error': 'Internal server error'}), 500\n    \n    # Add request logging\n    @app.before_request\n    def log_request():\n        from flask import request\n        logger.info(f'Incoming request: {request.method} {request.path} from {request.remote_addr}')\n    \n    return app\n","size_bytes":2603}},"version":1}