{"file_contents":{"bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport logging\nimport asyncio\nimport re\n\nlogger = logging.getLogger(__name__)\n\nclass DiscordBot(commands.Bot):\n    def __init__(self):\n        intents = discord.Intents.default()\n        intents.message_content = True\n        super().__init__(command_prefix='gs.', intents=intents)\n        \n        # Target channel ID\n        self.target_channel_id = 1401169397850308708\n        \n        # WFL pattern (case-insensitive)\n        self.wfl_pattern = re.compile(r'\\bwfl\\b', re.IGNORECASE)\n        \n        # Rate limiting\n        self.last_reaction_time = {}\n        self.reaction_cooldown = 1  # 1 second cooldown between reactions\n        \n        # Pet weight formula - base weights at each age\n        self.base_weights = {\n            1: 1.00, 2: 1.09, 3: 1.18, 4: 1.27, 5: 1.36, 6: 1.45, 7: 1.55, 8: 1.64, 9: 1.73, 10: 1.82,\n            11: 1.91, 12: 2.00, 13: 2.09, 14: 2.18, 15: 2.27, 16: 2.36, 17: 2.45, 18: 2.55, 19: 2.64, 20: 2.73,\n            21: 2.82, 22: 2.91, 23: 3.00, 24: 3.09, 25: 3.18, 26: 3.27, 27: 3.36, 28: 3.45, 29: 3.55, 30: 3.64,\n            31: 3.73, 32: 3.82, 33: 3.91, 34: 4.00, 35: 4.09, 36: 4.18, 37: 4.27, 38: 4.36, 39: 4.45, 40: 4.55,\n            41: 4.64, 42: 4.73, 43: 4.82, 44: 4.91, 45: 5.00, 46: 5.09, 47: 5.18, 48: 5.27, 49: 5.36, 50: 5.45,\n            51: 5.55, 52: 5.64, 53: 5.73, 54: 5.82, 55: 5.91, 56: 6.00, 57: 6.09, 58: 6.18, 59: 6.27, 60: 6.36,\n            61: 6.45, 62: 6.55, 63: 6.64, 64: 6.73, 65: 6.82, 66: 6.91, 67: 7.00, 68: 7.09, 69: 7.18, 70: 7.27,\n            71: 7.36, 72: 7.45, 73: 7.55, 74: 7.64, 75: 7.73, 76: 7.82, 77: 7.91, 78: 8.00, 79: 8.09, 80: 8.18,\n            81: 8.27, 82: 8.36, 83: 8.45, 84: 8.55, 85: 8.64, 86: 8.73, 87: 8.82, 88: 8.91, 89: 9.00, 90: 9.09,\n            91: 9.18, 92: 9.27, 93: 9.36, 94: 9.45, 95: 9.55, 96: 9.64, 97: 9.73, 98: 9.82, 99: 9.91, 100: 10.00\n        }\n        \n\n\n    async def on_ready(self):\n        \"\"\"Called when the bot is ready\"\"\"\n        logger.info(f'{self.user} has connected to Discord!')\n        logger.info(f'Bot is in {len(self.guilds)} guilds')\n        \n        # Verify target channel exists\n        target_channel = self.get_channel(self.target_channel_id)\n        if target_channel:\n            logger.info(f'Monitoring channel: {target_channel.name} ({target_channel.id})')\n        else:\n            logger.warning(f'Target channel {self.target_channel_id} not found')\n\n    async def on_message(self, message):\n        \"\"\"Handle incoming messages\"\"\"\n        # Ignore bot messages\n        if message.author.bot:\n            return\n        \n        # Process commands first\n        await self.process_commands(message)\n        \n        # Check if message is in target channel for WFL reactions\n        if message.channel.id != self.target_channel_id:\n            return\n        \n        # Check if message contains \"wfl\" (case-insensitive)\n        if not self.wfl_pattern.search(message.content):\n            return\n        \n        # Rate limiting check\n        current_time = asyncio.get_event_loop().time()\n        if (message.channel.id in self.last_reaction_time and \n            current_time - self.last_reaction_time[message.channel.id] < self.reaction_cooldown):\n            logger.debug(f'Rate limit: Skipping reaction for message {message.id}')\n            return\n        \n        self.last_reaction_time[message.channel.id] = current_time\n        \n        # React with W, F, L emojis\n        await self.add_wfl_reactions(message)\n\n    async def add_wfl_reactions(self, message):\n        \"\"\"Add W, F, L reactions to a message\"\"\"\n        reactions = ['W1', 'F1', 'L1']  # Custom server emojis for W, F, L\n        \n        try:\n            for emoji_name in reactions:\n                # Try to find the custom emoji in the server\n                emoji = discord.utils.get(message.guild.emojis, name=emoji_name)\n                if emoji:\n                    await message.add_reaction(emoji)\n                    logger.info(f'Added reaction :{emoji_name}: to message {message.id} in {message.channel.name}')\n                else:\n                    logger.warning(f'Custom emoji :{emoji_name}: not found in server {message.guild.name}')\n                # Small delay between reactions to avoid rate limits\n                await asyncio.sleep(0.5)\n                \n        except discord.HTTPException as e:\n            if e.status == 429:  # Rate limited\n                logger.warning(f'Rate limited while adding reactions to message {message.id}')\n            else:\n                logger.error(f'HTTP error adding reactions to message {message.id}: {e}')\n        except discord.Forbidden:\n            logger.error(f'Missing permissions to add reactions to message {message.id}')\n        except discord.NotFound:\n            logger.error(f'Message {message.id} not found when trying to add reactions')\n        except Exception as e:\n            logger.error(f'Unexpected error adding reactions to message {message.id}: {e}')\n\n    async def on_error(self, event, *args, **kwargs):\n        \"\"\"Handle errors\"\"\"\n        logger.error(f'Error in event {event}', exc_info=True)\n\n    async def on_command_error(self, ctx, error):\n        \"\"\"Handle command errors\"\"\"\n        logger.error(f'Command error: {error}', exc_info=True)\n\n    def calculate_weight_multiplier(self, current_age, current_weight):\n        \"\"\"Calculate the multiplier based on current age and weight\"\"\"\n        if current_age not in self.base_weights:\n            return None\n        \n        base_weight_at_current_age = self.base_weights[current_age]\n        multiplier = current_weight / base_weight_at_current_age\n        return multiplier\n\n    def predict_weights(self, current_age, current_weight, target_ages=None):\n        \"\"\"Predict weights for specified ages based on current data\"\"\"\n        multiplier = self.calculate_weight_multiplier(current_age, current_weight)\n        if multiplier is None:\n            return None\n        \n        if target_ages is None:\n            target_ages = list(range(1, 101))\n        \n        predictions = {}\n        for age in target_ages:\n            if age in self.base_weights:\n                predicted_weight = self.base_weights[age] * multiplier\n                predictions[age] = round(predicted_weight, 2)\n        \n        return predictions\n\n    @commands.command()\n    async def petweight(self, ctx, current_age: int, current_weight: float, target_age: int = None):\n        \"\"\"Calculate pet weight at different ages\n        Usage: gs.petweight <current_age> <current_weight> [target_age]\n        Example: gs.petweight 5 2.5 10\n        \"\"\"\n        try:\n            # Validate input\n            if current_age < 1 or current_age > 100:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Age must be between 1 and 100\")\n                return\n            \n            if current_weight <= 0:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Weight must be greater than 0\")\n                return\n            \n            # If target_age is specified, calculate for that age only\n            if target_age is not None:\n                if target_age < 1 or target_age > 100:\n                    await ctx.send(\"<:GsWrong:1414561861352816753>   Target age must be between 1 and 100\")\n                    return\n                \n                predictions = self.predict_weights(current_age, current_weight, [target_age])\n                if predictions is None:\n                    await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid age provided\")\n                    return\n                \n                predicted_weight = predictions[target_age]\n                \n                embed = discord.Embed(\n                    title=\" Pet Weight Prediction\",\n                    color=0x4CAF50\n                )\n                embed.add_field(\n                    name=\"Current Info\",\n                    value=f\"Age: {current_age} | Weight: {current_weight} kg\",\n                    inline=False\n                )\n                embed.add_field(\n                    name=f\"Predicted Weight at Age {target_age}\",\n                    value=f\"**{predicted_weight} kg**\",\n                    inline=False\n                )\n                \n                await ctx.send(embed=embed)\n            \n            else:\n                # Show weight progression for key ages\n                predictions = self.predict_weights(current_age, current_weight)\n                if predictions is None:\n                    await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid age provided\")\n                    return\n                \n                # Show current age + next 10 ages\n                key_ages = []\n                for age in range(current_age, min(current_age + 50, 101)):\n                    if age in predictions:\n                        key_ages.append(age)\n                \n                # If we don't have 10 ages ahead, show some before\n                if len(key_ages) < 10:\n                    for age in range(max(1, current_age - 5), current_age):\n                        if age in predictions and age not in key_ages:\n                            key_ages.insert(0, age)\n                \n                key_ages = sorted(key_ages)[:50]  # Limit to 10 ages\n                \n                embed = discord.Embed(\n                    title=\"üêæ Pet Weight Progression\",\n                    color=0x2196F3\n                )\n                embed.add_field(\n                    name=\"Current Info\",\n                    value=f\"Age: {current_age} | Weight: {current_weight} kg\",\n                    inline=False\n                )\n                \n                weight_text = \"\"\n                for age in key_ages:\n                    marker = \" ‚Üê **Current**\" if age == current_age else \"\"\n                    weight_text += f\"Age {age}: {predictions[age]} kg{marker}\\n\"\n                \n                embed.add_field(\n                    name=\"GS Pet Weight Predictions\",\n                    value=weight_text,\n                    inline=False\n                )\n                embed.add_field(\n                    name=\"üí° Tip\",\n                    value=\"Use `gs.petweight <age> <weight> <target_age>` to predict weight at a specific age\",\n                    inline=False\n                )\n                \n                await ctx.send(embed=embed)\n                \n        except ValueError:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Please provide valid numbers for age and weight\")\n        except Exception as e:\n            logger.error(f\"Error in petweight command: {e}\")\n            await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while calculating weights\")\n\n    async def close(self):\n        \"\"\"Clean shutdown\"\"\"\n        logger.info('Shutting down Discord bot...')\n        await super().close()\n","size_bytes":10889},"database.py":{"content":"import os\nimport psycopg2\nfrom psycopg2.extras import RealDictCursor\nfrom datetime import datetime, timedelta\nimport logging\nimport discord\n\nlogger = logging.getLogger(__name__)\n\nclass ModerationDB:\n    def __init__(self):\n        self.db_url = os.getenv('DATABASE_URL')\n        if not self.db_url:\n            raise ValueError(\"DATABASE_URL environment variable not set\")\n        \n    def get_connection(self):\n        \"\"\"Get database connection with retry logic\"\"\"\n        max_retries = 3\n        for attempt in range(max_retries):\n            try:\n                return psycopg2.connect(self.db_url, cursor_factory=RealDictCursor)\n            except Exception as e:\n                logger.error(f\"Database connection attempt {attempt + 1} failed: {e}\")\n                if attempt == max_retries - 1:\n                    raise\n                import time\n                time.sleep(1)\n    \n    def init_database(self):\n        \"\"\"Initialize database tables\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                # Create moderation_actions table\n                cur.execute(\"\"\"\n                    CREATE TABLE IF NOT EXISTS moderation_actions (\n                        id SERIAL PRIMARY KEY,\n                        user_id BIGINT NOT NULL,\n                        moderator_id BIGINT NOT NULL,\n                        server_id BIGINT NOT NULL,\n                        action_type VARCHAR(20) NOT NULL,\n                        reason TEXT NOT NULL,\n                        duration_minutes INTEGER,\n                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                        expires_at TIMESTAMP,\n                        is_active BOOLEAN DEFAULT TRUE,\n                        removed_by BIGINT,\n                        removed_at TIMESTAMP,\n                        removal_reason TEXT\n                    )\n                \"\"\")\n                \n                # Create indexes for better performance\n                cur.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_moderation_user_id \n                    ON moderation_actions(user_id)\n                \"\"\")\n                cur.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_moderation_server_id \n                    ON moderation_actions(server_id)\n                \"\"\")\n                cur.execute(\"\"\"\n                    CREATE INDEX IF NOT EXISTS idx_moderation_active \n                    ON moderation_actions(is_active, expires_at)\n                \"\"\")\n                \n                conn.commit()\n                logger.info(\"Database tables initialized successfully\")\n    \n    def add_moderation_action(self, user_id, moderator_id, server_id, action_type, reason, duration_minutes=None):\n        \"\"\"Add a new moderation action\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                expires_at = None\n                if duration_minutes:\n                    expires_at = datetime.utcnow() + timedelta(minutes=duration_minutes)\n                \n                cur.execute(\"\"\"\n                    INSERT INTO moderation_actions \n                    (user_id, moderator_id, server_id, action_type, reason, duration_minutes, expires_at)\n                    VALUES (%s, %s, %s, %s, %s, %s, %s)\n                    RETURNING id\n                \"\"\", (user_id, moderator_id, server_id, action_type, reason, duration_minutes, expires_at))\n                \n                action_id = cur.fetchone()['id']\n                conn.commit()\n                return action_id\n    \n    def get_user_record(self, user_id, server_id):\n        \"\"\"Get all moderation actions for a user\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    SELECT * FROM moderation_actions \n                    WHERE user_id = %s AND server_id = %s\n                    ORDER BY created_at DESC\n                \"\"\", (user_id, server_id))\n                \n                return cur.fetchall()\n    \n    def get_active_actions(self, user_id, server_id, action_type=None):\n        \"\"\"Get active moderation actions for a user\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                query = \"\"\"\n                    SELECT * FROM moderation_actions \n                    WHERE user_id = %s AND server_id = %s AND is_active = TRUE\n                    AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n                \"\"\"\n                params = [user_id, server_id]\n                \n                if action_type:\n                    query += \" AND action_type = %s\"\n                    params.append(action_type)\n                \n                query += \" ORDER BY created_at DESC\"\n                cur.execute(query, params)\n                \n                return cur.fetchall()\n    \n    def remove_moderation_action(self, action_id, removed_by, removal_reason):\n        \"\"\"Remove/revoke a moderation action\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    UPDATE moderation_actions \n                    SET is_active = FALSE, removed_by = %s, removed_at = CURRENT_TIMESTAMP, \n                        removal_reason = %s\n                    WHERE id = %s AND is_active = TRUE\n                    RETURNING *\n                \"\"\", (removed_by, removal_reason, action_id))\n                \n                result = cur.fetchone()\n                conn.commit()\n                return result\n    \n    def cleanup_expired_actions(self):\n        \"\"\"Clean up expired moderation actions\"\"\"\n        with self.get_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"\"\"\n                    UPDATE moderation_actions \n                    SET is_active = FALSE \n                    WHERE is_active = TRUE \n                    AND expires_at IS NOT NULL \n                    AND expires_at <= CURRENT_TIMESTAMP\n                    RETURNING id, user_id, action_type\n                \"\"\")\n                \n                expired_actions = cur.fetchall()\n                conn.commit()\n                return expired_actions\n\n# Global instance\nmod_db = ModerationDB()","size_bytes":6286},"fixed_bot.py":{"content":"import discord\nfrom discord.ext import commands\nimport logging\nimport asyncio\nimport re\nfrom typing import Optional\nimport json\nimport os\nfrom datetime import datetime, timedelta\nfrom database import mod_db\nimport difflib\nimport random\nimport operator\n\nlogger = logging.getLogger(__name__)\n\n# In-memory pet database  \nPET_DATABASE = {}\nPET_DATA_FILE = os.path.join(os.path.dirname(__file__), \"pet_values.json\")\n\n# Pet data will be loaded after function definitions\n\n# Chat guide message system\nchannel_message_counts = {}  # Track messages per channel for chat guide\nchat_guide_cooldown = {}     # Prevent spam/duplicates per channel\nCHAT_GUIDE_MESSAGE = \"**Make sure to check out the [Chat Guide](https://discord.com/channels/1370086525210984458/1410921626241073173) & you are following the guidelines whilst chatting!**\"\nCHAT_GUIDE_INTERVAL = 100    # Send every 100 messages\nCHAT_GUIDE_CHANNEL_ID = 1370086532433838102  # Only send in this specific channel\n\n# Load existing pet data on startup\ndef load_pet_data():\n    global PET_DATABASE\n    try:\n        logger.info(f\"üîÑ Attempting to load pet data from {PET_DATA_FILE}\")\n        if os.path.exists(PET_DATA_FILE):\n            logger.info(f\"‚úÖ File {PET_DATA_FILE} exists, loading...\")\n            with open(PET_DATA_FILE, 'r') as f:\n                PET_DATABASE = json.load(f)\n            logger.info(f\"üêæ Successfully loaded {len(PET_DATABASE)} pets from database\")\n        else:\n            PET_DATABASE = {}\n            logger.error(f\"‚ùå File {PET_DATA_FILE} not found, starting with empty database\")\n    except Exception as e:\n        logger.error(f\"üí• Error loading pet data: {e}\")\n        logger.error(f\"üìÅ Current working directory: {os.getcwd()}\")\n        logger.error(f\"üìÇ Contents of directory: {os.listdir('.')}\")\n        PET_DATABASE = {}\n\n# Save pet data to file\ndef save_pet_data():\n    try:\n        with open(PET_DATA_FILE, 'w') as f:\n            json.dump(PET_DATABASE, f, indent=2)\n        logger.info(f\"Saved {len(PET_DATABASE)} pets to database\")\n    except Exception as e:\n        logger.error(f\"Error saving pet data: {e}\")\n\n# Enhanced pet name detection patterns - Updated for your exact format\nPET_PATTERNS = [\n    # Primary pattern for the new format: \"(Petname)- (Value)‚îÜ Demand: (demand) ‚îÜImage:https://...\"\n    r'\\(([^)]+)\\)\\s*-\\s*([^‚îÜ\\n]+?)‚îÜ\\s*Demand:\\s*([^‚îÜ\\n]+?)\\s*‚îÜ\\s*Image:\\s*(https?://[^\\s\\n]+)',\n    # Fallback without image\n    r'\\(([^)]+)\\)\\s*-\\s*([^‚îÜ\\n]+?)‚îÜ\\s*Demand:\\s*([^‚îÜ\\n]+)',\n    # Legacy patterns for compatibility\n    r'([A-Za-z\\s]+?)\\s*-\\s*([^‚îÜ\\n]+?)‚îÜ\\s*Demand:\\s*([^‚îÜ\\n]+?)‚îÜ\\s*Image:\\s*(https?://[^\\s\\n]+)',\n    r'([A-Za-z\\s]+?)\\s*-\\s*([^‚îÜ\\n]+?)‚îÜ\\s*Demand:\\s*([^‚îÜ\\n]+)',\n]\n\ndef get_similarity_score(name1, name2):\n    \"\"\"Enhanced similarity scoring with fuzzy matching\"\"\"\n    name1 = name1.lower().strip()\n    name2 = name2.lower().strip()\n\n    # Exact match\n    if name1 == name2:\n        return 100\n\n    # Check if search term is contained in pet name\n    if name1 in name2 or name2 in name1:\n        return 95\n\n    # Check word overlap\n    words1 = set(name1.split())\n    words2 = set(name2.split())\n    common_words = words1.intersection(words2)\n\n    if common_words:\n        overlap_ratio = len(common_words) / max(len(words1), len(words2))\n        if overlap_ratio >= 0.4:\n            return int(overlap_ratio * 85)\n\n    # Fuzzy string matching\n    from difflib import SequenceMatcher\n    ratio = SequenceMatcher(None, name1, name2).ratio()\n    if ratio >= 0.6:\n        return int(ratio * 80)\n\n    # Partial matches\n    if any(word in name2 for word in words1 if len(word) > 2):\n        return 60\n\n    return 0\n\ndef find_best_pet_matches(search_name, max_results=5):\n    \"\"\"Find best matching pets with improved scoring\"\"\"\n    matches = []\n\n    for key, pet_data in PET_DATABASE.items():\n        score = get_similarity_score(search_name, pet_data['name'])\n        if score > 40:  # Lower threshold for better results\n            matches.append((pet_data, score))\n\n    # Sort by similarity score (highest first)\n    matches.sort(key=lambda x: x[1], reverse=True)\n    return matches[:max_results]\n\nasync def process_pet_value_message(message, provided_image_url=None):\n    \"\"\"Enhanced pet value processing with instant updates and proper image extraction\"\"\"\n    content = message.content\n\n    # Skip messages from games like Wordbomb, Trivia, etc.\n    if any(game_word in content.lower() for game_word in [\n        'wordbomb', 'trivia', 'akinator', 'pokemon', 'countryball', 'higher lower',\n        'word chain', 'rhyme time', 'scramble', 'hangman', 'twenty questions',\n        'truth or dare', 'never have i ever', 'would you rather', 'counting',\n        'rock paper scissors', 'tic tac toe', 'connect 4', 'chess', 'checkers'\n    ]):\n        logger.info(f\"Skipping game message: {content[:50]}...\")\n        return\n\n    # Skip messages that are just random words without pet context\n    if not any(keyword in content.lower() for keyword in [\n        'value', 'demand', 'pet', 'üêæ', 'ü™ô', 'high', 'medium', 'low', 'extremely', 'image:', '‚îÜ'\n    ]):\n        return\n\n    # Collect all images from the message\n    image_urls = []\n\n    if message.attachments:\n        for attachment in message.attachments:\n            if attachment.content_type and attachment.content_type.startswith('image/'):\n                image_url = attachment.url\n                image_urls.append(image_url)\n                logger.info(f\"Found attachment image: {attachment.filename}\")\n\n    if message.embeds:\n        for embed in message.embeds:\n            if embed.image and embed.image.url:\n                image_url = embed.image.url\n                image_urls.append(image_url)\n            elif embed.thumbnail and embed.thumbnail.url:\n                image_url = embed.thumbnail.url\n                image_urls.append(image_url)\n\n    if provided_image_url:\n        image_urls.append(provided_image_url)\n\n    # Enhanced pattern matching with image extraction\n    found_pets = []\n    for pattern in PET_PATTERNS:\n        matches = re.findall(pattern, content, re.IGNORECASE | re.MULTILINE)\n        for match in matches:\n            if len(match) >= 3:\n                pet_name = match[0].strip()\n                value = match[1].strip()\n                demand = match[2].strip()\n\n                # Check if this pattern includes image URL (4th group)\n                extracted_image_url = None\n                if len(match) >= 4 and match[3]:\n                    extracted_image_url = match[3].strip()\n                    # Remove 'lossless' parameter if present\n                    if 'quality=lossless' in extracted_image_url:\n                        extracted_image_url = extracted_image_url.replace('&quality=lossless', '').replace('quality=lossless&', '').replace('quality=lossless', '')\n                    logger.info(f\"Extracted image URL from text: {extracted_image_url[:50]}...\")\n\n                # Clean pet name - remove \"lossless\" prefix if present\n                original_name = pet_name\n                pet_name = re.sub(r'^(lossless\\s*)', '', pet_name, flags=re.IGNORECASE).strip()\n                pet_name = re.sub(r'[^\\w\\s]', '', pet_name).strip()\n\n                # Skip if cleaning removed everything or left only short/invalid names\n                if (not pet_name or\n                    pet_name.lower() in ['lossless', 'losless', 'loss', 'less'] or\n                    len(pet_name) < 2):\n                    logger.info(f\"Skipping invalid pet name after cleaning: '{original_name}' -> '{pet_name}'\")\n                    continue\n\n                if len(pet_name) >= 2:\n                    found_pets.append((pet_name, value, demand, extracted_image_url))\n\n    # Store pets with images - FIXED assignment logic\n    for i, pet_data in enumerate(found_pets):\n        pet_name, value, demand = pet_data[:3]\n        extracted_image_url = pet_data[3] if len(pet_data) > 3 else None\n\n        assigned_image = None\n\n        # Priority 1: Image URL extracted from the message text (most accurate)\n        if extracted_image_url:\n            assigned_image = extracted_image_url\n            logger.info(f\"Using extracted image URL for {pet_name}: {assigned_image[:50]}...\")\n        # Priority 2: Only assign attachment images if there's exactly ONE pet and ONE image\n        elif len(found_pets) == 1 and len(image_urls) == 1:\n            assigned_image = image_urls[0]\n            logger.info(f\"Assigning single attachment image to {pet_name}: {assigned_image[:50]}...\")\n        else:\n            logger.info(f\"No suitable image found for {pet_name}\")\n\n        pet_key = pet_name.lower().replace(' ', '_')\n\n        # Store pet data with instant update - preserve existing image if no new one\n        existing_image = PET_DATABASE.get(pet_key, {}).get('image_url')\n        final_image = assigned_image if assigned_image else existing_image\n\n        PET_DATABASE[pet_key] = {\n            'name': pet_name,\n            'value': value,\n            'demand': demand,\n            'last_updated': message.created_at.isoformat(),\n            'message_id': message.id,\n            'image_url': final_image\n        }\n\n        logger.info(f\"Updated pet: {pet_name} - Value: {value} - Demand: {demand} - Image: {'Yes' if assigned_image else 'No'}\")\n\n    # Save data immediately for instant updates\n    if found_pets:\n        save_pet_data()\n        logger.info(f\"INSTANT UPDATE: Processed {len(found_pets)} pets and saved to database\")\n\n# Pet weight formula\nBASE_WEIGHTS = {\n    1: 1.00, 2: 1.09, 3: 1.18, 4: 1.27, 5: 1.36, 6: 1.45, 7: 1.55, 8: 1.64, 9: 1.73, 10: 1.82,\n    11: 1.91, 12: 2.00, 13: 2.09, 14: 2.18, 15: 2.27, 16: 2.36, 17: 2.45, 18: 2.55, 19: 2.64, 20: 2.73,\n    21: 2.82, 22: 2.91, 23: 3.00, 24: 3.09, 25: 3.18, 26: 3.27, 27: 3.36, 28: 3.45, 29: 3.55, 30: 3.64,\n    31: 3.73, 32: 3.82, 33: 3.91, 34: 4.00, 35: 4.09, 36: 4.18, 37: 4.27, 38: 4.36, 39: 4.45, 40: 4.55,\n    41: 4.64, 42: 4.73, 43: 4.82, 44: 4.91, 45: 5.00, 46: 5.09, 47: 5.18, 48: 5.27, 49: 5.36, 50: 5.45,\n    51: 5.55, 52: 5.64, 53: 5.73, 54: 5.82, 55: 5.91, 56: 6.00, 57: 6.09, 58: 6.18, 59: 6.27, 60: 6.36,\n    61: 6.45, 62: 6.55, 63: 6.64, 64: 6.73, 65: 6.82, 66: 6.91, 67: 7.00, 68: 7.09, 69: 7.18, 70: 7.27,\n    71: 7.36, 72: 7.45, 73: 7.55, 74: 7.64, 75: 7.73, 76: 7.82, 77: 7.91, 78: 8.00, 79: 8.09, 80: 8.18,\n    81: 8.27, 82: 8.36, 83: 8.45, 84: 8.55, 85: 8.64, 86: 8.73, 87: 8.82, 88: 8.91, 89: 9.00, 90: 9.09,\n    91: 9.18, 92: 9.27, 93: 9.36, 94: 9.45, 95: 9.55, 96: 9.64, 97: 9.73, 98: 9.82, 99: 9.91, 100: 10.00\n}\n\nintents = discord.Intents.default()\nintents.message_content = True\nbot = commands.Bot(command_prefix=['gs.', 'gs '], intents=intents)\n\n# Channel IDs\nTARGET_CHANNEL_ID = 1401169397850308708\nPET_VALUES_CHANNEL_IDS = [\n    1406716276373590117,  # PRISMATIC CATEGORY\n    1406716328697659583,  # DIVINE CATEGORY\n    1406716530326241451,  # MYTHIC CATEGORY\n    1406716596302385323,  # LEGENDARY CATEGORY\n    1406716645921263787,  # RARE CATEGORY\n    1406716717870223360,  # UNCOMMON CATEGORY\n    1406716764368404520   # COMMON CATEGORY\n]\nREPORT_CHANNEL_ID = 1403179951431094404\nAUTOMOD_REPORT_CHANNEL_ID = 1405317544507609180\n\n# Automod banned words\nBANNED_WORDS = [\n    'negr', 'gay', 'epstiened', 'fatass', 'dildo', 'vagina', '@everyone', 'nudes', 'epstein', 'diddy',\n    'fetish', 'bitch ass', 'bitchass', 'doxx', 'chong', 'nigga', 'anal', 'asshole', 'boob', 'didy',\n    'femboy', 'ùóáùóÇùóÄùóÄùñ∫', 'horny', 'whore', 'diddle', 'slut', 'sybau', 'lgbtq', 'drug', 'penis',\n    'goon', 'dick', 'pussy', 'twerk', 'porn', 'niger', 'fag', 'lgbt', 'slag', 'blackie',\n    'prostitute', 'nigger', 'retard', 'diddled', 'niggas', 'dih', 'feet', 'schlong'\n]\n\n# Country guessing game data\nCOUNTRIES_FLAGS = {\n    \"üá∫üá∏\": \"United States\", \"üá¨üáß\": \"United Kingdom\", \"üá®üá¶\": \"Canada\", \"üá¶üá∫\": \"Australia\", \"üá©üá™\": \"Germany\",\n    \"üá´üá∑\": \"France\", \"üáÆüáπ\": \"Italy\", \"üá™üá∏\": \"Spain\", \"üáØüáµ\": \"Japan\", \"üá∞üá∑\": \"South Korea\", \"üá®üá≥\": \"China\",\n    \"üáßüá∑\": \"Brazil\", \"üá≤üáΩ\": \"Mexico\", \"üá¶üá∑\": \"Argentina\", \"üáÆüá≥\": \"India\", \"üá∑üá∫\": \"Russia\", \"üáøüá¶\": \"South Africa\",\n    \"üá™üá¨\": \"Egypt\", \"üá≥üá¨\": \"Nigeria\", \"üá∞üá™\": \"Kenya\", \"üá∏üá™\": \"Sweden\", \"üá≥üá¥\": \"Norway\", \"üá©üá∞\": \"Denmark\",\n    \"üá´üáÆ\": \"Finland\", \"üá≥üá±\": \"Netherlands\", \"üáßüá™\": \"Belgium\", \"üá®üá≠\": \"Switzerland\", \"üá¶üáπ\": \"Austria\",\n    \"üáµüá±\": \"Poland\", \"üá®üáø\": \"Czech Republic\", \"üá≠üá∫\": \"Hungary\", \"üá¨üá∑\": \"Greece\", \"üáπüá∑\": \"Turkey\",\n    \"üáÆüá™\": \"Ireland\", \"üáµüáπ\": \"Portugal\", \"üáÆüá∏\": \"Iceland\", \"üá±üá∫\": \"Luxembourg\", \"üá≤üáπ\": \"Malta\",\n    \"üá®üáæ\": \"Cyprus\", \"üáßüá¨\": \"Bulgaria\", \"üá∑üá¥\": \"Romania\", \"üá≠üá∑\": \"Croatia\", \"üá∏üáÆ\": \"Slovenia\",\n    \"üá∏üá∞\": \"Slovakia\", \"üá™üá™\": \"Estonia\", \"üá±üáª\": \"Latvia\", \"üá±üáπ\": \"Lithuania\", \"üá∫üá¶\": \"Ukraine\",\n    \"üáßüáæ\": \"Belarus\", \"üá≤üá©\": \"Moldova\", \"üá∑üá∏\": \"Serbia\", \"üáßüá¶\": \"Bosnia and Herzegovina\", \"üá≤üá™\": \"Montenegro\",\n    \"üá≤üá∞\": \"North Macedonia\", \"üá¶üá±\": \"Albania\", \"üáΩüá∞\": \"Kosovo\", \"üáÆüá±\": \"Israel\", \"üáØüá¥\": \"Jordan\",\n    \"üá±üáß\": \"Lebanon\", \"üá∏üáæ\": \"Syria\", \"üáÆüá∂\": \"Iraq\", \"üáÆüá∑\": \"Iran\", \"üá∏üá¶\": \"Saudi Arabia\", \"üá¶üá™\": \"UAE\",\n    \"üá∞üáº\": \"Kuwait\", \"üá∂üá¶\": \"Qatar\", \"üáßüá≠\": \"Bahrain\", \"üá¥üá≤\": \"Oman\", \"üáæüá™\": \"Yemen\", \"üá¶üá´\": \"Afghanistan\",\n    \"üáµüá∞\": \"Pakistan\", \"üáßüá©\": \"Bangladesh\", \"üá±üá∞\": \"Sri Lanka\", \"üá≥üáµ\": \"Nepal\", \"üáßüáπ\": \"Bhutan\",\n    \"üá≤üáª\": \"Maldives\", \"üáπüá≠\": \"Thailand\", \"üáªüá≥\": \"Vietnam\", \"üá∞üá≠\": \"Cambodia\", \"üá±üá¶\": \"Laos\",\n    \"üá≤üáæ\": \"Malaysia\", \"üá∏üá¨\": \"Singapore\", \"üáÆüá©\": \"Indonesia\", \"üáµüá≠\": \"Philippines\", \"üáßüá≥\": \"Brunei\",\n    \"üáπüá±\": \"East Timor\", \"üá≤üá≥\": \"Mongolia\", \"üá∞üáø\": \"Kazakhstan\", \"üá∫üáø\": \"Uzbekistan\", \"üá∞üá¨\": \"Kyrgyzstan\",\n    \"üáπüáØ\": \"Tajikistan\", \"üáπüá≤\": \"Turkmenistan\", \"üá¨üá™\": \"Georgia\", \"üá¶üá≤\": \"Armenia\", \"üá¶üáø\": \"Azerbaijan\",\n    \"üá≤üá¶\": \"Morocco\", \"üáπüá≥\": \"Tunisia\", \"üá©üáø\": \"Algeria\", \"üá±üáæ\": \"Libya\", \"üá∏üá©\": \"Sudan\", \"üá™üá≠\": \"Western Sahara\",\n    \"üá≤üá∑\": \"Mauritania\", \"üá≤üá±\": \"Mali\", \"üáßüá´\": \"Burkina Faso\", \"üá≥üá™\": \"Niger\", \"üáπüá©\": \"Chad\",\n    \"üá∏üá≥\": \"Senegal\", \"üá¨üá≤\": \"Gambia\", \"üá¨üáº\": \"Guinea-Bissau\", \"üá¨üá≥\": \"Guinea\", \"üá∏üá±\": \"Sierra Leone\",\n    \"üá±üá∑\": \"Liberia\", \"üá®üáÆ\": \"Ivory Coast\", \"üá¨üá≠\": \"Ghana\", \"üáπüá¨\": \"Togo\", \"üáßüáØ\": \"Benin\",\n    \"üá®üá≤\": \"Cameroon\", \"üá®üá´\": \"Central African Republic\", \"üáπüá©\": \"Chad\", \"üá∏üá∏\": \"South Sudan\",\n    \"üá™üáπ\": \"Ethiopia\", \"üá™üá∑\": \"Eritrea\", \"üá©üáØ\": \"Djibouti\", \"üá∏üá¥\": \"Somalia\", \"üá∫üá¨\": \"Uganda\",\n    \"üá∑üáº\": \"Rwanda\", \"üáßüáÆ\": \"Burundi\", \"üáπüáø\": \"Tanzania\", \"üá≤üáº\": \"Malawi\", \"üáøüá≤\": \"Zambia\",\n    \"üáøüáº\": \"Zimbabwe\", \"üáßüáº\": \"Botswana\", \"üá≥üá¶\": \"Namibia\", \"üá±üá∏\": \"Lesotho\", \"üá∏üáø\": \"Eswatini\",\n    \"üá≤üá¨\": \"Madagascar\", \"üá≤üá∫\": \"Mauritius\", \"üá∏üá®\": \"Seychelles\", \"üá∞üá≤\": \"Comoros\", \"üá®üáª\": \"Cape Verde\",\n    \"üá∏üáπ\": \"Sao Tome and Principe\", \"üá¨üá∂\": \"Equatorial Guinea\", \"üá¨üá¶\": \"Gabon\", \"üá®üá¨\": \"Republic of the Congo\",\n    \"üá®üá©\": \"Democratic Republic of the Congo\", \"üá¶üá¥\": \"Angola\", \"üáßüá≤\": \"Bermuda\", \"üáµüá∑\": \"Puerto Rico\"\n}\n\n# Tracking systems\ninvite_cache = {}\nuser_invites = {}\nuser_message_counts = {}\ndaily_reset = None\nweekly_reset = None\nmonthly_reset = None\nWFL_PATTERN = re.compile(r'\\bwfl\\b', re.IGNORECASE)\nlast_reaction_time = {}\nreaction_cooldown = 1\n\n# Country game tracking\nactive_games = {}\n\n# Math game tracking\nactive_math_games = {}\n\n# Group game tracking\nactive_group_math_games = {}\nactive_group_country_games = {}\nactive_group_scramble_games = {}\nactive_group_wordbomb_games = {}\n\n# Word bomb game data\nSCRAMBLE_WORDS = [\n    \"algorithm\", \"computer\", \"keyboard\", \"monitor\", \"software\", \"hardware\", \"network\", \"internet\",\n    \"database\", \"programming\", \"javascript\", \"python\", \"discord\", \"gaming\", \"streaming\", \"challenge\",\n    \"adventure\", \"treasure\", \"mystery\", \"fantasy\", \"rainbow\", \"butterfly\", \"elephant\", \"dolphin\",\n    \"mountain\", \"ocean\", \"forest\", \"desert\", \"volcano\", \"galaxy\", \"planet\", \"asteroid\", \"comet\",\n    \"telescope\", \"microscope\", \"laboratory\", \"experiment\", \"discovery\", \"invention\", \"creativity\",\n    \"imagination\", \"inspiration\", \"motivation\", \"determination\", \"achievement\", \"success\", \"victory\",\n    \"friendship\", \"kindness\", \"happiness\", \"celebration\", \"festival\", \"carnival\", \"fireworks\",\n    \"chocolate\", \"strawberry\", \"pineapple\", \"watermelon\", \"hamburger\", \"sandwich\", \"restaurant\",\n    \"university\", \"library\", \"museum\", \"theater\", \"concert\", \"orchestra\", \"symphony\", \"melody\",\n    \"harmony\", \"rhythm\", \"photography\", \"painting\", \"sculpture\", \"architecture\", \"literature\"\n]\n\nWORDBOMB_SEQUENCES = [\n    \"ing\", \"tion\", \"ent\", \"er\", \"ly\", \"ed\", \"al\", \"an\", \"re\", \"th\", \"in\", \"on\", \"at\", \"st\", \"nd\",\n    \"ch\", \"sh\", \"ck\", \"ll\", \"ss\", \"ff\", \"pp\", \"tt\", \"dd\", \"mm\", \"nn\", \"rr\", \"bb\", \"gg\", \"zz\",\n    \"ough\", \"ight\", \"ould\", \"ance\", \"ence\", \"able\", \"ible\", \"ment\", \"ness\", \"less\", \"ful\", \"ous\"\n]\n\ndef reset_message_counts():\n    \"\"\"Reset message counts based on time periods\"\"\"\n    global daily_reset, weekly_reset, monthly_reset\n    now = discord.utils.utcnow()\n\n    if daily_reset is None or now > daily_reset:\n        for user_id in user_message_counts:\n            user_message_counts[user_id]['daily'] = 0\n        daily_reset = now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)\n        logger.info(\"Reset daily message counts\")\n\n    if weekly_reset is None or now > weekly_reset:\n        for user_id in user_message_counts:\n            user_message_counts[user_id]['weekly'] = 0\n        days_ahead = 6 - now.weekday()\n        weekly_reset = (now + timedelta(days=days_ahead)).replace(hour=0, minute=0, second=0, microsecond=0)\n        logger.info(\"Reset weekly message counts\")\n\n    if monthly_reset is None or now > monthly_reset:\n        for user_id in user_message_counts:\n            user_message_counts[user_id]['monthly'] = 0\n        if now.month == 12:\n            monthly_reset = now.replace(year=now.year + 1, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)\n        else:\n            monthly_reset = now.replace(month=now.month + 1, day=1, hour=0, minute=0, second=0, microsecond=0)\n        logger.info(\"Reset monthly message counts\")\n\nasync def cache_invites():\n    \"\"\"Cache all current invites\"\"\"\n    global invite_cache\n    try:\n        if bot.guilds:\n            invites = await bot.guilds[0].invites()\n            invite_cache = {invite.code: {'uses': invite.uses, 'inviter': invite.inviter} for invite in invites}\n            logger.info(f\"Cached {len(invite_cache)} invites\")\n    except Exception as e:\n        logger.error(f\"Error caching invites: {e}\")\n\ndef calculate_weight_multiplier(current_age, current_weight):\n    if current_age not in BASE_WEIGHTS:\n        return None\n    base_weight_at_current_age = BASE_WEIGHTS[current_age]\n    multiplier = current_weight / base_weight_at_current_age\n    return multiplier\n\ndef predict_weights(current_age, current_weight, target_ages=None):\n    multiplier = calculate_weight_multiplier(current_age, current_weight)\n    if multiplier is None:\n        return None\n\n    if target_ages is None:\n        target_ages = list(range(1, 101))\n\n    predictions = {}\n    for age in target_ages:\n        if age in BASE_WEIGHTS:\n            predicted_weight = BASE_WEIGHTS[age] * multiplier\n            predictions[age] = round(predicted_weight, 2)\n\n    return predictions\n\n# Automod Ban View\nclass AutomodBanView(discord.ui.View):\n    def __init__(self, user, message_content, channel):\n        super().__init__(timeout=300)\n        self.user = user\n        self.message_content = message_content\n        self.channel = channel\n\n    @discord.ui.button(label=\"üî® Ban User\", style=discord.ButtonStyle.danger)\n    async def ban_user(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.ban_members:\n            await interaction.response.send_message(\"<:GsWrong:1414561861352816753>   You don't have permission to ban users.\", ephemeral=True)\n            return\n\n        try:\n            await self.user.ban(reason=f\"Automod violation: {self.message_content[:100]}\")\n\n            embed = discord.Embed(\n                title=\"üî® User Banned Successfully\",\n                description=f\"{self.user.mention} has been banned for automod violation.\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üëÆ Moderator\", value=interaction.user.mention, inline=True)\n            embed.add_field(name=\"üìã Reason\", value=f\"Automod violation: {self.message_content[:100]}\", inline=False)\n            embed.set_footer(text=\"üî• Game Services Automod System\")\n\n            await interaction.edit_original_response(embed=embed, view=None)\n\n        except Exception as e:\n            await interaction.response.send_message(f\"<:GsWrong:1414561861352816753>   Error banning user: {str(e)}\", ephemeral=True)\n    @discord.ui.button(label=\"<:GsWrong:1414561861352816753> Dismiss\", style=discord.ButtonStyle.secondary)\n    async def dismiss_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.kick_members:\n            await interaction.response.send_message(\"<:GsWrong:1414561861352816753>   You don't have permission to dismiss reports.\", ephemeral=True)\n            return\n\n        embed = discord.Embed(\n            title=\"<:GsWrong:1414561861352816753>  Automod Report Dismissed\",\n            description=\"The automod report has been dismissed by a moderator.\",\n            color=0x808080,\n            timestamp=discord.utils.utcnow()\n        )\n        embed.add_field(name=\"üëÆ Dismissed By\", value=interaction.user.mention, inline=True)\n        embed.set_footer(text=\"üî• Game Services Automod System\")\n\n        await interaction.edit_original_response(embed=embed, view=None)\n\n@bot.event\nasync def on_ready():\n    logger.info(f'{bot.user} has connected to Discord!')\n    logger.info(f'Bot is in {len(bot.guilds)} guilds')\n    \n    # Debug: List all registered commands\n    logger.info(f\"Total commands registered: {len(list(bot.commands))}\")\n    logger.info(f\"Registered commands: {[cmd.name for cmd in bot.commands]}\")\n    logger.info(f\"Commands with aliases: {[(cmd.name, cmd.aliases) for cmd in bot.commands if cmd.aliases]}\")\n    \n    # Test if petvalue command specifically exists\n    petvalue_cmd = bot.get_command('petvalue')\n    v_cmd = bot.get_command('v')\n    logger.info(f\"petvalue command found: {petvalue_cmd is not None}\")\n    logger.info(f\"v alias found: {v_cmd is not None}\")\n    \n    # Test command loading\n    if len(list(bot.commands)) == 0:\n        logger.error(\"üö® CRITICAL: No commands registered! This is the problem!\")\n    else:\n        logger.info(f\"<:GsRight:1414593140156792893>  Commands successfully registered: {len(list(bot.commands))} total\")\n\n    # Initialize database tables\n    try:\n        mod_db.init_database()\n        logger.info(\"Database tables initialized successfully\")\n    except Exception as e:\n        logger.error(f\"Error initializing database: {e}\")\n\n    load_pet_data()\n    await cache_invites()\n    reset_message_counts()\n\n    target_channel = bot.get_channel(TARGET_CHANNEL_ID)\n    if target_channel:\n        logger.info(f'Monitoring channel: {target_channel.name} ({target_channel.id})')\n\n    logger.info(f'Pet database loaded with {len(PET_DATABASE)} pets (auto-scanning disabled)')\n    \n    # Debug command registration at the end\n    logger.info(\"üîç FINAL COMMAND DEBUG:\")\n    logger.info(f\"Total commands registered: {len(list(bot.commands))}\")\n    logger.info(f\"Registered commands: {[cmd.name for cmd in bot.commands]}\")\n    logger.info(f\"Commands with aliases: {[(cmd.name, cmd.aliases) for cmd in bot.commands if cmd.aliases]}\")\n    \n    # Test specific commands\n    petvalue_cmd = bot.get_command('petvalue')\n    v_cmd = bot.get_command('v')\n    logger.info(f\"petvalue command found: {petvalue_cmd is not None}\")\n    logger.info(f\"v alias found: {v_cmd is not None}\")\n    \n    if len(list(bot.commands)) == 0:\n        logger.error(\"üö® CRITICAL: No commands registered at end of on_ready!\")\n    else:\n        logger.info(f\"<:GsRight:1414593140156792893>  ON_READY COMPLETE: {len(list(bot.commands))} commands active\")\n\n@bot.event\nasync def on_disconnect():\n    logger.warning(\"Bot disconnected from Discord!\")\n\n@bot.event\nasync def on_resumed():\n    logger.info(\"Bot reconnected to Discord!\")\n\n@bot.event\nasync def on_message(message):\n    if message.author.bot:\n        return\n\n    # Track message counts\n    user_id = message.author.id\n    if user_id not in user_message_counts:\n        user_message_counts[user_id] = {'daily': 0, 'weekly': 0, 'monthly': 0, 'last_message': discord.utils.utcnow()}\n\n    reset_message_counts()\n\n    user_message_counts[user_id]['daily'] += 1\n    user_message_counts[user_id]['weekly'] += 1\n    user_message_counts[user_id]['monthly'] += 1\n    user_message_counts[user_id]['last_message'] = discord.utils.utcnow()\n\n    # Chat guide message system - only track messages in the specific channel\n    channel_id = message.channel.id\n    if channel_id == CHAT_GUIDE_CHANNEL_ID:\n        if channel_id not in channel_message_counts:\n            channel_message_counts[channel_id] = 0\n\n        channel_message_counts[channel_id] += 1\n\n        # Check if we should send chat guide message\n        if channel_message_counts[channel_id] % CHAT_GUIDE_INTERVAL == 0:\n            # Check cooldown to prevent spam (5 minute cooldown)\n            current_time = discord.utils.utcnow()\n            if channel_id not in chat_guide_cooldown or \\\n               (current_time - chat_guide_cooldown[channel_id]).total_seconds() > 300:\n                try:\n                    await message.channel.send(CHAT_GUIDE_MESSAGE)\n                    chat_guide_cooldown[channel_id] = current_time\n                    logger.info(f\"Sent chat guide message in {message.channel.name} after {channel_message_counts[channel_id]} messages\")\n                except Exception as e:\n                    logger.error(f\"Error sending chat guide message: {e}\")\n\n    # Automoderation check (skip admins)\n    is_admin = message.author.guild_permissions.manage_guild or message.author.guild_permissions.administrator\n\n    if not is_admin:\n        message_lower = message.content.lower()\n        for banned_word in BANNED_WORDS:\n            if banned_word.lower() in message_lower:\n                try:\n                    # Delete the message with error handling\n                    try:\n                        await message.delete()\n                        message_deleted = True\n                    except discord.NotFound:\n                        logger.info(f\"Message already deleted by {message.author}\")\n                        message_deleted = False\n                    except discord.Forbidden:\n                        logger.warning(f\"No permission to delete message by {message.author}\")\n                        message_deleted = False\n                    except Exception as del_error:\n                        logger.error(f\"Error deleting message: {del_error}\")\n                        message_deleted = False\n\n                    # Warn and mute the user with permission checks\n                    duration_minutes = 10\n                    timeout_duration = timedelta(minutes=duration_minutes)\n\n                    # Check if bot can timeout users\n                    bot_member = message.guild.get_member(bot.user.id)\n                    if not bot_member or not bot_member.guild_permissions.moderate_members:\n                        logger.error(f\"Bot missing moderate_members permission for automod\")\n                        continue\n\n                    # Check role hierarchy\n                    if message.author.top_role >= bot_member.top_role:\n                        logger.warning(f\"Cannot automod {message.author} - role hierarchy\")\n                        continue\n\n                    try:\n                        await message.author.timeout(timeout_duration, reason=f\"Automod: Used banned word '{banned_word}'\")\n                        timeout_success = True\n                    except discord.Forbidden as timeout_error:\n                        logger.error(f\"Permission error timing out {message.author}: {timeout_error}\")\n                        timeout_success = False\n                    except Exception as timeout_error:\n                        logger.error(f\"Error timing out {message.author}: {timeout_error}\")\n                        timeout_success = False\n\n                    # Log in database with error handling\n                    try:\n                        action_id = mod_db.add_moderation_action(\n                            user_id=message.author.id,\n                            moderator_id=bot.user.id,\n                            server_id=message.guild.id,\n                            action_type=\"warn\",\n                            reason=f\"Automod: Used banned word '{banned_word}'\"\n                        )\n\n                        if timeout_success:\n                            mod_db.add_moderation_action(\n                                user_id=message.author.id,\n                                moderator_id=bot.user.id,\n                                server_id=message.guild.id,\n                                action_type=\"mute\",\n                                reason=f\"Automod: Used banned word '{banned_word}'\",\n                                duration_minutes=duration_minutes\n                            )\n                        database_logged = True\n                    except Exception as db_error:\n                        logger.error(f\"Database error in automod: {db_error}\")\n                        database_logged = False\n\n                    # Send to automod report channel\n                    automod_channel = bot.get_channel(AUTOMOD_REPORT_CHANNEL_ID)\n                    if automod_channel:\n                        embed = discord.Embed(\n                            title=\"‚ö†Ô∏è Automod Violation Detected\",\n                            description=f\"User {message.author.mention} has been automatically warned and muted.\",\n                            color=0xFFC916,\n                            timestamp=discord.utils.utcnow()\n                        )\n                        embed.add_field(name=\"üë§ User\", value=f\"{message.author.mention} ({message.author})\", inline=False)\n                        embed.add_field(name=\"üìç Channel\", value=f\"{message.channel.mention}\", inline=True)\n                        embed.add_field(name=\"üö´ Triggered Word\", value=f\"||{banned_word}||\", inline=True)\n                        embed.add_field(name=\"üí¨ Message Content\", value=f\"||{message.content[:500]}||\", inline=False)\n                        actions_taken = []\n                        if database_logged:\n                            actions_taken.append(\"‚Ä¢ Warned user\")\n                        if timeout_success:\n                            actions_taken.append(\"‚Ä¢ Muted for 10 minutes\")\n                        if message_deleted:\n                            actions_taken.append(\"‚Ä¢ Message deleted\")\n\n                        if not actions_taken:\n                            actions_taken.append(\"‚Ä¢ No actions taken (permission errors)\")\n\n                        embed.add_field(name=\"‚ö° Actions Taken\", value=\"\\n\".join(actions_taken), inline=False)\n                        embed.set_footer(text=\"üî• Game Services Automod System\")\n\n                        view = AutomodBanView(message.author, message.content, message.channel)\n                        await automod_channel.send(embed=embed, view=view)\n\n                    # DM the user (only if any action was taken)\n                    if timeout_success or database_logged:\n                        try:\n                            dm_embed = discord.Embed(\n                                title=\"‚ö†Ô∏è Automod Warning\",\n                                description=\"Your message contained inappropriate content and has been removed.\",\n                                color=0xFFC916,\n                                timestamp=discord.utils.utcnow()\n                            )\n                            dm_embed.add_field(name=\"üè† Server\", value=f\"{message.guild.name}\", inline=True)\n                            if timeout_success:\n                                dm_embed.add_field(name=\"‚è±Ô∏è Mute Duration\", value=\"10 minutes\", inline=True)\n                            dm_embed.add_field(name=\"üìã Reason\", value=f\"Used inappropriate word: ||{banned_word}||\", inline=False)\n                            dm_embed.add_field(name=\"üö® Appeal\", value=\"If you believe this was a mistake, contact staff in our appeals server:\\nhttps://discord.gg/ahharETNNR\", inline=False)\n                            dm_embed.set_footer(text=\"üî• Game Services Automod System\")\n\n                            await message.author.send(embed=dm_embed)\n                        except discord.Forbidden:\n                            logger.info(f\"Cannot DM {message.author} - DMs disabled\")\n                        except Exception as dm_error:\n                            logger.error(f\"Error sending automod DM: {dm_error}\")\n\n                except Exception as e:\n                    logger.error(f\"Unexpected error in automod for {message.author}: {e}\")\n                    # Continue processing other banned words\n\n                return  # Stop processing if automod triggered\n\n    # Check for group math game answers\n    if message.channel.id in active_group_math_games:\n        game = active_group_math_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            if message.content.strip().replace('-', '').isdigit():\n                user_answer = int(message.content.strip())\n                if user_answer == game['answer']:\n                    # Award point\n                    if user_id not in game['players']:\n                        game['players'][user_id] = 0\n                    game['players'][user_id] += 1\n                    game['answered_this_round'].add(user_id)\n\n                    # React to show it was correct\n                    try:\n                        await message.add_reaction('<:GsRight:1414593140156792893> ')\n                    except:\n                        pass\n\n    # Check for group country game answers\n    if message.channel.id in active_group_country_games:\n        game = active_group_country_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            if message.content.lower().strip() == game['country'].lower():\n                # Award point\n                if user_id not in game['players']:\n                    game['players'][user_id] = 0\n                game['players'][user_id] += 1\n                game['answered_this_round'].add(user_id)\n\n                # React to show it was correct\n                try:\n                    await message.add_reaction('<:GsRight:1414593140156792893>')\n                except:\n                    pass\n\n    # Check for group scramble game answers\n    if message.channel.id in active_group_scramble_games:\n        game = active_group_scramble_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            if message.content.lower().strip() == game['word'].lower():\n                # Award point\n                if user_id not in game['players']:\n                    game['players'][user_id] = 0\n                game['players'][user_id] += 1\n                game['answered_this_round'].add(user_id)\n\n                # React to show it was correct\n                try:\n                    await message.add_reaction('<:GsRight:1414593140156792893> ')\n                except:\n                    pass\n\n    # Check for group wordbomb game answers\n    if message.channel.id in active_group_wordbomb_games:\n        game = active_group_wordbomb_games[message.channel.id]\n        user_id = message.author.id\n\n        # Check if user already answered this round\n        if user_id not in game['answered_this_round']:\n            answer = message.content.lower().strip()\n            # Enhanced validation for proper words\n            if (len(answer) >= 3 and\n                game['sequence'].lower() in answer and\n                answer.isalpha() and\n                answer not in game['used_words'] and\n                is_valid_word(answer, game['sequence'])):\n\n                # Award point\n                if user_id not in game['players']:\n                    game['players'][user_id] = 0\n                game['players'][user_id] += 1\n                game['answered_this_round'].add(user_id)\n                game['used_words'].add(answer)\n\n                # React to show it was correct\n                try:\n                    await message.add_reaction('<:GsRight:1414593140156792893> ')\n                except:\n                    pass\n\n    # Process commands\n    await bot.process_commands(message)\n\n    # WFL reactions\n    if message.channel.id == TARGET_CHANNEL_ID:\n        if WFL_PATTERN.search(message.content):\n            current_time = asyncio.get_event_loop().time()\n            if (message.channel.id in last_reaction_time and\n                current_time - last_reaction_time[message.channel.id] < reaction_cooldown):\n                return\n\n            last_reaction_time[message.channel.id] = current_time\n\n            reactions = ['W1', 'F1', 'L1']\n            try:\n                for emoji_name in reactions:\n                    emoji = discord.utils.get(message.guild.emojis, name=emoji_name)\n                    if emoji:\n                        await message.add_reaction(emoji)\n                    await asyncio.sleep(0.5)\n            except Exception as e:\n                logger.error(f'Error adding reactions: {e}')\n\n@bot.command()\nasync def petweight(ctx, current_age: int, current_weight: float, target_age: Optional[int] = None):\n    \"\"\"üêæ Calculate pet weight at different ages\"\"\"\n    try:\n        if current_age < 1 or current_age > 100:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Pet Age must be between 1 and 100\")\n            return\n\n        if current_weight <= 0:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Pet Weight must be greater than 0\")\n            return\n\n        if target_age is not None:\n            if target_age < 1 or target_age > 100:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Pet Target age must be between 1 and 100\")\n                return\n\n            predictions = predict_weights(current_age, current_weight, [target_age])\n            if predictions is None:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid Pet age provided\")\n                return\n            predicted_weight = predictions[target_age]\n            embed = discord.Embed(\n                title=\"Petweight Prediction\",\n                url=\"https://discord.gg/4Jy4R8kMaf\",  # <- clickable title link\n                color=0xFFC916\n            )\n            embed.add_field(name=\"Current Info:\", value=f\"**Age:** {current_age} \\n**Weight:** {current_weight} <:KG:1414601553167519864>  \", inline=False)\n            \n            embed.add_field(name=f\"Predicted Weight at Age {target_age}\", value=f\"**{predicted_weight} <:KG:1414601553167519864> ** \", inline=False)\n            \n            embed.set_footer(text=\"üî• Game Services ‚Ä¢ Pet Weight Calculator\")\n            \n            await ctx.reply(embed=embed, mention_author=True)\n            await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n\n        else:\n            predictions = predict_weights(current_age, current_weight)\n            if predictions is None:\n                await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid age provided\")\n                return\n\n            key_ages = []\n            for age in range(current_age, min(current_age + 11, 101)):\n                if age in predictions:\n                    key_ages.append(age)\n\n            if len(key_ages) < 10:\n                for age in range(max(1, current_age - 5), current_age):\n                    if age in predictions and age not in key_ages:\n                        key_ages.insert(0, age)\n\n            key_ages = sorted(key_ages)[:10]\n\n            embed = discord.Embed(\n                title=\"Petweight Prediction\",\n                url=\"https://discord.gg/4Jy4R8kMaf\",  # <- clickable title link\n                color=0xFFC916\n            )\n            embed.add_field(name=\" Current Info:\", value=f\"**Age:** {current_age} üìÖ\\n**Weight:** {current_weight} <:KG:1414601553167519864> \", inline=False)\n\n            weight_text = \"\"\n            for age in key_ages:\n                marker = \" ‚Üê **Current**\" if age == current_age else \"\"\n                weight_text += f\"**Age {age}:** {predictions[age]} kg{marker}\\n\"\n\n            embed.add_field(name=\"Weight Predictions:\", value=weight_text, inline=False)\n            embed.add_field(name=\"Tip:\", value=\"Use `gs.petweight <age> <weight> <target_age>` to predict weight at a specific age\", inline=False)\n            embed.set_footer(text=\"üî• Game Services ‚Ä¢ Pet Weight Calculator\")\n\n            await ctx.reply(embed=embed, mention_author=True)\n            await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n\n    except ValueError:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   Please provide valid numbers for age and weight\")\n    except Exception as e:\n        logger.error(f\"Error in petweight command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while calculating weights\")\n\n@bot.command(aliases=['v', 'value', 'val'])\nasync def petvalue(ctx, *, pet_name: str):\n    \"\"\"üêæ Look up pet value information\"\"\"\n    try:\n        # Lazy fallback: Load pets if database is empty \n        if not PET_DATABASE:\n            logger.warning(\"PET_DATABASE is empty, attempting to reload...\")\n            load_pet_data()\n            \n        logger.info(f\"üîç Pet value lookup for '{pet_name}' - Database has {len(PET_DATABASE)} pets\")\n        # Enhanced search\n        clean_name = re.sub(r'[^\\w\\s]', '', pet_name).strip().lower().replace(' ', '_')\n\n        # Direct match first\n        exact_match = None\n        for key, pet_data in PET_DATABASE.items():\n            if key == clean_name or pet_data['name'].lower() == pet_name.lower():\n                exact_match = pet_data\n                break\n\n        if exact_match:\n            embed = discord.Embed(\n                title=exact_match['name'],\n                url=\"https://discord.gg/4Jy4R8kMaf\",  # <- clickable title link\n                color=0xFFC916\n            )\n            embed.set_author(\n                name=\"Game Services Values\",\n                icon_url=\"https://images-ext-1.discordapp.net/external/o1Y_94Itjl4AeBMbyiY7Xow1UI36KpW2nqWOJ1bZcT0/%3Fsize%3D1024/https/cdn.discordapp.com/avatars/1381546186183278612/19ed5075b4b08f29a41dd99d080c31e9.png?format=webp&quality=lossless\"  # <- must be a direct image link\n            )\n\n            embed.add_field(name=\"<:ExclamationMark:1412880724809482260>  Pets are valued based on Mimic  <:MimicOctopus:1412404639164403752>\", value=\"> 1KG Mimic = 100 Value\", inline=False)\n            \n            embed.add_field(name=\"Value\", value=f\"{exact_match['value']} <:Sheckles:1412881740099223582>  \", inline=True)\n            \n            embed.add_field(name=\"Demand\", value=f\"{exact_match['demand']}\", inline=True)\n\n            embed.add_field(\n                name=\"Trend\",\n                value=exact_match.get(\"trend\") or \"Adding\",\n                inline=True\n            )\n            embed.add_field(\n                name=\"Tier\",\n                value=exact_match.get(\"tier\") or \"Adding\",\n                inline=True\n            )\n            embed.add_field(\n                name=\"Obtained By\",\n                value=exact_match.get(\"obtainement\") or \"Adding\",\n                inline=True\n            )\n\n            if 'image_url' in exact_match and exact_match['image_url']:\n                try:\n                    # Clean the image URL and ensure it's properly formatted\n                    image_url = exact_match['image_url'].strip()\n                    # Remove 'lossless' parameter if present\n                    if 'quality=lossless' in image_url:\n                        image_url = image_url.replace('&quality=lossless', '').replace('quality=lossless&', '').replace('quality=lossless', '')\n                    embed.set_thumbnail(url=image_url)\n                    logger.info(f\"<:GsRight:1414593140156792893>  Successfully displaying image for {exact_match['name']}\")\n                except Exception as e:\n                    logger.error(f\"<:GsWrong:1414561861352816753>   Error setting image for {exact_match['name']}: {e}\")\n            else:\n                logger.warning(f\"No image available for {exact_match['name']}\")\n\n            embed.set_footer(text=\"üî• Game Services ‚Ä¢ Info: (100% match)\")\n\n            from discord.ui import View, Button\n\n            # build ONE link-button view\n            view = View()\n\n            # first button\n            view.add_item(Button(\n                label=\"Suggest Values\",\n                url=\"https://discord.com/channels/1370086525210984458/1391747223884136590\",\n                style=discord.ButtonStyle.link\n            ))\n\n            # second button\n            view.add_item(Button(\n                label=\"Values Explained\",\n                url=\"https://discord.com/channels/1370086525210984458/1370101881308713193/1406781226018406450\",\n                style=discord.ButtonStyle.link\n            ))\n            # send a single reply with the embed + button\n            try:\n                reply_msg = await ctx.reply(embed=embed, view=view, mention_author=True)\n            except Exception as e:\n                # fallback if sending with a view fails for any reason\n                print(f\"\")\n                reply_msg = await ctx.reply(embed=embed, mention_author=True)\n\n            # add reaction to the original message (the one that triggered the command)\n            try:\n                await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n            except Exception as e:\n                # Ignore/log permission/emoji errors\n                print(f\"\")\n\n            return\n\n\n\n        # Fuzzy search\n        best_matches = find_best_pet_matches(pet_name, max_results=5)\n        if best_matches:\n            # Auto-select best match\n            top_match = best_matches[0]\n            pet_data = top_match[0]  # dict for the pet\n\n            embed = discord.Embed(\n                title=pet_data[\"name\"],  \n                url=\"https://discord.gg/4Jy4R8kMaf\",\n                color=0xFFC916\n            )\n\n            embed.set_author(\n                name=\"Game Services Values\",\n                icon_url=\"https://cdn.discordapp.com/avatars/1381546186183278612/19ed5075b4b08f29a41dd99d080c31e9.png?size=1024\"\n            )\n\n            embed.add_field(\n                name=\"<:ExclamationMark:1412880724809482260>  Pets are valued based on Mimic  <:MimicOctopus:1412404639164403752>\",\n                value=\"> 1KG Mimic = 100 Value\",\n                inline=False\n            )\n\n            embed.add_field(\n                name=\"Value\",\n                value=f\"{pet_data['value']} <:Sheckles:1412881740099223582>\",\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Demand\",\n                value=pet_data[\"demand\"],\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Trend\",\n                value=pet_data[\"trend\"],\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Tier\",\n                value=pet_data[\"tier\"],\n                inline=True\n            )\n\n            embed.add_field(\n                name=\"Obtained By\",\n                value=pet_data[\"obtainement\"],\n                inline=True\n            )\n\n            # <:GsRight:1414593140156792893>  Add thumbnail if available\n            if 'image_url' in pet_data and pet_data['image_url']:\n                try:\n                    image_url = pet_data['image_url'].strip()\n                    if 'quality=lossless' in image_url:\n                        image_url = image_url.replace('&quality=lossless', '').replace('quality=lossless&', '').replace('quality=lossless', '')\n                    embed.set_thumbnail(url=image_url)\n                    logger.info(f\"<:GsRight:1414593140156792893>  Successfully displaying image for {pet_data['name']}\")\n                except Exception as e:\n                    logger.error(f\"<:GsWrong:1414561861352816753>   Error setting image for {pet_data['name']}: {e}\")\n            else:\n                logger.warning(f\"No image available for {pet_data['name']}\")\n\n            # <:GsRight:1414593140156792893>  Add footer after match quality\n            footer_text = \"üî• Game Services ‚Ä¢ INSTANT UPDATES\"\n            if top_match[1] < 100:\n                footer_text = f\"üî• Game Services ‚Ä¢ Info: ({top_match[1]}% match)\"\n            embed.set_footer(text=footer_text)\n\n            from discord.ui import View, Button\n\n            # build ONE link-button view\n            view = View()\n\n            # first button\n            view.add_item(Button(\n                label=\"Suggest Values\",\n                url=\"https://discord.com/channels/1370086525210984458/1391747223884136590\",\n                style=discord.ButtonStyle.link\n            ))\n\n            # second button\n            view.add_item(Button(\n                label=\"Values Explained\",\n                url=\"https://discord.com/channels/1370086525210984458/1370101881308713193/1406781226018406450\",\n                style=discord.ButtonStyle.link\n            ))\n            # send a single reply with the embed + button\n            try:\n                reply_msg = await ctx.reply(embed=embed, view=view, mention_author=True)\n            except Exception as e:\n                # fallback if sending with a view fails for any reason\n                print(f\"\")\n                reply_msg = await ctx.reply(embed=embed, mention_author=True)\n\n            # add reaction to the original message (the one that triggered the command)\n            try:\n                await ctx.message.add_reaction('<:GsRight:1414593140156792893>')\n            except Exception as e:\n                # Ignore/log permission/emoji errors\n                print(f\"\")\n\n            return\n\n        else:\n            await ctx.reply(f\"**{pet_name}** could not be found\")\n\n            try:\n                await ctx.message.add_reaction('<:GsWrong:1414561861352816753>')\n            except:\n                pass\n\n    except Exception as e:\n        logger.error(f\"Error in petvalue command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while looking up pet values\")\n\n@bot.command(name=\"forceupdate\", aliases=['force', 'refresh'])\nasync def force_update_pets(ctx):\n    \"\"\"üîÑ Force update pet database by rescanning all pet value channels (Admin only)\"\"\"\n    if not ctx.author.guild_permissions.administrator:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You need administrator permissions to force update the database.\")\n        return\n\n@bot.command(aliases=['pets', 'list'])\nasync def petlist(ctx, page: int = 1):\n    \"\"\"üìã List all pets in the database\"\"\"\n    try:\n        if not PET_DATABASE:\n            await ctx.send(\"<:GsWrong:1414561861352816753>   No pets found in database\")\n            return\n\n        pets_per_page = 15\n        total_pets = len(PET_DATABASE)\n        total_pages = (total_pets + pets_per_page - 1) // pets_per_page\n\n        if page < 1 or page > total_pages:\n            await ctx.send(f\"<:GsWrong:1414561861352816753>   Invalid page number. Pages available: 1-{total_pages}\")\n            return\n\n        start_idx = (page - 1) * pets_per_page\n        end_idx = start_idx + pets_per_page\n\n        pets = list(PET_DATABASE.values())[start_idx:end_idx]\n\n        embed = discord.Embed(title=\"üêæ Pet Database\", color=0xFFC916)\n        embed.add_field(name=\"üìä Total Pets\", value=f\"**{total_pets}** pets üéØ\", inline=True)\n        embed.add_field(name=\"üìÑ Page\", value=f\"**{page}/{total_pages}** üìã\", inline=True)\n        embed.add_field(name=\"üîÑ Auto-Updated\", value=\"**Real-time** ‚ö°\", inline=True)\n\n        pet_list = \"\"\n        for pet in pets:\n            demand_emoji = {\"High\": \"üî•\", \"Medium\": \"üìà\", \"Low\": \"üìâ\", \"Extremely High\": \"üíé\", \"Terrible\": \"üíÄ\"}.get(pet['demand'], \"üìä\")\n            pet_list += f\"‚Ä¢ **{pet['name']}** - {pet['value']} | {pet['demand']} {demand_emoji}\\n\"\n\n        embed.add_field(name=\"üêæ Pets\", value=pet_list or \"No pets on this page\", inline=False)\n\n        if page < total_pages:\n            embed.add_field(name=\"üí° Navigation\", value=f\"Use `gs.petlist {page + 1}` for next page ‚û°Ô∏è\\nUse `gs.v <name>` to get detailed info üîç\", inline=False)\n        else:\n            embed.add_field(name=\"üí° Usage\", value=\"Use `gs.v <name>` to get detailed pet info üîç\", inline=False)\n\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ AUTO-SCAN ALL MESSAGES\")\n        await ctx.send(embed=embed)\n\n    except Exception as e:\n        logger.error(f\"Error in petlist command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while listing pets\")\n\n@bot.command(aliases=['country', 'flag', 'guess'])\nasync def countryguess(ctx):\n    \"\"\"üåç Start a country guessing game\"\"\"\n    if ctx.channel.id in active_games:\n        await ctx.send(\"üéÆ A game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Select random country\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    active_games[ctx.channel.id] = {\n        'country': country,\n        'players': {},\n        'round': 1,\n        'max_rounds': 5,\n        'start_time': discord.utils.utcnow()\n    }\n\n    embed = discord.Embed(\n        title=\"üåç Country Guessing Game Started!\",\n        description=f\"**Round 1/5:** What country does this flag belong to? ü§î\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"15 seconds per round ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üéØ How to Play\", value=\"Just type the country name! üí¨\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"First correct answer gets a point! ü•á\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Anyone can play!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.lower().strip() == country.lower())\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        # Award point\n        user_id = winner_msg.author.id\n        if user_id not in active_games[ctx.channel.id]['players']:\n            active_games[ctx.channel.id]['players'][user_id] = 0\n        active_games[ctx.channel.id]['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"üéâ {winner_msg.author.mention} got it right! That's **{country}**.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Great job!\")\n        await ctx.send(embed=embed)\n\n        # Continue game or end\n        if active_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_games[ctx.channel.id]['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"‚è∞ Time's Up!\",\n            description=f\"No one got it! The answer was **{country}** {flag}\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Better luck next time!\")\n        await ctx.send(embed=embed)\n\n        if active_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_games[ctx.channel.id]['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\nasync def continue_country_game(ctx):\n    \"\"\"Continue the country guessing game\"\"\"\n    if ctx.channel.id not in active_games:\n        return\n\n    game = active_games[ctx.channel.id]\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    game['country'] = country\n\n    embed = discord.Embed(\n        title=\"üåç Country Guessing Game\",\n        description=f\"**Round {game['round']}/5:** What country does this flag belong to? ü§î\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"15 seconds ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üèÜ Current Scores\", value=\"\\n\".join([f\"<@{uid}>: {score} üéØ\" for uid, score in game['players'].items()]) if game['players'] else \"No scores yet üìä\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Keep guessing!\")\n\n    await ctx.send(embed=embed)\n\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.lower().strip() == country.lower())\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        user_id = winner_msg.author.id\n        if user_id not in game['players']:\n            game['players'][user_id] = 0\n        game['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"üéâ {winner_msg.author.mention} got it right! That's **{country}**.\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"‚è∞ Time's Up!\",\n            description=f\"No one got it! The answer was **{country}** {flag}\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_country_game(ctx)\n        else:\n            await end_country_game(ctx)\n\nasync def end_country_game(ctx):\n    \"\"\"End the country guessing game and show results\"\"\"\n    if ctx.channel.id not in active_games:\n        return\n\n    game = active_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"üéÆ Game Over!\",\n            description=\"No one scored any points! Better luck next time! üòÖ\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            leaderboard += f\"{medal} <@{user_id}>: **{score}** points\\n\"\n\n        embed = discord.Embed(\n            title=\"üéÆ Game Over! Final Scores:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"üèÜ Winner\", value=f\"üéâ <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"üîÑ Play Again\", value=\"Use `gs.countryguess` to start a new game! üåç\", inline=False)\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_games[ctx.channel.id]\n\n@bot.command(name=\"mathquestions\", aliases=['math', 'mathgame', 'mathquiz'])\nasync def mathquestions(ctx):\n    \"\"\"üßÆ Start a math questions game\"\"\"\n    if ctx.channel.id in active_math_games:\n        await ctx.send(\"üéÆ A math game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Generate first math question\n    num1, num2, operation, answer = generate_math_question()\n    active_math_games[ctx.channel.id] = {\n        'answer': answer,\n        'players': {},\n        'round': 1,\n        'max_rounds': 5,\n        'start_time': discord.utils.utcnow()\n    }\n\n    embed = discord.Embed(\n        title=\"üßÆ Math Questions Game Started!\",\n        description=f\"**Round 1/5:** What is the answer to this equation? ü§î\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"15 seconds per round ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üéØ How to Play\", value=\"Just type the number! üí¨\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"First correct answer gets a point! ü•á\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Anyone can play!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.strip().replace('-', '').isdigit() and\n                int(m.content.strip()) == answer)\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        # Award point\n        user_id = winner_msg.author.id\n        if user_id not in active_math_games[ctx.channel.id]['players']:\n            active_math_games[ctx.channel.id]['players'][user_id] = 0\n        active_math_games[ctx.channel.id]['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"üéâ {winner_msg.author.mention} got it right! The answer was **{answer}**.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Great job!\")\n        await ctx.send(embed=embed)\n\n        # Continue game or end\n        if active_math_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_math_games[ctx.channel.id]['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"‚è∞ Time's Up!\",\n            description=f\"No one got it! The answer was **{answer}**\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Better luck next time!\")\n        await ctx.send(embed=embed)\n\n        if active_math_games[ctx.channel.id]['round'] < 5:\n            await asyncio.sleep(2)\n            active_math_games[ctx.channel.id]['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\ndef generate_math_question():\n    \"\"\"Generate a random math question\"\"\"\n    operations = ['+', '-', '*', '/']\n    operation = random.choice(operations)\n\n    if operation == '+':\n        num1 = random.randint(10, 100)\n        num2 = random.randint(10, 100)\n        answer = num1 + num2\n    elif operation == '-':\n        num1 = random.randint(20, 100)\n        num2 = random.randint(10, num1)  # Ensure positive result\n        answer = num1 - num2\n    elif operation == '*':\n        num1 = random.randint(2, 15)\n        num2 = random.randint(2, 15)\n        answer = num1 * num2\n    else:  # division\n        answer = random.randint(2, 20)\n        num2 = random.randint(2, 12)\n        num1 = answer * num2  # Ensure clean division\n        operation = '√∑'\n\n    return num1, num2, operation, answer\n\nasync def continue_math_game(ctx):\n    \"\"\"Continue the math game\"\"\"\n    if ctx.channel.id not in active_math_games:\n        return\n\n    game = active_math_games[ctx.channel.id]\n    num1, num2, operation, answer = generate_math_question()\n    game['answer'] = answer\n\n    embed = discord.Embed(\n        title=\"üßÆ Math Questions Game\",\n        description=f\"**Round {game['round']}/5:** What is the answer to this equation? ü§î\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"15 seconds ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üèÜ Current Scores\", value=\"\\n\".join([f\"<@{uid}>: {score} üéØ\" for uid, score in game['players'].items()]) if game['players'] else \"No scores yet üìä\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Keep calculating!\")\n\n    await ctx.send(embed=embed)\n\n    def check(m):\n        return (m.channel == ctx.channel and\n                not m.author.bot and\n                m.content.strip().replace('-', '').isdigit() and\n                int(m.content.strip()) == answer)\n\n    try:\n        winner_msg = await bot.wait_for('message', check=check, timeout=15.0)\n\n        user_id = winner_msg.author.id\n        if user_id not in game['players']:\n            game['players'][user_id] = 0\n        game['players'][user_id] += 1\n\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answer!\",\n            description=f\"üéâ {winner_msg.author.mention} got it right! The answer was **{answer}**.\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\n    except asyncio.TimeoutError:\n        embed = discord.Embed(\n            title=\"‚è∞ Time's Up!\",\n            description=f\"No one got it! The answer was **{answer}**\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n\n        if game['round'] < 5:\n            await asyncio.sleep(2)\n            game['round'] += 1\n            await continue_math_game(ctx)\n        else:\n            await end_math_game(ctx)\n\nasync def end_math_game(ctx):\n    \"\"\"End the math game and show results\"\"\"\n    if ctx.channel.id not in active_math_games:\n        return\n\n    game = active_math_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"üéÆ Game Over!\",\n            description=\"No one scored any points! Better luck next time! üòÖ\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            leaderboard += f\"{medal} <@{user_id}>: **{score}** points\\n\"\n\n        embed = discord.Embed(\n            title=\"üéÆ Game Over! Final Scores:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"üèÜ Winner\", value=f\"üéâ <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"üîÑ Play Again\", value=\"Use `gs.mathquestions` to start a new game! üßÆ\", inline=False)\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_math_games[ctx.channel.id]\n\n@bot.command(name=\"groupmath\", aliases=['gmath', 'groupmathgame', 'mgame'])\nasync def group_math_game(ctx):\n    \"\"\"üßÆ Start a group math game where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_math_games:\n        await ctx.send(\"üéÆ A group math game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"üßÆ Group Math Game - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the group math challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üéØ How to Play\", value=\"Answer math questions as fast as you can! üí¨\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"1 point for each correct answer! ü•á\", inline=True)\n    embed.add_field(name=\"üìä Rounds\", value=\"10 questions total üìù\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Generate first math question\n    num1, num2, operation, answer = generate_math_question()\n    active_group_math_games[ctx.channel.id] = {\n        'answer': answer,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"üßÆ Group Math Game Started!\",\n        description=f\"**Round 1/10:** ü§î\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"20 seconds per round ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(participants)} joined! üéØ\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"1 point for each correct answer! ü•á\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Group Math Challenge!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(20)  # Give 20 seconds for everyone to answer\n    await continue_group_math_game(ctx)\n\n@bot.command(name=\"groupcountriesquiz\", aliases=['gcountry', 'groupcountry', 'gcountries', 'countrygame', 'countries', 'flags'])\nasync def group_country_quiz(ctx):\n    \"\"\"üåç Start a group countries quiz where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_country_games:\n        await ctx.send(\"üéÆ A group countries quiz is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"üåç Group Countries Quiz - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the geography challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üéØ How to Play\", value=\"Guess country names from flags! üè≥Ô∏è\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"1 point for each correct guess! ü•á\", inline=True)\n    embed.add_field(name=\"üìä Rounds\", value=\"10 flags total üåç\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Select random country\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    active_group_country_games[ctx.channel.id] = {\n        'country': country,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"üåç Group Countries Quiz Started!\",\n        description=f\"**Round 1/10:** Guess this country! ü§î\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"20 seconds per round ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(participants)} joined! üéØ\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"1 point for each correct answer! ü•á\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Group Geography Challenge!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(20)  # Give 20 seconds for everyone to answer\n    await continue_group_country_game(ctx)\n\nasync def continue_group_math_game(ctx):\n    \"\"\"Continue the group math game\"\"\"\n    if ctx.channel.id not in active_group_math_games:\n        return\n\n    game = active_group_math_games[ctx.channel.id]\n\n    # Show who got the last question right\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answers!\",\n            description=f\"üéâ **{len(correct_users)}** players got it right!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"üìä Answer\", value=f\"**{game['answer']}**\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_math_game(ctx)\n        return\n\n    # Clear answered set for new round\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new question\n    num1, num2, operation, answer = generate_math_question()\n    game['answer'] = answer\n\n    embed = discord.Embed(\n        title=\"üßÆ Group Math Game\",\n        description=f\"**Round {game['round']}/10:** What's the answer? ü§î\\n\\n**{num1} {operation} {num2} = ?**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"15 seconds ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(game['players'])} participating üéØ\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Keep calculating!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(20)\n    await continue_group_math_game(ctx)\n\nasync def continue_group_country_game(ctx):\n    \"\"\"Continue the group country game\"\"\"\n    if ctx.channel.id not in active_group_country_games:\n        return\n\n    game = active_group_country_games[ctx.channel.id]\n\n    # Show who got the last question right\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answers!\",\n            description=f\"üéâ **{len(correct_users)}** players got it right!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"üåç Answer\", value=f\"**{game['country']}**\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_country_game(ctx)\n        return\n\n    # Clear answered set for new round\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new country\n    flag, country = random.choice(list(COUNTRIES_FLAGS.items()))\n    game['country'] = country\n\n    embed = discord.Embed(\n        title=\"üåç Group Countries Quiz\",\n        description=f\"**Round {game['round']}/10:** What country is this? ü§î\\n\\n{flag}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"15 seconds ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(game['players'])} participating üéØ\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Keep guessing!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(20)\n    await continue_group_country_game(ctx)\n\nasync def end_group_math_game(ctx):\n    \"\"\"End the group math game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_math_games:\n        return\n\n    game = active_group_math_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"üéÆ Group Math Game Over!\",\n            description=\"No one participated! Better luck next time! üòÖ\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            percentage = int((score / game['max_rounds']) * 100)\n            leaderboard += f\"{medal} <@{user_id}>: **{score}/{game['max_rounds']}** ({percentage}%)\\n\"\n\n        embed = discord.Embed(\n            title=\"üéÆ Group Math Game Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"üèÜ Winner\", value=f\"üéâ <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"üìä Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** questions asked\", inline=True)\n        embed.add_field(name=\"üîÑ Play Again\", value=\"Use `gs.groupmath` to start a new game! üßÆ\", inline=False)\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_math_games[ctx.channel.id]\n\nasync def end_group_country_game(ctx):\n    \"\"\"End the group country game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_country_games:\n        return\n\n    game = active_group_country_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"üéÆ Group Countries Quiz Over!\",\n            description=\"No one participated! Better luck next time! üòÖ\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            percentage = int((score / game['max_rounds']) * 100)\n            leaderboard += f\"{medal} <@{user_id}>: **{score}/{game['max_rounds']}** ({percentage}%)\\n\"\n\n        embed = discord.Embed(\n            title=\"üéÆ Group Countries Quiz Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"üèÜ Winner\", value=f\"üéâ <@{winner_id}> with **{winner_score}** points!\", inline=False)\n\n        embed.add_field(name=\"üìä Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** questions asked\", inline=True)\n        embed.add_field(name=\"üîÑ Play Again\", value=\"Use `gs.groupcountriesquiz` to start a new game! üåç\", inline=False)\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_country_games[ctx.channel.id]\n\n@bot.command(name=\"groupscramble\", aliases=['gscramble', 'groupunscramble', 'gunscramble', 'scramble', 'unscramble', 'wordgame'])\nasync def group_scramble_game(ctx):\n    \"\"\"üî§ Start a group word scramble game where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_scramble_games:\n        await ctx.send(\"üéÆ A group scramble game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"üî§ Group Word Scramble - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the word scramble challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üéØ How to Play\", value=\"Unscramble mixed up words! üî§\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"1 point for each word solved! ü•á\", inline=True)\n    embed.add_field(name=\"üìä Rounds\", value=\"10 words total üìù\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Select random word and scramble it\n    word = random.choice(SCRAMBLE_WORDS)\n    scrambled = scramble_word(word)\n\n    active_group_scramble_games[ctx.channel.id] = {\n        'word': word,\n        'scrambled': scrambled,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"üî§ Group Word Scramble Started!\",\n        description=f\"**Round 1/10:** Unscramble this word! ü§î\\n\\n{scrambled.upper()}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"20 seconds per round ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(participants)} joined! üéØ\", inline=True)\n    embed.add_field(name=\"üí° Hint\", value=f\"The word has **{len(word)}** letters\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Group Word Challenge!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(20)  # Give 20 seconds for everyone to answer\n    await continue_group_scramble_game(ctx)\n\ndef scramble_word(word):\n    \"\"\"Scramble a word by shuffling its letters\"\"\"\n    word_list = list(word)\n    random.shuffle(word_list)\n    scrambled = ''.join(word_list)\n\n    # Make sure it's actually scrambled\n    attempts = 0\n    while scrambled.lower() == word.lower() and attempts < 10:\n        random.shuffle(word_list)\n        scrambled = ''.join(word_list)\n        attempts += 1\n\n    return scrambled\n\ndef is_valid_word(word, sequence):\n    \"\"\"Validate that a word is proper for wordbomb (prevents cheating like 'chhhh')\"\"\"\n    # Basic checks\n    if len(word) < 3:\n        return False\n\n    # Must contain the sequence\n    if sequence.lower() not in word.lower():\n        return False\n\n    # Check for excessive repetition (like \"chhhh\") - STRICT VALIDATION\n    char_counts = {}\n    for char in word:\n        char_counts[char] = char_counts.get(char, 0) + 1\n\n    # For sequences like \"ch\", prevent words like \"chhhh\" by limiting consecutive repeats\n    sequence_chars = set(sequence.lower())\n    for char in sequence_chars:\n        if char in char_counts and char_counts[char] > 2:\n            # Special case: if the sequence is just repeated chars (like \"chhhh\"), reject it\n            if word.lower().count(char * 3) > 0:  # 3+ consecutive same chars\n                return False\n\n    # No single character should appear more than 3 times total\n    max_repeats = max(char_counts.values())\n    if max_repeats > 3:\n        return False\n\n    # Prevent words that are just the sequence repeated\n    if word.lower() == sequence.lower() * (len(word) // len(sequence)):\n        return False\n\n    # Check for reasonable word structure (vowels and consonants)\n    vowels = set('aeiou')\n    has_vowel = any(char in vowels for char in word)\n    has_consonant = any(char not in vowels and char.isalpha() for char in word)\n\n    # Must have at least one vowel and one consonant for longer words\n    if len(word) > 3 and not (has_vowel and has_consonant):\n        return False\n\n    # Prevent nonsense words that are just repeated characters\n    unique_chars = len(set(word.lower()))\n    if unique_chars < 2 and len(word) > 3:  # Words like \"aaaa\" or \"bbbb\"\n        return False\n\n    return True\n\nasync def continue_group_scramble_game(ctx):\n    \"\"\"Continue the group scramble game\"\"\"\n    if ctx.channel.id not in active_group_scramble_games:\n        return\n\n    game = active_group_scramble_games[ctx.channel.id]\n\n    # Show who got the last question right\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"<:GsRight:1414593140156792893>  Correct Answers!\",\n            description=f\"üéâ **{len(correct_users)}** players got it right!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"üìù Answer\", value=f\"**{game['word'].upper()}**\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_scramble_game(ctx)\n        return\n\n    # Clear answered set for new round\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new scramble\n    word = random.choice(SCRAMBLE_WORDS)\n    scrambled = scramble_word(word)\n    game['word'] = word\n    game['scrambled'] = scrambled\n\n    embed = discord.Embed(\n        title=\"üî§ Group Word Scramble\",\n        description=f\"**Round {game['round']}/10:** Unscramble this word! ü§î\\n\\n**{scrambled.upper()}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"20 seconds ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(game['players'])} participating üéØ\", inline=True)\n    embed.add_field(name=\"üí° Hint\", value=f\"The word has **{len(word)}** letters\", inline=False)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Keep unscrambling!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(20)\n    await continue_group_scramble_game(ctx)\n\nasync def end_group_scramble_game(ctx):\n    \"\"\"End the group scramble game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_scramble_games:\n        return\n\n    game = active_group_scramble_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"üéÆ Group Word Scramble Over!\",\n            description=\"No one participated! Better luck next time! üòÖ\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            percentage = int((score / game['max_rounds']) * 100)\n            leaderboard += f\"{medal} <@{user_id}>: **{score}/{game['max_rounds']}** ({percentage}%)\\n\"\n\n        embed = discord.Embed(\n            title=\"üéÆ Group Word Scramble Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"üèÜ Winner\", value=f\"üéâ <@{winner_id}> with **{winner_score}** words!\", inline=False)\n\n        embed.add_field(name=\"üìä Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** words scrambled\", inline=True)\n        embed.add_field(name=\"üîÑ Play Again\", value=\"Use `gs.groupscramble` to start a new game! üî§\", inline=False)\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_scramble_games[ctx.channel.id]\n\n@bot.command(name=\"groupwordbomb\", aliases=['gwordbomb', 'groupbomb', 'gbomb', 'wordbomb', 'bomb'])\nasync def group_wordbomb_game(ctx):\n    \"\"\"üí£ Start a group word bomb game where everyone can participate\"\"\"\n    if ctx.channel.id in active_group_wordbomb_games:\n        await ctx.send(\"üéÆ A group word bomb game is already active in this channel! Wait for it to finish.\")\n        return\n\n    # Create participation embed\n    embed = discord.Embed(\n        title=\"üí£ Group Word Bomb - Join Now!\",\n        description=\"React with <:GsRight:1414593140156792893>  to participate in the word bomb challenge!\\n\\n**20 seconds to join...**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üéØ How to Play\", value=\"Make words with given letter sequences! üí£\", inline=True)\n    embed.add_field(name=\"üèÜ Scoring\", value=\"1 point for each valid word! ü•á\", inline=True)\n    embed.add_field(name=\"üìä Rounds\", value=\"10 sequences total üí•\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ React to join!\")\n\n    message = await ctx.send(embed=embed)\n\n    # Bot reacts first\n    await message.add_reaction(\"<:GsRight:1414593140156792893> \")\n\n    # Wait 20 seconds for reactions\n    await asyncio.sleep(20)\n\n    # Get participants\n    updated_message = await ctx.channel.fetch_message(message.id)\n    participants = set()\n    for reaction in updated_message.reactions:\n        if str(reaction.emoji) == \"<:GsRight:1414593140156792893> \":\n            async for user in reaction.users():\n                if not user.bot:\n                    participants.add(user.id)\n\n    if not participants:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   No one joined the game! Better luck next time.\")\n        return\n\n    # Select random letter sequence\n    sequence = random.choice(WORDBOMB_SEQUENCES)\n\n    active_group_wordbomb_games[ctx.channel.id] = {\n        'sequence': sequence,\n        'players': {},\n        'round': 1,\n        'max_rounds': 10,\n        'start_time': discord.utils.utcnow(),\n        'answered_this_round': set(),\n        'used_words': set(),\n        'participants': participants\n    }\n\n    embed = discord.Embed(\n        title=\"üí£ Group Word Bomb Started!\",\n        description=f\"**Round 1/10:** Make words containing! üí•\\n\\n**{sequence.upper()}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"25 seconds per round ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(participants)} joined! üéØ\", inline=True)\n    embed.add_field(name=\"üìã Rules\", value=\"At least 3 letters, no repeats!\", inline=True)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Group Word Bomb!\")\n\n    await ctx.send(embed=embed)\n\n    # Wait for answers\n    await asyncio.sleep(25)  # Give 25 seconds for everyone to answer\n    await continue_group_wordbomb_game(ctx)\n\nasync def continue_group_wordbomb_game(ctx):\n    \"\"\"Continue the group word bomb game\"\"\"\n    if ctx.channel.id not in active_group_wordbomb_games:\n        return\n\n    game = active_group_wordbomb_games[ctx.channel.id]\n\n    # Show who got words this round\n    if game['answered_this_round']:\n        correct_users = [f\"<@{uid}>\" for uid in game['answered_this_round']]\n        embed = discord.Embed(\n            title=\"üí• Words Found!\",\n            description=f\"üéâ **{len(correct_users)}** players found valid words!\\n{', '.join(correct_users)}\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"üî§ Sequence\", value=f\"**{game['sequence'].upper()}**\", inline=True)\n        embed.add_field(name=\"üìä Words Found\", value=f\"**{len(game['used_words'])}** total\", inline=True)\n        await ctx.send(embed=embed)\n        await asyncio.sleep(2)\n\n    if game['round'] >= game['max_rounds']:\n        await end_group_wordbomb_game(ctx)\n        return\n\n    # Clear answered set for new round but keep used words\n    game['answered_this_round'].clear()\n    game['round'] += 1\n\n    # Generate new sequence\n    sequence = random.choice(WORDBOMB_SEQUENCES)\n    game['sequence'] = sequence\n    game['used_words'].clear()  # Reset used words for new sequence\n\n    embed = discord.Embed(\n        title=\"üí£ Group Word Bomb\",\n        description=f\"**Round {game['round']}/10:** Make words containing! üí•\\n\\n**{sequence.upper()}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"‚è∞ Time Limit\", value=\"25 seconds ‚è±Ô∏è\", inline=True)\n    embed.add_field(name=\"üë• Players\", value=f\"{len(game['players'])} participating üéØ\", inline=True)\n    embed.add_field(name=\"üìã Remember\", value=\"At least 3 letters, no repeats!\", inline=False)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Keep bombing!\")\n\n    await ctx.send(embed=embed)\n    await asyncio.sleep(25)\n    await continue_group_wordbomb_game(ctx)\n\nasync def end_group_wordbomb_game(ctx):\n    \"\"\"End the group word bomb game and show leaderboard\"\"\"\n    if ctx.channel.id not in active_group_wordbomb_games:\n        return\n\n    game = active_group_wordbomb_games[ctx.channel.id]\n\n    if not game['players']:\n        embed = discord.Embed(\n            title=\"üéÆ Group Word Bomb Over!\",\n            description=\"No one participated! Better luck next time! üòÖ\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n    else:\n        # Sort players by score\n        sorted_players = sorted(game['players'].items(), key=lambda x: x[1], reverse=True)\n\n        leaderboard = \"\"\n        for i, (user_id, score) in enumerate(sorted_players, 1):\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            leaderboard += f\"{medal} <@{user_id}>: **{score}** words found\\n\"\n\n        embed = discord.Embed(\n            title=\"üéÆ Group Word Bomb Over! Final Leaderboard:\",\n            description=leaderboard,\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n\n        if sorted_players:\n            winner_id = sorted_players[0][0]\n            winner_score = sorted_players[0][1]\n            embed.add_field(name=\"üèÜ Winner\", value=f\"üéâ <@{winner_id}> with **{winner_score}** words!\", inline=False)\n\n        embed.add_field(name=\"üìä Game Stats\", value=f\"**{len(game['players'])}** total participants\\n**{game['max_rounds']}** sequences bombed\", inline=True)\n        embed.add_field(name=\"üîÑ Play Again\", value=\"Use `gs.groupwordbomb` to start a new game! üí£\", inline=False)\n        embed.set_footer(text=\"üî• Game Services ‚Ä¢ Thanks for playing!\")\n\n    await ctx.send(embed=embed)\n    del active_group_wordbomb_games[ctx.channel.id]\n\n@bot.command(name=\"c\", aliases=[\"calc\", \"calculator\"])\nasync def calculate(ctx, *, expression: str):\n    \"\"\"üßÆ Calculator feature - Calculate math expressions\"\"\"\n    try:\n        # Replace common symbols with Python operators\n        expression = expression.replace('x', '*').replace('X', '*').replace('√∑', '/').replace('√ó', '*')\n\n        # Remove spaces\n        expression = expression.replace(' ', '')\n\n        # Basic validation - only allow numbers, operators, and parentheses\n        allowed_chars = set('0123456789+-*/.,()')\n        if not all(c in allowed_chars for c in expression):\n            await ctx.send(\"<:GsWrong:1414561861352816753>   Invalid characters in expression. Use only numbers and operators (+, -, *, /, x)\")\n            return\n\n        # Evaluate the expression safely\n        try:\n            result = eval(expression)\n\n            # Format result nicely\n            if isinstance(result, float):\n                if result.is_integer():\n                    result = int(result)\n                else:\n                    result = round(result, 6)  # Round to 6 decimal places\n\n            embed = discord.Embed(\n                title=\"üßÆ Calculator Result\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üìù Expression\", value=f\"`{expression}`\", inline=False)\n            embed.add_field(name=\"üéØ Result\", value=f\"**{result}**\", inline=False)\n            embed.add_field(name=\"üí° Usage\", value=\"Try: `gs.c 4+11`, `gs.c 4/11`, `gs.c 4x11`, `gs.c (5+3)*2`\", inline=False)\n            embed.set_footer(text=\"üî• Game Services ‚Ä¢ Calculator\")\n\n            await ctx.send(embed=embed)\n\n        except ZeroDivisionError:\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Calculation Error\",\n                description=\"Cannot divide by zero!\",\n                color=0xFFC916\n            )\n            embed.add_field(name=\"üìù Expression\", value=f\"`{expression}`\", inline=False)\n            embed.set_footer(text=\"üî• Game Services ‚Ä¢ Calculator\")\n            await ctx.send(embed=embed)\n\n        except Exception as e:\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Calculation Error\",\n                description=\"Invalid mathematical expression!\",\n                color=0xFFC916\n            )\n            embed.add_field(name=\"üìù Expression\", value=f\"`{expression}`\", inline=False)\n            embed.add_field(name=\"üí° Tip\", value=\"Make sure your expression is valid. Example: `gs.c 4+11`\", inline=False)\n            embed.set_footer(text=\"üî• Game Services ‚Ä¢ Calculator\")\n            await ctx.send(embed=embed)\n\n    except Exception as e:\n        logger.error(f\"Error in calculator command: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   An error occurred while calculating the expression.\")\n\n@bot.command(name=\"m\", aliases=[\"messages\", \"msgs\"])\nasync def show_messages(ctx, user: discord.Member = None):\n    \"\"\"üìä Show message statistics for a user\"\"\"\n    target_user = user or ctx.author\n    user_id = target_user.id\n\n    if user_id not in user_message_counts:\n        user_message_counts[user_id] = {'daily': 0, 'weekly': 0, 'monthly': 0, 'last_message': discord.utils.utcnow()}\n\n    data = user_message_counts[user_id]\n\n    embed = discord.Embed(title=\"üìä Message Statistics\", color=0xFFC916, timestamp=discord.utils.utcnow())\n    embed.set_thumbnail(url=target_user.display_avatar.url)\n\n    embed.add_field(name=\"üìÖ Daily Messages\", value=f\"**{data['daily']}** messages üìù\", inline=True)\n    embed.add_field(name=\"üìÑ Weekly Messages\", value=f\"**{data['weekly']}** messages üìö\", inline=True)\n    embed.add_field(name=\"üìö Monthly Messages\", value=f\"**{data['monthly']}** messages üìñ\", inline=True)\n\n    if data['last_message']:\n        last_msg_time = data['last_message']\n        time_ago = discord.utils.utcnow() - last_msg_time\n        if time_ago.days > 0:\n            last_msg_str = f\"{time_ago.days} days ago üìÖ\"\n        elif time_ago.seconds > 3600:\n            last_msg_str = f\"{time_ago.seconds // 3600} hours ago ‚è∞\"\n        elif time_ago.seconds > 60:\n            last_msg_str = f\"{time_ago.seconds // 60} minutes ago ‚è±Ô∏è\"\n        else:\n            last_msg_str = \"Just now üïê\"\n\n        embed.add_field(name=\"‚è∞ Last Message\", value=last_msg_str, inline=True)\n\n    embed.add_field(name=\"üë§ User\", value=f\"{target_user.mention} üéØ\", inline=False)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Message Tracking System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"msgtop\", aliases=[\"messageleaderboard\", \"msgleaderboard\"])\nasync def message_leaderboard(ctx, period: str = \"daily\"):\n    \"\"\"üèÜ Show top message senders\"\"\"\n    if period.lower() not in ['daily', 'weekly', 'monthly']:\n        embed = discord.Embed(\n            title=\"<:GsWrong:1414561861352816753>   Invalid Period\",\n            description=\"Please specify: `daily`, `weekly`, or `monthly` üìÖ\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n        return\n\n    if not user_message_counts:\n        embed = discord.Embed(\n            title=f\"üìä {period.title()} Message Leaderboard\",\n            description=\"No message data available yet. üìä\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n        return\n\n    # Sort by the specified period\n    leaderboard = []\n    for user_id, data in user_message_counts.items():\n        count = data[period.lower()]\n        if count > 0:\n            leaderboard.append((user_id, count))\n\n    leaderboard.sort(key=lambda x: x[1], reverse=True)\n    leaderboard = leaderboard[:10]  # Top 10\n\n    embed = discord.Embed(\n        title=f\"üèÜ {period.title()} Message Leaderboard\",\n        description=f\"Top 10 most active members ({period.lower()}) üí¨\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n\n    leaderboard_text = \"\"\n    for i, (user_id, count) in enumerate(leaderboard, 1):\n        user = bot.get_user(user_id)\n        if user:\n            medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            leaderboard_text += f\"{medal} {user.mention}: **{count}** messages üìù\\n\"\n\n    if leaderboard_text:\n        embed.add_field(name=\"üìã Rankings\", value=leaderboard_text, inline=False)\n    else:\n        embed.add_field(name=\"üìã Rankings\", value=\"No active users found üò¥\", inline=False)\n\n    embed.add_field(name=\"üîÑ Refresh\", value=f\"Use `gs.msgtop {period}` to update üìä\", inline=False)\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Message Tracking System\")\n    await ctx.send(embed=embed)\n\n# Moderation commands and views (kept from original code)\nclass ReportConfirmationView(discord.ui.View):\n    def __init__(self, user, reporter, reason, report_channel, report_embed):\n        super().__init__(timeout=300)\n        self.user = user\n        self.reporter = reporter\n        self.reason = reason\n        self.report_channel = report_channel\n        self.report_embed = report_embed\n        self.confirmed = None\n\n    @discord.ui.button(label=\"Submit Report\", style=discord.ButtonStyle.danger, emoji=\"üö®\")\n    async def submit_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.reporter:\n            try:\n                await interaction.response.send_message(\"Only the reporter can submit this report.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            await interaction.response.defer()\n\n            self.confirmed = True\n\n            # Send to report channel with staff moderation view\n            staff_view = StaffModerationView(self.user, self.reporter, self.reason)\n            await self.report_channel.send(embed=self.report_embed, view=staff_view)\n\n            # Confirmation to reporter\n            confirm_embed = discord.Embed(\n                title=\"<:GsRight:1414593140156792893>  Report Submitted Successfully\",\n                description=f\"Your report against {self.user.mention} has been sent to the moderation team.\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            confirm_embed.add_field(name=\"üìã Reason\", value=self.reason, inline=False)\n            confirm_embed.add_field(name=\"‚è±Ô∏è Next Steps\",\n                                   value=\"Our moderation team will review this report. Thank you for helping keep our community safe!\",\n                                   inline=False)\n            confirm_embed.set_footer(text=f\"üî• Game Services Report System ‚Ä¢ Report ID: {interaction.message.id}\")\n\n            try:\n                await interaction.edit_original_response(embed=confirm_embed, view=None)\n            except discord.errors.NotFound:\n                await interaction.followup.send(embed=confirm_embed, ephemeral=True)\n            self.stop()\n        except Exception as e:\n            logger.error(f\"Error submitting report: {e}\")\n            try:\n                await interaction.followup.send(\"Report submitted successfully!\", ephemeral=True)\n            except:\n                pass\n\n    @discord.ui.button(label=\"Cancel Report\", style=discord.ButtonStyle.secondary, emoji=\"<:GsWrong:1414561861352816753>  \")\n    async def cancel_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.reporter:\n            try:\n                await interaction.response.send_message(\"Only the reporter can cancel this report.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            await interaction.response.defer()\n\n            self.confirmed = False\n            cancel_embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Report Cancelled\",\n                description=\"Your report has been cancelled and will not be sent to the moderation team.\",\n                color=0x808080\n            )\n            try:\n                await interaction.edit_original_response(embed=cancel_embed, view=None)\n            except discord.errors.NotFound:\n                await interaction.followup.send(embed=cancel_embed, ephemeral=True)\n            self.stop()\n        except Exception as e:\n            logger.error(f\"Error cancelling report: {e}\")\n            try:\n                await interaction.followup.send(\"Report cancelled.\", ephemeral=True)\n            except:\n                pass\n\nclass StaffModerationView(discord.ui.View):\n    def __init__(self, reported_user, reporter, reason):\n        super().__init__(timeout=3600)  # 1 hour timeout\n        self.reported_user = reported_user\n        self.reporter = reporter\n        self.reason = reason\n\n    @discord.ui.button(label=\"Approve Report\", style=discord.ButtonStyle.success, emoji=\"<:GsRight:1414593140156792893>\")\n    async def approve_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.kick_members:\n            try:\n                await interaction.response.send_message(\"You don't have permission to moderate reports.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            # Create moderation action view\n            mod_view = QuickModerationView(self.reported_user, interaction.user, self.reason)\n\n            embed = discord.Embed(\n                title=\"<:GsRight:1414593140156792893>  Report Approved - Choose Action\",\n                description=f\"Report against {self.reported_user.mention} has been approved by {interaction.user.mention}\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üìã Original Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"üë§ Reporter\", value=self.reporter.mention, inline=True)\n            embed.add_field(name=\"üëÆ Reviewing Staff\", value=interaction.user.mention, inline=True)\n            embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            await interaction.response.edit_message(embed=embed, view=mod_view)\n        except Exception as e:\n            logger.error(f\"Error approving report: {e}\")\n            try:\n                await interaction.response.defer()\n                await interaction.followup.send(\"Report approved successfully!\", ephemeral=True)\n            except:\n                pass\n\n    @discord.ui.button(label=\"Deny Report\", style=discord.ButtonStyle.danger, emoji=\"<:GsWrong:1414561861352816753>  \")\n    async def deny_report(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if not interaction.user.guild_permissions.kick_members:\n            try:\n                await interaction.response.send_message(\"You don't have permission to moderate reports.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Report Denied\",\n                description=f\"Report against {self.reported_user.mention} has been denied by {interaction.user.mention}\",\n                color=0x808080,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üìã Original Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"üë§ Reporter\", value=self.reporter.mention, inline=True)\n            embed.add_field(name=\"üëÆ Reviewing Staff\", value=interaction.user.mention, inline=True)\n            embed.add_field(name=\"üìù Status\", value=\"No action taken - Report deemed invalid\", inline=False)\n            embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            await interaction.response.edit_message(embed=embed, view=None)\n        except Exception as e:\n            logger.error(f\"Error denying report: {e}\")\n            try:\n                await interaction.response.defer()\n                await interaction.followup.send(\"Report denied successfully!\", ephemeral=True)\n            except:\n                pass\n\nclass QuickModerationView(discord.ui.View):\n    def __init__(self, user, moderator, reason, reporter=None):\n        super().__init__(timeout=1800)  # 30 minutes timeout\n        self.user = user\n        self.moderator = moderator\n        self.reason = f\"Report violation: {reason}\"\n        self.reporter = reporter\n\n    @discord.ui.button(label=\"Warn\", style=discord.ButtonStyle.secondary, emoji=\"‚ö†Ô∏è\")\n    async def quick_warn(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"warn\")\n\n    @discord.ui.button(label=\"Mute 5m\", style=discord.ButtonStyle.primary, emoji=\"üîá\")\n    async def quick_mute_5m(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"mute\", \"5m\")\n\n    @discord.ui.button(label=\"Mute 10m\", style=discord.ButtonStyle.primary, emoji=\"üîá\")\n    async def quick_mute_10m(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"mute\", \"10m\")\n\n    @discord.ui.button(label=\"Mute 20m\", style=discord.ButtonStyle.primary, emoji=\"üîá\")\n    async def quick_mute_20m(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"mute\", \"20m\")\n\n    @discord.ui.button(label=\"Kick\", style=discord.ButtonStyle.danger, emoji=\"üë¢\")\n    async def quick_kick(self, interaction: discord.Interaction, button: discord.ui.Button):\n        await self.execute_quick_action(interaction, \"kick\")\n\n    async def execute_quick_action(self, interaction, action_type, duration=None):\n        try:\n            if action_type == \"warn\":\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"warn\",\n                    reason=self.reason\n                )\n\n            elif action_type == \"mute\":\n                duration_minutes = parse_duration(duration)\n                if duration_minutes and duration_minutes > 0:\n                    # Discord timeout max is 28 days, ensure we don't exceed it\n                    max_minutes = 28 * 24 * 60  # 28 days in minutes\n                    duration_minutes = min(duration_minutes, max_minutes)\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=duration_minutes)\n                    await self.user.timeout(timeout_until, reason=self.reason)\n                else:\n                    # Default to 10 minutes if parsing fails\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=10)\n                    await self.user.timeout(timeout_until, reason=self.reason)\n                    duration_minutes = 10\n\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"mute\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            elif action_type == \"kick\":\n                await interaction.guild.kick(self.user, reason=self.reason)\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"kick\",\n                    reason=self.reason\n                )\n\n            # Send DM to user\n            dm_success = await self.send_dm_notification(action_type, duration)\n\n            # Create success embed\n            if action_type == \"warn\": title = \"‚ö†Ô∏è Warning Issued\"\n            elif action_type == \"mute\": title = f\"üîá User Muted for {duration}\"\n            elif action_type == \"kick\": title = \"üë¢ User Kicked\"\n\n            embed = discord.Embed(\n                title=f\"{title} Successfully\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üë§ User\", value=f\"{self.user.mention} ({self.user})\", inline=False)\n            embed.add_field(name=\"üëÆ Moderator\", value=f\"{self.moderator.mention}\", inline=True)\n            embed.add_field(name=\"üìã Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"üÜî Action ID\", value=f\"#{action_id}\", inline=True)\n            embed.add_field(name=\"üí¨ DM Status\", value=\"<:GsRight:1414593140156792893>  Sent\" if dm_success else \"<:GsWrong:1414561861352816753>   Failed\", inline=True)\n            embed.add_field(name=\"üìä Database\", value=\"<:GsRight:1414593140156792893>  Logged\", inline=True)\n            if self.reporter:\n                embed.add_field(name=\"üë§ Original Reporter\", value=self.reporter.mention, inline=True)\n            embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            await interaction.edit_original_response(embed=embed, view=None)\n\n        except Exception as e:\n            logger.error(f\"Error executing quick action {action_type}: {e}\")\n            await interaction.response.send_message(f\"Error executing {action_type}: {str(e)}\", ephemeral=True)\n\n    async def send_dm_notification(self, action_type, duration=None):\n        \"\"\"Send DM notification to the user and return success status\"\"\"\n        try:\n            if action_type == \"warn\":\n                title = \"‚ö†Ô∏è You Have Been Warned\"\n                description = \"You have been warned in the server\"\n            elif action_type == \"mute\":\n                title = \"üîá You Have Been Muted\"\n                description = \"You have been muted from the server\"\n            elif action_type == \"kick\":\n                title = \"üë¢ You Have Been Kicked\"\n                description = \"You have been kicked from the server\"\n            else:\n                title = f\"You have been {action_type}\"\n                description = f\"You have been {action_type} from the server\"\n\n            embed = discord.Embed(\n                title=title,\n                description=description,\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üè† Server\", value=f\"{self.moderator.guild.name} (Roblox)\", inline=True)\n            embed.add_field(name=\"üë§ Moderator\", value=f\"{self.moderator} (on study arc)\", inline=True)\n            if duration:\n                embed.add_field(name=\"‚è±Ô∏è Duration\", value=duration, inline=True)\n            embed.add_field(name=\"üìã Reason\", value=self.reason, inline=False)\n            embed.add_field(\n                name=\"üö® Appeal Process\",\n                value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\\nüîó https://discord.gg/ahharETNNR\",\n                inline=False\n            )\n            embed.set_footer(text=\"üî• Game Services Moderation System ‚Ä¢ Today at \" + discord.utils.utcnow().strftime(\"%I:%M %p\"))\n\n            await self.user.send(embed=embed)\n            return True\n        except Exception as e:\n            logger.error(f\"Error sending DM to {self.user}: {e}\")\n            return False\n\n# Confirmation View for moderation actions\nclass ConfirmationView(discord.ui.View):\n    def __init__(self, action_type, user, moderator, reason, duration=None):\n        super().__init__(timeout=300)\n        self.action_type = action_type\n        self.user = user\n        self.moderator = moderator\n        self.reason = reason\n        self.duration = duration\n\n    @discord.ui.button(label=\"Confirm\", style=discord.ButtonStyle.danger, emoji=\"<:GsRight:1414593140156792893> \")\n    async def confirm_action(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.moderator:\n            try:\n                await interaction.response.send_message(\"Only the moderator can confirm this action.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            # Acknowledge the interaction first\n            await interaction.response.defer()\n\n            # Check bot permissions first\n            bot_member = interaction.guild.get_member(interaction.client.user.id)\n            if not bot_member:\n                await interaction.followup.send(\"<:GsWrong:1414561861352816753>   Error: Bot member not found in guild.\", ephemeral=True)\n                return\n\n            # Check if bot can perform the action\n            permission_check = self.check_bot_permissions(bot_member, interaction.guild)\n            if not permission_check[\"success\"]:\n                await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Bot Missing Permissions**\\n{permission_check['error']}\", ephemeral=True)\n                return\n\n            # Check role hierarchy\n            if self.user.top_role >= bot_member.top_role:\n                await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Role Hierarchy Error**\\nI cannot {self.action_type} {self.user.mention} because their role is equal to or higher than mine.\\n\\n**Solution:** Move my role above theirs in Server Settings ‚Üí Roles.\", ephemeral=True)\n                return\n\n            if self.action_type == \"warn\":\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"warn\",\n                    reason=self.reason\n                )\n\n            elif self.action_type == \"mute\":\n                duration_minutes = parse_duration(self.duration)\n                if duration_minutes and duration_minutes > 0:\n                    # Discord timeout max is 28 days, ensure we don't exceed it\n                    max_minutes = 28 * 24 * 60  # 28 days in minutes\n                    duration_minutes = min(duration_minutes, max_minutes)\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=duration_minutes)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n‚Ä¢ Bot missing `Moderate Members` permission\\n‚Ä¢ Target user has higher role than bot\\n‚Ä¢ Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                else:\n                    # Default to 10 minutes if parsing fails\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=10)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n‚Ä¢ Bot missing `Moderate Members` permission\\n‚Ä¢ Target user has higher role than bot\\n‚Ä¢ Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                    duration_minutes = 10\n\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"mute\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            elif self.action_type == \"kick\":\n                try:\n                    await interaction.guild.kick(self.user, reason=self.reason)\n                except discord.Forbidden as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot kick {self.user.mention}\\n\\n**Possible causes:**\\n‚Ä¢ Bot missing `Kick Members` permission\\n‚Ä¢ Target user has higher role than bot\\n‚Ä¢ Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                    return\n                except Exception as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Kick Failed**: {str(e)}\", ephemeral=True)\n                    return\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"kick\",\n                    reason=self.reason\n                )\n\n            elif self.action_type == \"ban\":\n                duration_minutes = None\n                if self.duration and self.duration != \"permanent\":\n                    duration_minutes = parse_duration(self.duration)\n\n                try:\n                    await interaction.guild.ban(self.user, reason=self.reason)\n                except discord.Forbidden as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot ban {self.user.mention}\\n\\n**Possible causes:**\\n‚Ä¢ Bot missing `Ban Members` permission\\n‚Ä¢ Target user has higher role than bot\\n‚Ä¢ Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                    return\n                except Exception as e:\n                    await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Ban Failed**: {str(e)}\", ephemeral=True)\n                    return\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"ban\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            elif self.action_type == \"mutewarn\":\n                # First apply the warning\n                warn_action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"warn\",\n                    reason=self.reason\n                )\n\n                # Then apply the mute\n                duration_minutes = parse_duration(self.duration)\n                if duration_minutes and duration_minutes > 0:\n                    # Discord timeout max is 28 days, ensure we don't exceed it\n                    max_minutes = 28 * 24 * 60  # 28 days in minutes\n                    duration_minutes = min(duration_minutes, max_minutes)\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=duration_minutes)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n‚Ä¢ Bot missing `Moderate Members` permission\\n‚Ä¢ Target user has higher role than bot\\n‚Ä¢ Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                else:\n                    # Default to 10 minutes if parsing fails\n                    timeout_until = discord.utils.utcnow() + timedelta(minutes=10)\n                    try:\n                        await self.user.timeout(timeout_until, reason=self.reason)\n                    except discord.Forbidden as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Permission Error**: Cannot mute {self.user.mention}\\n\\n**Possible causes:**\\n‚Ä¢ Bot missing `Moderate Members` permission\\n‚Ä¢ Target user has higher role than bot\\n‚Ä¢ Target user is server owner\\n\\n**Error details:** {str(e)}\", ephemeral=True)\n                        return\n                    except Exception as e:\n                        await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Mute Failed**: {str(e)}\", ephemeral=True)\n                        return\n                    duration_minutes = 10\n\n                action_id = mod_db.add_moderation_action(\n                    user_id=self.user.id,\n                    moderator_id=self.moderator.id,\n                    server_id=interaction.guild.id,\n                    action_type=\"mute\",\n                    reason=self.reason,\n                    duration_minutes=duration_minutes\n                )\n\n            # Send DM to user\n            dm_success = await self.send_dm_notification()\n\n            # Create success embed\n            action_titles = {\n                \"warn\": \"‚ö†Ô∏è Warning Issued\",\n                \"mute\": f\"üîá User Muted for {self.duration}\",\n                \"kick\": \"üë¢ User Kicked\",\n                \"ban\": f\"üî® User Banned ({self.duration})\",\n                \"mutewarn\": f\"‚ö†Ô∏èüîá User Warned + Muted for {self.duration}\"\n            }\n\n            embed = discord.Embed(\n                title=f\"{action_titles[self.action_type]} Successfully\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üë§ User\", value=f\"{self.user.mention} ({self.user})\", inline=False)\n            embed.add_field(name=\"üëÆ Moderator\", value=f\"{self.moderator.mention}\", inline=True)\n            embed.add_field(name=\"üè† Server\", value=f\"{interaction.guild.name}\", inline=True)\n            embed.add_field(name=\"üìã Reason\", value=self.reason, inline=False)\n            embed.add_field(name=\"üÜî Action ID\", value=f\"#{action_id}\", inline=True)\n            embed.add_field(name=\"üí¨ DM Status\", value=\"<:GsRight:1414593140156792893>  Sent\" if dm_success else \"<:GsWrong:1414561861352816753>   Failed\", inline=True)\n            embed.add_field(name=\"üìä Database\", value=\"<:GsRight:1414593140156792893>  Logged\", inline=True)\n\n            if self.duration and self.action_type in [\"mute\", \"ban\", \"mutewarn\"]:\n                embed.add_field(name=\"‚è±Ô∏è Duration\", value=self.duration, inline=True)\n\n            embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            try:\n                await interaction.edit_original_response(embed=embed, view=None)\n            except discord.errors.NotFound:\n                # If edit fails, try to send a new message\n                await interaction.followup.send(embed=embed, ephemeral=True)\n\n        except Exception as e:\n            logger.error(f\"Error executing {self.action_type}: {e}\")\n            try:\n                await interaction.followup.send(f\"<:GsWrong:1414561861352816753>   **Unexpected Error**\\nFailed to execute {self.action_type}: {str(e)}\", ephemeral=True)\n            except:\n                pass\n\n    def check_bot_permissions(self, bot_member, guild):\n        \"\"\"Check if bot has required permissions for the action\"\"\"\n        required_perms = {\n            \"warn\": [\"send_messages\"],\n            \"mute\": [\"moderate_members\"],\n            \"kick\": [\"kick_members\"],\n            \"ban\": [\"ban_members\"],\n            \"mutewarn\": [\"moderate_members\"]\n        }\n\n        permissions_needed = required_perms.get(self.action_type, [])\n        missing_perms = []\n\n        for perm in permissions_needed:\n            if not getattr(bot_member.guild_permissions, perm, False):\n                missing_perms.append(perm.replace('_', ' ').title())\n\n        if missing_perms:\n            perm_list = ', '.join(missing_perms)\n            return {\n                \"success\": False,\n                \"error\": f\"I'm missing these permissions: **{perm_list}**\\n\\n**How to fix:**\\n1. Go to Server Settings ‚Üí Roles\\n2. Find my role and edit permissions\\n3. Enable the missing permissions above\"\n            }\n\n        return {\"success\": True, \"error\": None}\n\n    @discord.ui.button(label=\"Cancel\", style=discord.ButtonStyle.secondary, emoji=\"<:GsWrong:1414561861352816753>  \")\n    async def cancel_action(self, interaction: discord.Interaction, button: discord.ui.Button):\n        if interaction.user != self.moderator:\n            try:\n                await interaction.response.send_message(\"Only the moderator can cancel this action.\", ephemeral=True)\n            except:\n                pass\n            return\n\n        try:\n            await interaction.response.defer()\n\n            embed = discord.Embed(\n                title=\"<:GsWrong:1414561861352816753>   Action Cancelled\",\n                description=f\"The {self.action_type} action has been cancelled.\",\n                color=0x808080\n            )\n            embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            try:\n                await interaction.edit_original_response(embed=embed, view=None)\n            except discord.errors.NotFound:\n                await interaction.followup.send(embed=embed, ephemeral=True)\n        except Exception as e:\n            logger.error(f\"Error cancelling action: {e}\")\n            try:\n                await interaction.followup.send(\"<:GsWrong:1414561861352816753>   Error occurred while cancelling, but action was not executed.\", ephemeral=True)\n            except:\n                pass\n\n    async def send_dm_notification(self):\n        \"\"\"Send DM notification to the user and return success status\"\"\"\n        try:\n            action_titles = {\n                \"warn\": \"‚ö†Ô∏è You Have Been Warned\",\n                \"mute\": \"üîá You Have Been Muted\",\n                \"kick\": \"üë¢ You Have Been Kicked\",\n                \"ban\": \"üî® You Have Been Banned\",\n                \"mutewarn\": \"‚ö†Ô∏èüîá You Have Been Warned + Muted\"\n            }\n\n            action_descriptions = {\n                \"warn\": \"You have been warned in the server\",\n                \"mute\": \"You have been muted from the server\",\n                \"kick\": \"You have been kicked from the server\",\n                \"ban\": \"You have been banned from the server\",\n                \"mutewarn\": \"You have been warned and muted from the server\"\n            }\n\n            embed = discord.Embed(\n                title=action_titles[self.action_type],\n                description=action_descriptions[self.action_type],\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            embed.add_field(name=\"üè† Server\", value=f\"{self.moderator.guild.name}\", inline=True)\n            embed.add_field(name=\"üë§ Moderator\", value=f\"{self.moderator}\", inline=True)\n\n            if self.duration and self.action_type in [\"mute\", \"ban\", \"mutewarn\"]:\n                embed.add_field(name=\"‚è±Ô∏è Duration\", value=self.duration, inline=True)\n\n            embed.add_field(name=\"üìã Reason\", value=self.reason, inline=False)\n            embed.add_field(\n                name=\"üö® Appeal Process\",\n                value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\\nüîó https://discord.gg/ahharETNNR\",\n                inline=False\n            )\n            embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            await self.user.send(embed=embed)\n            return True\n        except Exception as e:\n            logger.error(f\"Error sending DM to {self.user}: {e}\")\n            return False\n\n# Utility functions\ndef parse_duration(duration_str):\n    \"\"\"Parse duration string like '1h', '30m', '2d' into minutes\"\"\"\n    if not duration_str:\n        return 10  # Default 10 minutes\n\n    duration_str = duration_str.lower().strip()\n    if duration_str == \"permanent\":\n        return None\n\n    # Extract number and unit\n    match = re.match(r'(\\d+)([mhd])', duration_str)\n    if not match:\n        return 10  # Default 10 minutes\n\n    number, unit = match.groups()\n    number = int(number)\n\n    # Ensure positive number\n    if number <= 0:\n        return 10\n\n    if unit == 'm':\n        return number\n    elif unit == 'h':\n        return number * 60\n    elif unit == 'd':\n        return number * 24 * 60\n\n    return 10\n\ndef format_duration(minutes):\n    \"\"\"Format minutes into readable duration\"\"\"\n    if not minutes:\n        return \"Permanent\"\n\n    if minutes < 60:\n        return f\"{minutes} minute{'s' if minutes != 1 else ''}\"\n    elif minutes < 1440:  # Less than a day\n        hours = minutes // 60\n        remaining_minutes = minutes % 60\n        if remaining_minutes:\n            return f\"{hours} hour{'s' if hours != 1 else ''} {remaining_minutes} minute{'s' if remaining_minutes != 1 else ''}\"\n        else:\n            return f\"{hours} hour{'s' if hours != 1 else ''}\"\n    else:  # Days\n        days = minutes // 1440\n        remaining_hours = (minutes % 1440) // 60\n        if remaining_hours:\n            return f\"{days} day{'s' if days != 1 else ''} {remaining_hours} hour{'s' if remaining_hours != 1 else ''}\"\n        else:\n            return f\"{days} day{'s' if days != 1 else ''}\"\n\n# Moderation commands\n@bot.command(name=\"warn\", aliases=[\"w\"])\nasync def warn_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Warn a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"You don't have permission to warn users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot warn users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"‚ö†Ô∏è Confirm Warning\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"üî• Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"warn\", user, ctx.author, reason)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"mute\", aliases=[\"timeout\"])\nasync def mute_user(ctx, user: discord.Member, duration=\"1h\", *, reason=\"No reason provided\"):\n    \"\"\"Mute a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.moderate_members:\n        await ctx.send(\"You don't have permission to mute users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot mute users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"üîá Confirm Mute\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Duration\", value=duration, inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"üî• Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"mute\", user, ctx.author, reason, duration)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"ban\", aliases=[\"b\"])\nasync def ban_user(ctx, user: discord.Member, duration=\"permanent\", *, reason=\"No reason provided\"):\n    \"\"\"Ban a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.ban_members:\n        await ctx.send(\"You don't have permission to ban users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot ban users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"üî® Confirm Ban\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Duration\", value=duration, inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"üî• Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"ban\", user, ctx.author, reason, duration)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"kick\", aliases=[\"k\"])\nasync def kick_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Kick a user with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"You don't have permission to kick users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot kick users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"üë¢ Confirm Kick\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.set_footer(text=\"üî• Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"kick\", user, ctx.author, reason)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"mutewarn\", aliases=[\"mw\"])\nasync def mutewarn_user(ctx, user: discord.Member, duration=\"1h\", *, reason=\"No reason provided\"):\n    \"\"\"Warn and mute a user simultaneously with 2-step confirmation\"\"\"\n    if not ctx.author.guild_permissions.moderate_members:\n        await ctx.send(\"You don't have permission to mute and warn users.\")\n        return\n\n    if user.top_role >= ctx.author.top_role and ctx.author != ctx.guild.owner:\n        await ctx.send(\"You cannot warn/mute users with equal or higher roles.\")\n        return\n\n    # Create confirmation embed\n    embed = discord.Embed(\n        title=\"‚ö†Ô∏èüîá Confirm Warn + Mute\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"User\", value=f\"{user.mention} ({user})\", inline=False)\n    embed.add_field(name=\"Moderator\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"Duration\", value=duration, inline=True)\n    embed.add_field(name=\"Reason\", value=reason, inline=False)\n    embed.add_field(name=\"Actions\", value=\"Will apply **both** warning and mute\", inline=False)\n    embed.set_footer(text=\"üî• Click Confirm to proceed or Cancel to abort\")\n\n    view = ConfirmationView(\"mutewarn\", user, ctx.author, reason, duration)\n    await ctx.send(embed=embed, view=view)\n\n@bot.command(name=\"unmute\", aliases=[\"um\"])\nasync def unmute_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Unmute a user\"\"\"\n    if not ctx.author.guild_permissions.moderate_members:\n        await ctx.send(\"You don't have permission to unmute users.\")\n        return\n\n    try:\n        if not user.is_timed_out():\n            await ctx.send(f\"{user.mention} is not currently muted.\")\n            return\n\n        # Remove timeout\n        await user.timeout(None, reason=f\"Unmuted by {ctx.author}: {reason}\")\n\n        # Create success embed\n        embed = discord.Embed(\n            title=\"üîä User Unmuted\",\n            color=0xFFC916,\n            timestamp=discord.utils.utcnow()\n        )\n        embed.add_field(name=\"üè† Server\", value=f\"{ctx.guild.name}\", inline=True)\n        embed.add_field(name=\"üë§ Moderator\", value=f\"{ctx.author} (on study arc)\", inline=True)\n        embed.add_field(name=\"üìã Reason\", value=reason, inline=False)\n        embed.add_field(\n            name=\"üö® Appeal Process\",\n            value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\",\n            inline=False\n        )\n        embed.set_footer(text=\"üî• Game Services Moderation System ‚Ä¢ Today at \" + discord.utils.utcnow().strftime(\"%I:%M %p\"))\n\n        await ctx.send(embed=embed)\n\n        # DM the user\n        try:\n            dm_embed = discord.Embed(\n                title=\"üîä You Have Been Unmuted\",\n                description=\"You have been unmuted from the server\",\n                color=0xFFC916,\n                timestamp=discord.utils.utcnow()\n            )\n            dm_embed.add_field(name=\"üè† Server\", value=f\"{ctx.guild.name}\", inline=True)\n            dm_embed.add_field(name=\"üë§ Moderator\", value=f\"{ctx.author} (on study arc)\", inline=True)\n            dm_embed.add_field(name=\"üìã Reason\", value=reason, inline=False)\n            dm_embed.add_field(\n                name=\"üö® Appeal Process\",\n                value=\"If you believe this action was taken in error, you may appeal this decision in our appeals server:\\nüîó https://discord.gg/ahharETNNR\",\n                inline=False\n            )\n            dm_embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n            await user.send(embed=dm_embed)\n        except discord.Forbidden:\n            logger.info(f\"Could not DM {user} - DMs disabled\")\n\n    except Exception as e:\n        logger.error(f\"Error unmuting user: {e}\")\n        await ctx.send(f\"Error unmuting {user.mention}: {str(e)}\")\n\n@bot.command(name=\"removewarn\", aliases=[\"unwarn\", \"rw\"])\nasync def remove_warn(ctx, action_id_str: str, *, removal_reason=\"No reason provided\"):\n    \"\"\"Remove a moderation action\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"You don't have permission to remove moderation actions.\")\n        return\n\n    # Try to convert action_id_str to integer\n    try:\n        action_id = int(action_id_str)\n    except ValueError:\n        embed = discord.Embed(\n            title=\"<:GsWrong:1414561861352816753>   Invalid Action ID\",\n            description=\"Please provide a valid action ID number.\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"üí° Usage\", value=\"`gs.removewarn <action_id> [reason]`\", inline=False)\n        embed.add_field(name=\"üìã Example\", value=\"`gs.removewarn 123 mistake by staff`\", inline=False)\n        embed.add_field(name=\"üîç How to find Action ID\", value=\"Use `gs.warns @user` to see action IDs\", inline=False)\n        embed.set_footer(text=\"üî• Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    # Remove from database\n    removed_action = mod_db.remove_moderation_action(action_id, ctx.author.id, removal_reason)\n\n    if not removed_action:\n        await ctx.send(\"No active moderation action found with that ID.\")\n        return\n\n    embed = discord.Embed(\n        title=\"<:GsRight:1414593140156792893>  Moderation Action Removed Successfully\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üÜî Action ID\", value=f\"#{action_id}\", inline=True)\n    embed.add_field(name=\"üè∑Ô∏è Original Action\", value=removed_action['action_type'].title(), inline=True)\n    embed.add_field(name=\"üë§ Target User\", value=f\"<@{removed_action['user_id']}>\", inline=True)\n    embed.add_field(name=\"üëÆ Original Moderator\", value=f\"<@{removed_action['moderator_id']}>\", inline=True)\n    embed.add_field(name=\"üóëÔ∏è Removed By\", value=f\"{ctx.author.mention}\", inline=True)\n    embed.add_field(name=\"üìä Database\", value=\"<:GsRight:1414593140156792893>  Updated\", inline=True)\n    embed.add_field(name=\"üìù Removal Reason\", value=removal_reason, inline=False)\n    embed.add_field(name=\"üìã Original Reason\", value=removed_action['reason'], inline=False)\n    embed.set_footer(text=\"üî• Game Services Moderation System\")\n\n    await ctx.send(embed=embed)\n\n    # If it was a mute, remove the timeout\n    if removed_action['action_type'] == 'mute':\n        try:\n            user = ctx.guild.get_member(removed_action['user_id'])\n            if user and user.is_timed_out():\n                await user.timeout(None, reason=f\"Mute removed by {ctx.author}\")\n        except Exception as e:\n            logger.error(f\"Error removing timeout: {e}\")\n\n@bot.command(name=\"warns\", aliases=[\"warnlist\"])\nasync def user_warns(ctx, user: discord.Member = None):\n    \"\"\"Show warning history for a user in this server\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    warn_records = [r for r in records if r['action_type'] == 'warn' and r['is_active']]\n\n    if not warn_records:\n        embed = discord.Embed(\n            title=\"üìã No Warning History\",\n            description=f\"{user.mention} has no warning history in **{ctx.guild.name}**.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"‚ö†Ô∏è Warning History for {user.display_name}\",\n        description=f\"Server: **{ctx.guild.name}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_warns = []\n    active_warns = [r for r in warn_records if r['is_active']]\n\n    embed.add_field(name=\"üìä Summary\", value=f\"**{len(active_warns)}** active warnings\", inline=True)\n    embed.add_field(name=\"üìà Total\", value=f\"**{len(warn_records)}** total warnings\", inline=True)\n    embed.add_field(name=\"üè† Server\", value=f\"**{ctx.guild.name}**\", inline=True)\n\n    for record in warn_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_warns.append(\n            f\"**#{record['id']}** Warning - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_warns:\n        embed.add_field(name=\"üìù Recent Warnings\",\n                       value=\"\\n\".join(recent_warns),\n                       inline=False)\n\n    embed.set_footer(text=\"üî• Game Services Moderation System ‚Ä¢ Server-Specific Data\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"mutes\", aliases=[\"mutelist\"])\nasync def user_mutes(ctx, user: discord.Member = None):\n    \"\"\"Show mute history for a user\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    mute_records = [r for r in records if r['action_type'] == 'mute']\n\n    if not mute_records:\n        embed = discord.Embed(\n            title=\"üìã No Mute History\",\n            description=f\"{user.mention} has no mute history.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"üîá Mute History for {user.display_name}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_mutes = []\n    for record in mute_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_mutes.append(\n            f\"**#{record['id']}** Mute - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_mutes:\n        embed.add_field(name=\"üìù Recent Mutes\",\n                       value=\"\\n\".join(recent_mutes),\n                       inline=False)\n\n    embed.set_footer(text=\"üî• Game Services Moderation System\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"bans\", aliases=[\"ba\"])\nasync def user_bans(ctx, user: discord.Member = None):\n    \"\"\"Show ban history for a user\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    ban_records = [r for r in records if r['action_type'] == 'ban']\n\n    if not ban_records:\n        embed = discord.Embed(\n            title=\"üìã No Ban History\",\n            description=f\"{user.mention} has no ban history.\",\n            color=0xFFC916\n        )\n        embed.set_footer(text=\"üî• Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"üî® Ban History for {user.display_name}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_bans = []\n    for record in ban_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_bans.append(\n            f\"**#{record['id']}** Ban - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_bans:\n        embed.add_field(name=\"üìù Recent Bans\",\n                       value=\"\\n\".join(recent_bans),\n                       inline=False)\n\n    embed.set_footer(text=\"üî• Moderation System\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"gs.kicks\", aliases=[\"kicks\"])\nasync def user_kicks(ctx, user: discord.Member = None):\n    \"\"\"Show kick history for a user\"\"\"\n    if not user:\n        user = ctx.author\n\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n    kick_records = [r for r in records if r['action_type'] == 'kick']\n\n    if not kick_records:\n        embed = discord.Embed(\n            title=\"üìã No Kick History\",\n            description=f\"{user.mention} has no kick history.\",\n            color=0x00FF00\n        )\n        embed.set_footer(text=\"üî• Game Services Moderation System\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"üë¢ Kick History for {user.display_name}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    recent_kicks = []\n    for record in kick_records[:10]:\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:50] + \"...\" if len(record['reason']) > 50 else record['reason']\n\n        recent_kicks.append(\n            f\"**#{record['id']}** Kick - {created_at}\\n\"\n            f\"By: <@{moderator_id}>\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_kicks:\n        embed.add_field(name=\"üìù Recent Kicks\",\n                       value=\"\\n\".join(recent_kicks),\n                       inline=False)\n\n    embed.set_footer(text=\"üî• Game Services Moderation System\")\n    await ctx.send(embed=embed)\n\n# Roblox Server Commands\n@bot.command(name=\"gagps\", aliases=[\"gs.gagps\"])\nasync def grow_a_garden_ps(ctx):\n    \"\"\"üå± Get Grow-A-Garden Private Server link\"\"\"\n    embed = discord.Embed(\n        title=\"üå± Grow-A-Garden Private Server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"Private Server Link:\",\n        value=\"https://www.roblox.com/share?code=46f8e0e94513bc41a1bf7314925f5420&type=Server\",\n        inline=False\n    )\n    embed.set_footer(text=\"üî• Game Services\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"sabps\", aliases=[\"gs.sabps\"])\nasync def steal_a_brainrot_ps(ctx):\n    \"\"\"üß† Get Steal-A-Brainrot Private Server link\"\"\"\n    embed = discord.Embed(\n        title=\"üß† Steal-A-Brainrot Private Server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"Private Server Link:\",\n        value=\"https://www.roblox.com/share?code=75f26e5ffe139f42807227d149126668&type=Server\",\n        inline=False\n    )\n    embed.set_footer(text=\"üî• Game Services\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"tutorial\", aliases=[\"gs.tutorial\"])\nasync def invite_tutorial(ctx):\n    \"\"\"üìö Learn how to create your own invite link\"\"\"\n    embed = discord.Embed(\n        title=\"üìö Tutorial\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"How to generate your own invite link:\",\n        value=\"https://youtu.be/UkyljZT6lFg?si=G-C6biADCokHOM70\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"üìù What you'll learn:\",\n        value=\"‚Ä¢ How to create non-vanity server invite links\\n‚Ä¢ Step-by-step guide\\n‚Ä¢ Easy to follow tutorial\",\n        inline=False\n    )\n    embed.set_footer(text=\"üî• Game Services\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"secretsabps\", aliases=[\"gs.secretsabps\"])\nasync def mal_sabps(ctx):\n    \"\"\"üß† Get Secret Steal-A-Brainrot Private Server link\"\"\"\n    embed = discord.Embed(\n        title=\"üß† Secret Steal-A-Brainrot Private Server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"Private Server Link:\",\n        value=\"https://www.roblox.com/share?code=9aa554d3133c214293a36fcf6b027ce3&type=Server\",\n        inline=False\n    )\n    embed.set_footer(text=\"üî• Game Services\")\n    await ctx.send(embed=embed)\n@bot.command(name=\"serverlinks\", aliases=[\"gs.serverlinks\"])\nasync def server_links(ctx):\n    \"\"\"üîó Get all server invite links (Admin only)\"\"\"\n    # Check if user has administrator permission\n    if not ctx.author.guild_permissions.administrator:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You need administrator permissions to use this command.\")\n        return\n\n    server_count = len(bot.guilds)\n\n    embed = discord.Embed(\n        title=\"üîó Server Information & Links\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"üìä Bot Statistics\",\n        value=f\"**{server_count}** servers connected\",\n        inline=False\n    )\n\n    server_info = \"\"\n    for guild in bot.guilds[:10]:  # Limit to first 10 servers\n        member_count = guild.member_count or 0\n        try:\n            # Try to create an invite\n            text_channels = [channel for channel in guild.text_channels if channel.permissions_for(guild.me).create_instant_invite]\n            if text_channels:\n                invite = await text_channels[0].create_invite(max_age=0, max_uses=0)\n                server_info += f\"**{guild.name}** ({member_count} members)\\n{invite.url}\\n\\n\"\n            else:\n                server_info += f\"**{guild.name}** ({member_count} members)\\n*No invite permission*\\n\\n\"\n        except:\n            server_info += f\"**{guild.name}** ({member_count} members)\\n*Cannot create invite*\\n\\n\"\n\n    if server_info:\n        embed.add_field(\n            name=\"üè∞ Server Invites\",\n            value=server_info[:1020] + (\"...\" if len(server_info) > 1020 else \"\"),\n            inline=False\n        )\n\n    if server_count > 10:\n        embed.add_field(\n            name=\"‚ÑπÔ∏è Note\",\n            value=f\"Showing first 10 of {server_count} servers\",\n            inline=False\n        )\n\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Admin Command\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"chatguide\", aliases=[\"gs.chatguide\", \"guide\"])\nasync def send_chat_guide(ctx):\n    \"\"\"üìã Manually send the chat guide message (only works in designated channel)\"\"\"\n    channel_id = ctx.channel.id\n\n    # Only allow in the specific channel\n    if channel_id != CHAT_GUIDE_CHANNEL_ID:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   This command only works in <#1370086532433838102>.\")\n        return\n\n    current_time = discord.utils.utcnow()\n\n    # Check cooldown to prevent spam (1 minute cooldown for manual command)\n    if channel_id in chat_guide_cooldown and \\\n       (current_time - chat_guide_cooldown[channel_id]).total_seconds() < 60:\n        remaining = 60 - (current_time - chat_guide_cooldown[channel_id]).total_seconds()\n        await ctx.send(f\"‚è∞ Chat guide message is on cooldown. Try again in {int(remaining)} seconds.\")\n        return\n\n    try:\n        await ctx.send(CHAT_GUIDE_MESSAGE)\n        chat_guide_cooldown[channel_id] = current_time\n        logger.info(f\"Manually sent chat guide message in {ctx.channel.name} by {ctx.author}\")\n    except Exception as e:\n        logger.error(f\"Error manually sending chat guide message: {e}\")\n        await ctx.send(\"<:GsWrong:1414561861352816753>   Failed to send chat guide message.\")\n\n@bot.command(name=\"messagecounter\", aliases=[\"gs.msgcount\", \"msgcount\"])\nasync def message_counter_status(ctx):\n    \"\"\"üìä Check message counter status for this channel (Admin only)\"\"\"\n    if not ctx.author.guild_permissions.manage_messages:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You need manage messages permission to use this command.\")\n        return\n\n    channel_id = ctx.channel.id\n    message_count = channel_message_counts.get(channel_id, 0)\n    remaining = CHAT_GUIDE_INTERVAL - (message_count % CHAT_GUIDE_INTERVAL)\n\n    embed = discord.Embed(\n        title=\"üìä Chat Guide Message Counter\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(\n        name=\"üí¨ Messages in Channel\",\n        value=f\"**{message_count}** total messages\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"‚è∞ Next Guide Message\",\n        value=f\"In **{remaining}** messages\",\n        inline=False\n    )\n    embed.add_field(\n        name=\"üîÑ Interval\",\n        value=f\"Every **{CHAT_GUIDE_INTERVAL}** messages\",\n        inline=False\n    )\n\n    if channel_id in chat_guide_cooldown:\n        last_sent = chat_guide_cooldown[channel_id]\n        time_since = discord.utils.utcnow() - last_sent\n        embed.add_field(\n            name=\"üìÖ Last Sent\",\n            value=f\"{int(time_since.total_seconds() / 60)} minutes ago\",\n            inline=False\n        )\n\n    embed.set_footer(text=\"üî• Game Services ‚Ä¢ Message Counter System\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"gs.history\", aliases=[\"history\"])\nasync def user_full_history(ctx, user: discord.Member = None):\n    \"\"\"Show complete moderation history for a user in this server\"\"\"\n    if not user:\n        user = ctx.author\n\n    # Get user's record for this server only\n    records = mod_db.get_user_record(user.id, ctx.guild.id)\n\n    if not records:\n        embed = discord.Embed(\n            title=\"üìã Clean Record\",\n            description=f\"{user.mention} has no moderation history in **{ctx.guild.name}**.\",\n            color=0xFFC916\n        )\n        embed.add_field(name=\"üè† Server\", value=f\"**{ctx.guild.name}**\", inline=True)\n        embed.set_footer(text=\"üî• Game Services Moderation System ‚Ä¢ Server-Specific Data\")\n        await ctx.send(embed=embed)\n        return\n\n    embed = discord.Embed(\n        title=f\"üìã Complete Moderation History for {user.display_name}\",\n        description=f\"Server: **{ctx.guild.name}**\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.set_thumbnail(url=user.display_avatar.url)\n\n    # Count actions (active and inactive)\n    warns = len([r for r in records if r['action_type'] == 'warn'])\n    mutes = len([r for r in records if r['action_type'] == 'mute'])\n    bans = len([r for r in records if r['action_type'] == 'ban'])\n    kicks = len([r for r in records if r['action_type'] == 'kick'])\n\n    # Count active actions\n    active_warns = len([r for r in records if r['action_type'] == 'warn' and r['is_active']])\n    active_mutes = len([r for r in records if r['action_type'] == 'mute' and r['is_active']])\n    active_bans = len([r for r in records if r['action_type'] == 'ban' and r['is_active']])\n\n    embed.add_field(name=\"üìä Total Actions\",\n                   value=f\"Warnings: {warns}\\nMutes: {mutes}\\nBans: {bans}\\nKicks: {kicks}\",\n                   inline=True)\n\n    embed.add_field(name=\"‚ö° Active Actions\",\n                   value=f\"Warnings: {active_warns}\\nMutes: {active_mutes}\\nBans: {active_bans}\\nKicks: 0\",\n                   inline=True)\n\n    embed.add_field(name=\"üè† Server\",\n                   value=f\"**{ctx.guild.name}**\\nID: {ctx.guild.id}\",\n                   inline=True)\n\n    # Show recent actions (last 8)\n    recent_actions = []\n    for record in records[:8]:\n        action_type = record['action_type'].title()\n        created_at = record['created_at'].strftime('%m/%d/%Y %H:%M')\n        moderator_id = record['moderator_id']\n        reason = record['reason'][:45] + \"...\" if len(record['reason']) > 45 else record['reason']\n        status = \"<:GsWrong:1414561861352816753>   Removed\" if not record['is_active'] else \"<:GsRight:1414593140156792893>  Active\"\n\n        recent_actions.append(\n            f\"**#{record['id']}** {action_type} - {created_at}\\n\"\n            f\"By: <@{moderator_id}> | {status}\\n\"\n            f\"Reason: {reason}\\n\"\n        )\n\n    if recent_actions:\n        embed.add_field(name=\"üìù Recent Actions\",\n                       value=\"\\n\".join(recent_actions),\n                       inline=False)\n\n    embed.set_footer(text=\"üî• Game Services Moderation System ‚Ä¢ Server-Specific Data\")\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"gs.report\", aliases=[\"report\"])\nasync def report_user(ctx, user: discord.Member, *, reason=\"No reason provided\"):\n    \"\"\"Report a user to moderators\"\"\"\n    # Prevent self-reporting\n    if user == ctx.author:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot report yourself.\")\n        return\n\n    # Prevent reporting bots\n    if user.bot:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot report bots.\")\n        return\n\n    # Get the report channel\n    report_channel = bot.get_channel(REPORT_CHANNEL_ID)\n    if not report_channel:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   Report channel not found. Please contact an administrator.\")\n        return\n\n    # Create report embed\n    report_embed = discord.Embed(\n        title=\"üö® User Report Alert\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    report_embed.add_field(name=\"üéØ Reported User\", value=f\"{user.mention} ({user})\\nID: {user.id}\", inline=False)\n    report_embed.add_field(name=\"üë§ Reporter\", value=f\"{ctx.author.mention} ({ctx.author})\\nID: {ctx.author.id}\", inline=False)\n    report_embed.add_field(name=\"üìç Channel\", value=f\"{ctx.channel.mention} ({ctx.channel.name})\", inline=True)\n    report_embed.add_field(name=\"üè† Server\", value=f\"{ctx.guild.name}\", inline=True)\n    report_embed.add_field(name=\"üìã Reason\", value=reason, inline=False)\n\n    # Add user info\n    now = discord.utils.utcnow()\n    account_age = (now - user.created_at).days\n    server_join = (now - user.joined_at).days if user.joined_at else \"Unknown\"\n    report_embed.add_field(name=\"üìä User Info\",\n                          value=f\"Account Age: {account_age} days\\nServer Member: {server_join} days\",\n                          inline=True)\n\n    report_embed.set_thumbnail(url=user.display_avatar.url)\n    report_embed.set_footer(text=f\"üî• Game Services Report System ‚Ä¢ Report ID: {ctx.message.id}\")\n\n    # Create confirmation embed with warning\n    confirm_embed = discord.Embed(\n        title=\"üö® Confirm Report Submission\",\n        description=f\"You are about to report {user.mention} to the moderation team.\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    confirm_embed.add_field(name=\"üìã Reason\", value=reason, inline=False)\n    confirm_embed.add_field(name=\"‚ö†Ô∏è **WARNING**\",\n                           value=\"**FALSE REPORTS WILL GET YOU MUTED**\\nOnly submit this report if you have a legitimate concern.\",\n                           inline=False)\n    confirm_embed.add_field(name=\"‚ùì Are you sure?\",\n                           value=\"Click Submit Report to send this to staff, or Cancel to dismiss.\",\n                           inline=False)\n    confirm_embed.set_footer(text=\"üî• Game Services Report System\")\n\n    # Create view with confirmation buttons\n    view = ReportConfirmationView(user, ctx.author, reason, report_channel, report_embed)\n    await ctx.send(embed=confirm_embed, view=view)\n\n# Invite tracking commands\n@bot.command(name=\"invites\", aliases=[\"inv\", \"gs.invites\"])\nasync def show_invites(ctx, user: discord.Member = None):\n    \"\"\"Show invite statistics for a user\"\"\"\n    target_user = user or ctx.author\n    user_id = target_user.id\n\n    if user_id not in user_invites:\n        user_invites[user_id] = {'invites': 0, 'fake': 0, 'rejoins': 0, 'bonus': 0}\n\n    data = user_invites[user_id]\n    total = data['invites'] + data['bonus'] - data['fake'] - data['rejoins']\n\n    embed = discord.Embed(\n        title=\"üìä Invite Statistics\",\n        description=f\"Invite data for {target_user.mention}\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n\n    embed.add_field(name=\"<:GsRight:1414593140156792893>  Valid Invites\", value=str(data['invites']), inline=True)\n    embed.add_field(name=\"üö´ Fake Invites\", value=str(data['fake']), inline=True)\n    embed.add_field(name=\"üîÑ Rejoins\", value=str(data['rejoins']), inline=True)\n    embed.add_field(name=\"üéÅ Bonus Invites\", value=str(data['bonus']), inline=True)\n    embed.add_field(name=\"üìà Total Score\", value=str(total), inline=True)\n    embed.add_field(name=\"üë§ User\", value=f\"{target_user} ({target_user.id})\", inline=False)\n\n    embed.set_thumbnail(url=target_user.display_avatar.url)\n    embed.set_footer(text=\"üî• Game Services Invite System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"addinvite\", aliases=[\"addinv\"])\nasync def add_invite(ctx, user: discord.Member, amount: int = 1):\n    \"\"\"Add bonus invites to a user (Moderators only)\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You don't have permission to manage invites.\")\n        return\n\n    if user.id not in user_invites:\n        user_invites[user.id] = {'invites': 0, 'fake': 0, 'rejoins': 0, 'bonus': 0}\n\n    user_invites[user.id]['bonus'] += amount\n\n    embed = discord.Embed(\n        title=\"<:GsRight:1414593140156792893>  Bonus Invites Added\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üë§ User\", value=user.mention, inline=True)\n    embed.add_field(name=\"üéÅ Added\", value=f\"+{amount} bonus invites\", inline=True)\n    embed.add_field(name=\"üëÆ Moderator\", value=ctx.author.mention, inline=True)\n    embed.add_field(name=\"üìä New Bonus Total\", value=str(user_invites[user.id]['bonus']), inline=False)\n    embed.set_footer(text=\"üî• Game Services Invite System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"removeinvite\", aliases=[\"reminv\"])\nasync def remove_invite(ctx, user: discord.Member, amount: int = 1):\n    \"\"\"Remove bonus invites from a user (Moderators only)\"\"\"\n    if not ctx.author.guild_permissions.kick_members:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You don't have permission to manage invites.\")\n        return\n\n    if user.id not in user_invites:\n        user_invites[user.id] = {'invites': 0, 'fake': 0, 'rejoins': 0, 'bonus': 0}\n\n    user_invites[user.id]['bonus'] = max(0, user_invites[user.id]['bonus'] - amount)\n\n    embed = discord.Embed(\n        title=\"‚ûñ Bonus Invites Removed\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n    embed.add_field(name=\"üë§ User\", value=user.mention, inline=True)\n    embed.add_field(name=\"üîª Removed\", value=f\"-{amount} bonus invites\", inline=True)\n    embed.add_field(name=\"üëÆ Moderator\", value=ctx.author.mention, inline=True)\n    embed.add_field(name=\"üìä New Bonus Total\", value=str(user_invites[user.id]['bonus']), inline=False)\n    embed.set_footer(text=\"üî• Game Services Invite System\")\n\n    await ctx.send(embed=embed)\n\n@bot.command(name=\"invtop\", aliases=[\"inviteleaderboard\"])\nasync def invite_leaderboard(ctx):\n    \"\"\"Show top inviters\"\"\"\n    if not user_invites:\n        embed = discord.Embed(\n            title=\"üìä Invite Leaderboard\",\n            description=\"No invite data available yet.\",\n            color=0xFFC916\n        )\n        await ctx.send(embed=embed)\n        return\n\n    # Calculate total scores and sort\n    leaderboard = []\n    for user_id, data in user_invites.items():\n        total = data['invites'] + data['bonus'] - data['fake'] - data['rejoins']\n        leaderboard.append((user_id, total, data))\n\n    leaderboard.sort(key=lambda x: x[1], reverse=True)\n    leaderboard = leaderboard[:10]  # Top 10\n\n    embed = discord.Embed(\n        title=\"üèÜ Invite Leaderboard\",\n        description=\"Top 10 inviters in the server\",\n        color=0xFFC916,\n        timestamp=discord.utils.utcnow()\n    )\n\n    for i, (user_id, total, data) in enumerate(leaderboard, 1):\n        user = bot.get_user(user_id)\n        user_name = user.display_name if user else f\"User {user_id}\"\n\n        medal = \"ü•á\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n\n        embed.add_field(\n            name=f\"{medal} {user_name}\",\n            value=f\"**{total}** total invites\\n<:GsRight:1414593140156792893>  {data['invites']} ‚Ä¢ üö´ {data['fake']} ‚Ä¢ üîÑ {data['rejoins']} ‚Ä¢ üéÅ {data['bonus']}\",\n            inline=False\n        )\n\n    embed.set_footer(text=\"üî• Game Services Invite System\")\n    await ctx.send(embed=embed)\n\n# Message tracking commands\n\n# --- Echo Command (Admins Only) ---\n@bot.command(name=\"echo\")\n@commands.has_permissions(administrator=True)\nasync def echo_command(ctx, *, message: str = None):\n    reference = ctx.message.reference\n    try:\n        await ctx.message.delete()  # delete the command message\n    except discord.Forbidden:\n        pass  # ignore if bot has no perms\n\n    if not message and not reference:\n        error = await ctx.send(\"<:GsWrong:1414561861352816753>   You must provide a message or reply to one.\")\n        await asyncio.sleep(5)\n        await error.delete()\n        return\n\n    # Determine final message to send\n    final_message = message or \"\"\n\n    # Add user info if NOT in excluded server\n    if ctx.guild and ctx.guild.id != 1370086525210984458:\n        final_message = f\"üí¨ {ctx.author} echoed:\\n{final_message}\"\n\n    if reference:\n        replied_message = await ctx.channel.fetch_message(reference.message_id)\n        await replied_message.reply(final_message)\n    else:\n        await ctx.send(final_message)\n# --- AnonymousEcho (Admins Only) ---\n@bot.command(name=\"anonymousecho\")\n@commands.has_permissions(administrator=True)\nasync def echo_command(ctx, *, message: str = None):\n    reference = ctx.message.reference\n    try:\n        await ctx.message.delete()  # delete the command message\n    except discord.Forbidden:\n        pass  # ignore if bot has no perms\n\n    if not message and not reference:\n        error = await ctx.send(\"<:GsWrong:1414561861352816753>   You must provide a message or reply to one.\")\n        await asyncio.sleep(5)\n        await error.delete()\n        return\n\n    # Determine final message to send\n    final_message = message or \"\"\n\n    # Add user info if NOT in excluded server\n    if ctx.guild and ctx.guild.id != 1370086525210984458:\n        final_message = f\"üí¨ Someone Anonymously Echoed:\\n{final_message}\"\n\n    if reference:\n        replied_message = await ctx.channel.fetch_message(reference.message_id)\n        await replied_message.reply(final_message)\n    else:\n        await ctx.send(final_message)\n# --- Fixed Message Command ---\n@bot.command(name=\"arix\")\nasync def arix_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"wowowowow me arix <:CatSmirk:1411643056230498415>\"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n# --- Fixed Message Command ---\n@bot.command(name=\"mal\")\nasync def mal_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"<a:MonkeySpin:1410866007953637428> \"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n# --- Fixed Message Command ---\n@bot.command(name=\"sia\")\nasync def sia_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"hewooo <a:Excited:1390404098616197251>  \"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n# --- Fixed Message Command ---\n@bot.command(name=\"scyther\")\nasync def scyther_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"Hi Guys I Am Scytherino Yaperino <a:MonkeySpin:1410866007953637428>\"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n# --- Auto Ticket Greeting ---\n@bot.event\nasync def on_guild_channel_create(channel):\n    # Only act on text channels\n    if isinstance(channel, discord.TextChannel):\n        if channel.name.lower().startswith(\"ticket\"):\n            try:\n                await channel.send(\"**Hello, please be patient until staff respond to your ticket, meanwhile state why you made it.**\")\n            except Exception as e:\n                print(f\"Error sending ticket greeting: {e}\")\n\n# --- Fake Ban Command (gs.bam) ---\n@bot.command(name=\"bam\", aliases=[\"gs.bam\"])\nasync def bam_command(ctx, member: discord.Member = None):\n    if not member:\n        error = await ctx.send(\"‚ÑπÔ∏è Usage: `gs.bam @user`\")\n        await error.delete(delay=5)\n        return\n\n    embed = discord.Embed(\n        title=\"‚öíÔ∏è Ban Hammer\",\n        description=f\"Banned **{member.display_name}**\",\n        color=0xFFC916\n    )\n    embed.set_footer(text=\"üéÆ Game Services\")\n\n    await ctx.send(embed=embed)\n# --- Clear Command (mods/admins with Manage Messages) ---\n@bot.command(name=\"clear\", aliases=[\"gs.clear\"])\n@commands.has_permissions(manage_messages=True)\nasync def clear(ctx, amount: int = None):\n    # Validate input\n    if amount is None or amount < 1:\n        error = await ctx.send(\"‚ö†Ô∏è Usage: `gs.clear <number>` ‚Äî number must be 1 or higher.\")\n        await error.delete(delay=5)\n        return\n\n    # We'll try to bulk delete `amount` messages *plus* the command message (if still present)\n    limit = amount + 1\n\n    try:\n        # Prevent removing pinned messages\n        deleted = await ctx.channel.purge(limit=limit, check=lambda m: not m.pinned)\n        # Count deleted messages excluding the command message (if it was included)\n        deleted_count = sum(1 for m in deleted if m.id != ctx.message.id)\n        confirm = await ctx.send(f\"<:GsRight:1414593140156792893>  Deleted {deleted_count} messages.\")\n        await confirm.delete(delay=5)\n\n    except discord.Forbidden:\n        # Bot lacks Manage Messages / Read Message History permissions\n        error = await ctx.send(\"<:GsWrong:1414561861352816753>   I don't have permission to delete messages in this channel.\")\n        await error.delete(delay=5)\n\n    except discord.HTTPException as e:\n        # Bulk delete failed (e.g., messages older than 14 days cannot be bulk-deleted)\n        logger.exception(\"Bulk delete failed\", exc_info=e)\n        err = await ctx.send(\"<:GsWrong:1414561861352816753>   Failed to delete messages. Note: Discord won't bulk-delete messages older than 14 days.\")\n        await err.delete(delay=8)\n\n    except Exception as e:\n        logger.exception(\"Unexpected error in clear command\", exc_info=e)\n        err = await ctx.send(\"<:GsWrong:1414561861352816753>   An unexpected error occurred while trying to clear messages.\")\n        await err.delete(delay=8)\n\n# --- Fixed Message Command ---\n@bot.command(name=\"aarav\")\nasync def aarav_command(ctx):\n    # The message you want to send (change this!)\n    fixed_message = \"Brri brri dicus bombicus- I mean hello !\"\n\n    # Send the fixed message\n    await ctx.send(fixed_message)\n\n\n# ---------------- gs.absence command ----------------\nABSENCE_ROLE_ID = 1374481044916408340\n\n@bot.command(name=\"absence\")\n@commands.has_permissions(administrator=True)\nasync def absence(ctx, member: discord.Member, duration: str):\n    \"\"\"\n    Usage: gs.absence @member 10m\n    Only usable by administrators. Cannot target users with equal/higher role or the server owner.\n    \"\"\"\n    # Protect server owner\n    if member == ctx.guild.owner:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot mark the server owner absent.\")\n        return\n\n    # Prevent targeting equal/higher role\n    if member.top_role >= ctx.author.top_role:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You cannot mark this user absent (they have equal or higher role).\")\n        return\n\n    # Parse duration\n    time_units = {\"s\": 1, \"m\": 60, \"h\": 3600, \"d\": 86400}\n    try:\n        unit = duration[-1].lower()\n        amount = int(duration[:-1])\n        seconds = amount * time_units[unit]\n    except Exception:\n        await ctx.send(\"Invalid time format. Use e.g. `10m`, `2h`, `1d`.\")\n        return\n\n    role = ctx.guild.get_role(ABSENCE_ROLE_ID)\n    if not role:\n        await ctx.send(\"Absence role not found!\")\n        return\n\n    try:\n        await member.add_roles(role)\n    except Exception as e:\n        await ctx.send(f\"Failed to add absence role: {e}\")\n        return\n\n    # Plain text start message\n    await ctx.send(f\"üìå {member.mention} is now marked absent for **{duration}**. The role will be removed automatically.\")\n\n    # Schedule role removal\n    async def remove_role_later():\n        await asyncio.sleep(seconds)\n        try:\n            m = ctx.guild.get_member(member.id)\n            if m and role in m.roles:\n                await m.remove_roles(role)\n                # Plain text end message\n                await ctx.send(f\"<:GsRight:1414593140156792893>  {m.mention}'s absence has ended.\")\n        except Exception:\n            pass\n\n    bot.loop.create_task(remove_role_later())\n\n# ---------------- gs.dm command ----------------\n@bot.command(name=\"dm\")\nasync def dm(ctx, member: discord.Member, *, message: str):\n    \"\"\"\n    Usage: gs.dm @member your message\n    Only the user with ID 721063236371480717 can use this command.\n    \"\"\"\n    # Check if the author is the allowed user mo\n    allowed_ids = {721063236371480717, 1344727532972412938}  # <:GsRight:1414593140156792893>  two allowed users\n\n    if ctx.author.id not in allowed_ids:\n        await ctx.send(\"<:GsWrong:1414561861352816753>   You are not allowed to use this command.\")\n        return\n\n    try:\n        await member.send(message)\n        await ctx.send(f\"üì© Successfully sent DM to {member.mention}\")\n    except discord.Forbidden:\n        await ctx.send(f\"‚ö†Ô∏è I cannot DM {member.mention}. Their DMs might be closed.\")\n    except Exception as e:\n        await ctx.send(f\"<:GsWrong:1414561861352816753>   Failed to send DM: {e}\")\n\n# ---------------- Missing commands handlers ----------------\n@bot.command(name=\"sabadminabuse\")\nasync def axo_command(ctx):\n    \"\"\"Handle axo command\"\"\"\n    await ctx.send(\"Next Steal A Brainrot Admin Abuse is at Your time: <t:1757451600:F>\")\n\n@bot.command(name=\"countryquiz\", aliases=[\"cquiz\"])\nasync def country_quiz(ctx):\n    \"\"\"Redirect to the correct countries quiz command\"\"\"\n    await ctx.send(\"üåç Use `gs.groupcountriesquiz` or `gs.countryguess` to play geography games!\")   \n    \n# ---------------- Mal's Gws ----------------\n@bot.command(name=\"giveawayprompt\")\nasync def giveawayprompt_command(ctx):\n    if not any(role.id == 1403093737323761746 for role in ctx.author.roles):\n        await ctx.reply(\"<:GsWrong:1414561861352816753> You don't have permission to use this command.\", mention_author=True)\n        return\n\n    # build the embed\n    embed = discord.Embed(\n        title=\"üéâ Giveaway Info\",\n        description=(\n            \"**1. Prize Details**\\n\"\n            \"‚óè Prize: \\n\"\n            \"‚óè Amount of Winners: \\n\\n\"\n            \"**2. Duration**\\n\"\n            \"‚óè Giveaway Length: \\n\"\n            \"‚óè Claim Time (*Half of the duration +*)\\n\\n\"\n            \"**3. Requirements**\\n\"\n            \"‚óè Any specific requirements\\n\"\n            \"‚óè Any bypassers\"\n        ),\n        color=0xFFC916\n    )\n    embed.set_footer(text=\"üî• Giveaways\")\n\n    # <:GsRight:1414593140156792893>  reply to the triggering message with embed\n    await ctx.reply(embed=embed, mention_author=True)\n\nimport discord\nfrom discord.ext import commands\nfrom discord.ui import View, Button\nimport asyncio\nimport io\nimport datetime\nimport json\nimport os\nimport re\n\n# ---------------- CONFIG ----------------\nSTAFF_ROLE_ID = 1394686620300476476   # Staff role\nTICKET_CATEGORY_1 = 1372934736330096780  # Buying tickets category\nTICKET_CATEGORY_2 = 1372934887186890903  # Support tickets category\nLOG_CHANNEL_ID = 1414528231834386545     # Ticket logs channel\nPANEL_ALLOWED_USER = 721063236371480717  # only this user can run gs.ticketpanel\nGOLD = 0xFFC916\nDB_FILE = \"tickets.json\"\n\n# ---------------- Bot setup (safe create-if-missing) ----------------\ntry:\n    bot  # if NameError -> not defined\nexcept NameError:\n    intents = discord.Intents.default()\n    intents.message_content = True\n    intents.members = True\n    bot = commands.Bot(command_prefix=['gs.', 'gs '], intents=intents)\n\n# ---------------- Persistent DB helpers ----------------\nDB_LOCK = asyncio.Lock()\n# structure: {\"tickets\": {\"<channel_id>\": {\"creator_id\": int|None, \"claimer_id\": int|None, \"action_message_id\": int|None, \"created_at\": iso}}, \"panels\": [{\"channel_id\": int, \"message_id\": int}, ...]}\n_tickets_db = {\"tickets\": {}, \"panels\": []}\n\ndef load_db():\n    global _tickets_db\n    if os.path.exists(DB_FILE):\n        try:\n            with open(DB_FILE, \"r\", encoding=\"utf-8\") as f:\n                _tickets_db = json.load(f)\n        except Exception:\n            _tickets_db = {\"tickets\": {}, \"panels\": []}\n    else:\n        _tickets_db = {\"tickets\": {}, \"panels\": []}\n\nasync def save_db():\n    async with DB_LOCK:\n        # make a safe write\n        tmp = DB_FILE + \".tmp\"\n        with open(tmp, \"w\", encoding=\"utf-8\") as f:\n            json.dump(_tickets_db, f, indent=2)\n        os.replace(tmp, DB_FILE)\n\nload_db()\n\n# ---------------- Utility: transcript & staff detection ----------------\nasync def make_transcript(channel: discord.TextChannel) -> discord.File:\n    \"\"\"Return a discord.File object containing the channel transcript.\"\"\"\n    transcript_lines = []\n    async for msg in channel.history(limit=None, oldest_first=True):\n        ts = msg.created_at.astimezone().strftime(\"%Y-%m-%d %H:%M:%S\")\n        # include attachments info (simple)\n        att_text = \"\"\n        if msg.attachments:\n            att_text = \" [attachments: \" + \", \".join(a.url for a in msg.attachments) + \"]\"\n        # guard binary / big content by truncating if necessary\n        content = msg.content or \"\"\n        if len(content) > 3000:\n            content = content[:3000] + \"...[truncated]\"\n        transcript_lines.append(f\"[{ts}] {msg.author} ({getattr(msg.author, 'id', 'unknown')}): {content}{att_text}\")\n    data = \"\\n\".join(transcript_lines) or \"(no messages)\"\n    return discord.File(io.BytesIO(data.encode(\"utf-8\")), filename=f\"{channel.name}-transcript.txt\")\n\nasync def gather_staff_who_spoke(channel: discord.TextChannel, staff_role: discord.Role):\n    \"\"\"Return (set of Member, mention_string). Searches message history and finds staff who posted.\"\"\"\n    staff_members = set()\n    async for msg in channel.history(limit=None):\n        if msg.author.bot:\n            continue\n        # msg.author may be Member or User; use roles attr safely\n        roles = getattr(msg.author, \"roles\", [])\n        if staff_role in roles:\n            staff_members.add(msg.author)\n    mentions = \", \".join(m.mention for m in staff_members) if staff_members else \"No staff replied.\"\n    return staff_members, mentions\n\n# ---------------- Persistent Views ----------------\nclass TicketView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n\n    @discord.ui.button(label=\"Buying Tickets\", emoji=\"<:GsBuying:1415290878964142110>\",\n                       style=discord.ButtonStyle.secondary, custom_id=\"panel_buy\")\n    async def buy_button(self, interaction: discord.Interaction, button: Button):\n        await create_ticket(interaction, TICKET_CATEGORY_1, \"buying\")\n\n    @discord.ui.button(label=\"Support Tickets\", emoji=\"<:GsSupport:1415290793681490000>\",\n                       style=discord.ButtonStyle.secondary, custom_id=\"panel_support\")\n    async def support_button(self, interaction: discord.Interaction, button: Button):\n        await create_ticket(interaction, TICKET_CATEGORY_2, \"support\")\n\nclass TicketActionView(View):\n    def __init__(self):\n        super().__init__(timeout=None)\n\n    @discord.ui.button(label=\"Close\", style=discord.ButtonStyle.secondary, custom_id=\"ticket_close\")\n    async def close_btn(self, interaction: discord.Interaction, button: Button):\n        # only staff\n        guild = interaction.guild\n        staff_role = guild.get_role(STAFF_ROLE_ID)\n        if not staff_role or staff_role not in interaction.user.roles:\n            return await interaction.response.send_message(embed=discord.Embed(\n                description=\"<:GsWrong:1414561861352816753> You can‚Äôt use this.\", color=0x000000), ephemeral=True)\n        # show confirm\n        await show_confirmation(interaction, action=\"close\")\n\n    @discord.ui.button(label=\"Delete\", style=discord.ButtonStyle.secondary, custom_id=\"ticket_delete\")\n    async def delete_btn(self, interaction: discord.Interaction, button: Button):\n        guild = interaction.guild\n        staff_role = guild.get_role(STAFF_ROLE_ID)\n        if not staff_role or staff_role not in interaction.user.roles:\n            return await interaction.response.send_message(embed=discord.Embed(\n                description=\"<:GsWrong:1414561861352816753> You can‚Äôt use this.\", color=0x000000), ephemeral=True)\n        await show_confirmation(interaction, action=\"delete\")\n\n    @discord.ui.button(label=\"Claim\", style=discord.ButtonStyle.secondary, custom_id=\"ticket_claim\")\n    async def claim_btn(self, interaction: discord.Interaction, button: Button):\n        guild = interaction.guild\n        staff_role = guild.get_role(STAFF_ROLE_ID)\n        if not staff_role or staff_role not in interaction.user.roles:\n            return await interaction.response.send_message(embed=discord.Embed(\n                description=\"<:GsWrong:1414561861352816753> You can‚Äôt use this.\", color=0x000000), ephemeral=True)\n        await show_confirmation(interaction, action=\"claim\")\n\n# helper to show the gold confirmation prompt (edits the same message)\nasync def show_confirmation(interaction: discord.Interaction, action: str):\n    \"\"\"\n    action: \"close\" | \"delete\" | \"claim\"\n    This edits the message the button was on into a confirmation embed (gold),\n    with Yes/No buttons. On cancel it reverts to original embed + TicketActionView.\n    \"\"\"\n    action_readable = {\"close\": \"Close\",\n                       \"delete\": \"Delete\",\n                       \"claim\": \"Claim\"}.get(action, action)\n\n    confirm_embed = discord.Embed(\n        title=\"Confirm action\",\n        description=f\"Are you sure you want to **{action_readable}**?\",\n        color=GOLD\n    )\n\n    original_message = interaction.message\n    original_embed = original_message.embeds[0] if original_message.embeds else None\n\n    # If embed missing, try to recover from persistent DB (use stored action_message_id for this channel)\n    if not original_embed:\n        meta = _tickets_db.get(\"tickets\", {}).get(str(interaction.channel.id))\n        if meta and meta.get(\"action_message_id\"):\n            try:\n                msg = await interaction.channel.fetch_message(meta[\"action_message_id\"])\n                if msg.embeds:\n                    original_embed = msg.embeds[0]\n            except Exception:\n                original_embed = None\n\n    class ConfirmView(View):\n        def __init__(self, action, original_embed):\n            super().__init__(timeout=30)\n            self.action = action\n            self.original_embed = original_embed\n\n        @discord.ui.button(label=\"Yes\", emoji=\"<:GsRight:1414593140156792893>\",\n                           style=discord.ButtonStyle.secondary, custom_id=\"confirm_yes\")\n        async def yes(self, yes_i: discord.Interaction, button: Button):\n            # double-check staff\n            guild = yes_i.guild\n            staff_role = guild.get_role(STAFF_ROLE_ID)\n            if not staff_role or staff_role not in yes_i.user.roles:\n                return await yes_i.response.send_message(embed=discord.Embed(\n                    description=\"<:GsWrong:1414561861352816753> You can‚Äôt use this.\", color=0x000000), ephemeral=True)\n\n            # perform the desired action on the channel where the button was pressed\n            channel = yes_i.channel\n            # fetch fresh channel object\n            channel = guild.get_channel(channel.id)\n            # perform\n            if self.action == \"close\":\n                await do_close_ticket(channel, yes_i.user)\n                # confirm to the interactor and remove view\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=f\"<:GsRight:1414593140156792893> Ticket closed (user removed) by {yes_i.user.mention}.\",\n                    color=0x000000), view=None)\n            elif self.action == \"delete\":\n                await do_delete_ticket(channel, yes_i.user)\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=f\"<:GsRight:1414593140156792893> Ticket deleted by {yes_i.user.mention}.\",\n                    color=0x000000), view=None)\n            elif self.action == \"claim\":\n                await do_claim_ticket(channel, yes_i.user)\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=f\"<:GsRight:1414593140156792893> Ticket claimed by {yes_i.user.mention}.\",\n                    color=0x000000), view=None)\n            else:\n                await yes_i.response.edit_message(embed=discord.Embed(\n                    description=\"Unknown action.\", color=0x000000), view=None)\n\n        @discord.ui.button(label=\"No\", emoji=\"<:GsWrong:1414561861352816753>\",\n                           style=discord.ButtonStyle.secondary, custom_id=\"confirm_no\")\n        async def no(self, no_i: discord.Interaction, button: Button):\n            # revert the original embed + view\n            await no_i.response.edit_message(embed=self.original_embed or discord.Embed(\n                description=\"Ticket actions\", color=0x000000), view=TicketActionView())\n\n    await interaction.response.edit_message(embed=confirm_embed, view=ConfirmView(action, original_embed))\n\n# ---------------- Core action implementations ----------------\nasync def do_close_ticket(channel: discord.TextChannel, action_by: discord.Member):\n    \"\"\"Remove ticket creator's access (do not delete channel), rename to closed-..., produce transcript & log.\"\"\"\n    guild = channel.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n    log_channel = guild.get_channel(LOG_CHANNEL_ID)\n\n    # try to get creator and claimer from DB first\n    meta = _tickets_db.get(\"tickets\", {}).get(str(channel.id), {})\n    creator_id = meta.get(\"creator_id\")\n    claimer_id = meta.get(\"claimer_id\")\n\n    # fallback to topic parsing if DB empty\n    if not creator_id and channel.topic:\n        parts = channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_id = int(parts[0])\n        if len(parts) > 1 and parts[1].isdigit():\n            claimer_id = int(parts[1])\n\n    ticket_creator = guild.get_member(creator_id) if creator_id else None\n\n    # collect staff who replied before changing perms\n    staff_members, staff_mentions = await gather_staff_who_spoke(channel, staff_role)\n\n    # create transcript\n    transcript = await make_transcript(channel)\n\n    # remove creator permissions (revoke view/send)\n    if ticket_creator:\n        try:\n            await channel.set_permissions(ticket_creator, overwrite=discord.PermissionOverwrite(view_channel=False, send_messages=False))\n        except Exception:\n            pass\n\n    # optionally rename channel to indicate closed\n    try:\n        if not channel.name.startswith(\"closed-\"):\n            await channel.edit(name=f\"closed-{channel.name}\")\n    except Exception:\n        pass\n\n    # log embed + ping creators/staff in content to ensure they are notified (embeds don't always ping)\n    embed = discord.Embed(\n        title=\"<:GsTicketsStyle2:1415298853598396509>  Ticket Closed (user removed)\",\n        color=GOLD,\n        timestamp=datetime.datetime.utcnow()\n    )\n    embed.add_field(name=\"Ticket Creator\", value=(ticket_creator.mention if ticket_creator else \"Unknown\"), inline=False)\n    embed.add_field(name=\"Closed By\", value=action_by.mention, inline=False)\n    embed.add_field(name=\"Staff Involved\", value=(staff_mentions), inline=False)\n    if log_channel:\n        content_ping = \"\"\n        if ticket_creator:\n            content_ping += f\"{ticket_creator.mention} \"\n        if staff_members:\n            content_ping += \" \".join(m.mention for m in staff_members)\n        # send content ping and embed & transcript\n        try:\n            await log_channel.send(content=content_ping or None, embed=embed, file=transcript)\n        except Exception:\n            # fallback without content ping\n            await log_channel.send(embed=embed, file=transcript)\n\n    # mark closed in DB (do not delete entry so we can audit later)\n    meta_key = str(channel.id)\n    if meta_key in _tickets_db.get(\"tickets\", {}):\n        _tickets_db[\"tickets\"][meta_key][\"closed\"] = True\n        _tickets_db[\"tickets\"][meta_key][\"closed_at\"] = datetime.datetime.utcnow().isoformat()\n        await save_db()\n\nasync def do_delete_ticket(channel: discord.TextChannel, action_by: discord.Member):\n    \"\"\"Make transcript, log and delete channel.\"\"\"\n    guild = channel.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n    log_channel = guild.get_channel(LOG_CHANNEL_ID)\n\n    # identify creator from DB first\n    creator_id = None\n    meta = _tickets_db.get(\"tickets\", {}).get(str(channel.id), {})\n    if meta:\n        creator_id = meta.get(\"creator_id\")\n\n    # fallback to topic\n    if not creator_id and channel.topic:\n        parts = channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_id = int(parts[0])\n    ticket_creator = guild.get_member(creator_id) if creator_id else None\n\n    staff_members, staff_mentions = await gather_staff_who_spoke(channel, staff_role)\n    transcript = await make_transcript(channel)\n\n    embed = discord.Embed(\n        title=\"<:GsTicketsStyle2:1415298853598396509>  Ticket Deleted\",\n        description=f\"Deleted by {action_by.mention}\",\n        color=GOLD,\n        timestamp=datetime.datetime.utcnow()\n    )\n    embed.add_field(name=\"User\", value=(ticket_creator.mention if ticket_creator else \"Unknown (topic missing)\"), inline=False)\n    embed.add_field(name=\"Staff Involved\", value=staff_mentions, inline=False)\n    if log_channel:\n        content_ping = \"\"\n        if ticket_creator:\n            content_ping += f\"{ticket_creator.mention} \"\n        if staff_members:\n            content_ping += \" \".join(m.mention for m in staff_members)\n        try:\n            await log_channel.send(content=content_ping or None, embed=embed, file=transcript)\n        except Exception:\n            await log_channel.send(embed=embed, file=transcript)\n\n    # remove from DB (if present)\n    meta_key = str(channel.id)\n    if meta_key in _tickets_db.get(\"tickets\", {}):\n        del _tickets_db[\"tickets\"][meta_key]\n        await save_db()\n\n    # delete after logging\n    await channel.delete()\n\nasync def do_claim_ticket(channel: discord.TextChannel, claimer: discord.Member):\n    \"\"\"Give exclusive send permissions to claimer, others staff can view only.\"\"\"\n    guild = channel.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n\n    # find creator id from DB or topic\n    meta_key = str(channel.id)\n    meta = _tickets_db.get(\"tickets\", {}).get(meta_key, {})\n    creator_id = meta.get(\"creator_id\")\n    current_claimer = meta.get(\"claimer_id\")\n\n    if not creator_id and channel.topic:\n        parts = channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_id = int(parts[0])\n    # set staff role send_messages=False (view True)\n    try:\n        await channel.set_permissions(staff_role, view=True, send_messages=False)\n    except Exception:\n        pass\n    # set claimer perms\n    await channel.set_permissions(claimer, view=True, send_messages=True)\n\n    # update channel.topic to include claimer id (creator;claimer)\n    creator_part = str(creator_id) if creator_id else \"\"\n    try:\n        await channel.edit(topic=f\"{creator_part};{claimer.id}\")\n    except Exception:\n        pass\n\n    # update DB\n    _tickets_db.setdefault(\"tickets\", {}).setdefault(meta_key, {})\n    _tickets_db[\"tickets\"][meta_key][\"creator_id\"] = creator_id\n    _tickets_db[\"tickets\"][meta_key][\"claimer_id\"] = claimer.id\n    await save_db()\n\n    # log claim in log channel\n    log_channel = guild.get_channel(LOG_CHANNEL_ID)\n    embed = discord.Embed(title=\"<:GsTicketsStyle2:1415298853598396509>  Ticket Claimed\",\n                          description=f\"Claimed by {claimer.mention}\",\n                          color=GOLD,\n                          timestamp=datetime.datetime.utcnow())\n    if log_channel:\n        await log_channel.send(embed=embed)\n\n# ---------------- Create a ticket (stores creator id in DB & topic), posts ticket-action message inside ticket ----------------\nasync def create_ticket(interaction: discord.Interaction, category_id: int, ticket_type: str):\n    guild = interaction.guild\n    staff_role = guild.get_role(STAFF_ROLE_ID)\n    category = guild.get_channel(category_id)\n    if not staff_role or not category:\n        return await interaction.response.send_message(embed=discord.Embed(\n            description=\"<:GsWrong:1414561861352816753> Ticket system not set up properly. Contact an admin.\",\n            color=0x000000), ephemeral=True)\n\n    # prepare overwrites\n    overwrites = {\n        guild.default_role: discord.PermissionOverwrite(view_channel=False),\n        staff_role: discord.PermissionOverwrite(view_channel=True, send_messages=True),\n        interaction.user: discord.PermissionOverwrite(view_channel=True, send_messages=True)\n    }\n\n    # create channel and set topic to \"creatorID;\" (claimer blank)\n    # sanitize name (keep your original style but avoid illegal chars)\n    safe_name_user = re.sub(r\"[^0-9a-zA-Z-_]\", \"\", f\"{interaction.user.name}\")[:32]\n    name_safe = f\"{ticket_type}-ticket-{safe_name_user}-{interaction.user.discriminator}\"\n    ticket_channel = await guild.create_text_channel(\n        name=name_safe,\n        overwrites=overwrites,\n        category=category,\n        topic=f\"{interaction.user.id};\"  # creatorID ; claimerID (empty)\n    )\n\n    # send initial embed + ticket action buttons (persistent)\n    embed = discord.Embed(\n        title=f\"{ticket_type.capitalize()} Ticket\",\n        description=f\"{interaction.user.mention} this ticket has been created. Use the buttons below (staff only).\",\n        color=GOLD,\n        timestamp=datetime.datetime.utcnow()\n    )\n    # send and capture message so we can persist its id\n    action_msg = await ticket_channel.send(embed=embed, view=TicketActionView())\n\n    # store ticket metadata to DB (persistent)\n    _tickets_db.setdefault(\"tickets\", {})[str(ticket_channel.id)] = {\n        \"creator_id\": interaction.user.id,\n        \"claimer_id\": None,\n        \"action_message_id\": action_msg.id,\n        \"created_at\": datetime.datetime.utcnow().isoformat()\n    }\n    await save_db()\n\n    # respond to user\n    await interaction.response.send_message(embed=discord.Embed(\n        description=f\"{ticket_type.capitalize()} Ticket created: {ticket_channel.mention} <:GsRight:1414593140156792893>\",\n        color=0x000000\n    ), ephemeral=True)\n\n# ---------------- Panel command (restricted to single user) ----------------\n@bot.command(name=\"ticketpanel\")\nasync def ticketpanel(ctx):\n    if ctx.author.id != PANEL_ALLOWED_USER:\n        return await ctx.send(embed=discord.Embed(\n            description=\"<:GsWrong:1414561861352816753> You are not allowed to use this command.\",\n            color=0x000000\n        ))\n    embed = discord.Embed(\n        title=\"<:GsTicketsStyle2:1415298853598396509>  GS Tickets\",\n        description=(\n            \"Choose the type of ticket you want to open below:\\n\\n\"\n            \"<:GsBuying:1415290878964142110> **Buying Tickets** ‚Üí For purchases and orders.\\n\\n\"\n            \"<:GsSupport:1415290793681490000> **Support Tickets** ‚Üí For help and general assistance.\"\n        ),\n        color=0x000000\n    )\n    embed.set_thumbnail(url=\"https://media.discordapp.net/attachments/1378099122497785976/1415323351878078474/image.png?format=webp&quality=lossless\")\n    embed.set_image(url=\"https://media.discordapp.net/attachments/1378099122497785976/1415309148697919581/image.png?format=webp&quality=lossless\")\n    panel_msg = await ctx.send(embed=embed, view=TicketView())\n\n    # persist panel message so we can re-attach view after restarts\n    _tickets_db.setdefault(\"panels\", []).append({\"channel_id\": ctx.channel.id, \"message_id\": panel_msg.id})\n    await save_db()\n\n# ---------------- gs.delete command (same flow as Delete button) ----------------\n@bot.command(name=\"delete\")\nasync def delete_cmd(ctx):\n    staff_role = ctx.guild.get_role(STAFF_ROLE_ID)\n    if not staff_role or staff_role not in ctx.author.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> You don‚Äôt have permission.\", color=0x000000))\n\n    if not ctx.channel.name.startswith((\"buying-ticket-\", \"support-ticket-\", \"closed-support\", \"closed-buying\")):\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> This command can only be used in a ticket channel.\", color=0x000000))\n\n    # show confirmation inline (reusing show_confirmation by synthesizing an \"interaction-like\" edit)\n    # easiest: send a new confirmation message for the command:\n    confirm_embed = discord.Embed(title=\"Confirm delete\", description=\"Are you sure you want to delete this ticket?\", color=GOLD)\n    class DeleteConfirm(View):\n        @discord.ui.button(label=\"Yes\", emoji=\"<:GsRight:1414593140156792893>\", style=discord.ButtonStyle.secondary)\n        async def yes(self, interaction: discord.Interaction, button: Button):\n            staff_role_local = ctx.guild.get_role(STAFF_ROLE_ID)\n            if staff_role_local not in interaction.user.roles:\n                return await interaction.response.send_message(\"<:GsWrong:1414561861352816753> You can‚Äôt use this.\", ephemeral=True)\n            await do_delete_ticket(ctx.channel, interaction.user)\n            await interaction.response.edit_message(embed=discord.Embed(description=\"Deleted.\", color=0x000000), view=None)\n        @discord.ui.button(label=\"No\", emoji=\"<:GsWrong:1414561861352816753>\", style=discord.ButtonStyle.secondary)\n        async def no(self, interaction: discord.Interaction, button: Button):\n            await interaction.response.edit_message(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> Action denied.\", color=0x000000), view=None)\n\n    await ctx.send(embed=confirm_embed, view=DeleteConfirm())\n\n# ---------------- gs.claim command (with gold confirmation) ----------------\n@bot.command(name=\"claim\")\nasync def claim_cmd(ctx):\n    staff_role = ctx.guild.get_role(STAFF_ROLE_ID)\n    if not staff_role or staff_role not in ctx.author.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> You don‚Äôt have permission.\", color=0x000000))\n    if not ctx.channel.name.startswith((\"buying-ticket-\", \"support-ticket-\")):\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> This command can only be used in a ticket channel.\", color=0x000000))\n\n    confirm_embed = discord.Embed(title=\"Claim ticket\", description=f\"{ctx.author.mention}, do you want to claim this ticket?\", color=GOLD)\n    class ClaimConfirm(View):\n        @discord.ui.button(label=\"Yes\", emoji=\"<:GsRight:1414593140156792893>\", style=discord.ButtonStyle.secondary)\n        async def yes(self, interaction: discord.Interaction, button: Button):\n            staff_role_local = ctx.guild.get_role(STAFF_ROLE_ID)\n            if staff_role_local not in interaction.user.roles:\n                return await interaction.response.send_message(\"<:GsWrong:1414561861352816753> You can‚Äôt use this.\", ephemeral=True)\n            await do_claim_ticket(ctx.channel, interaction.user)\n            await interaction.response.edit_message(embed=discord.Embed(description=f\"<:GsRight:1414593140156792893> Ticket claimed by {interaction.user.mention}.\", color=0x000000), view=None)\n        @discord.ui.button(label=\"No\", emoji=\"<:GsWrong:1414561861352816753>\", style=discord.ButtonStyle.secondary)\n        async def no(self, interaction: discord.Interaction, button: Button):\n            await interaction.response.edit_message(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> Claim cancelled.\", color=0x000000), view=None)\n\n    await ctx.send(embed=confirm_embed, view=ClaimConfirm())\n\n# ---------------- gs.transfer @member (give claim to another staff) ----------------\n@bot.command(name=\"transfer\")\nasync def transfer_cmd(ctx, member: discord.Member):\n    staff_role = ctx.guild.get_role(STAFF_ROLE_ID)\n    if not staff_role or staff_role not in ctx.author.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> You don‚Äôt have permission.\", color=0x000000))\n    if not ctx.channel.name.startswith((\"buying-ticket-\", \"support-ticket-\")):\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> This command can only be used in a ticket channel.\", color=0x000000))\n    # target must be staff\n    if staff_role not in member.roles:\n        return await ctx.send(embed=discord.Embed(description=\"<:GsWrong:1414561861352816753> Target is not staff.\", color=0x000000))\n\n    # set staff role perms to view only, make member send_messages True\n    await ctx.channel.set_permissions(staff_role, view=True, send_messages=False)\n    await ctx.channel.set_permissions(member, view=True, send_messages=True)\n    # update topic claimer part while preserving creator id\n    creator_part = \"\"\n    if ctx.channel.topic:\n        parts = ctx.channel.topic.split(\";\")\n        if parts and parts[0].isdigit():\n            creator_part = parts[0]\n    await ctx.channel.edit(topic=f\"{creator_part};{member.id}\")\n\n    # update DB\n    meta_key = str(ctx.channel.id)\n    _tickets_db.setdefault(\"tickets\", {}).setdefault(meta_key, {})\n    _tickets_db[\"tickets\"][meta_key][\"claimer_id\"] = member.id\n    await save_db()\n\n    await ctx.send(embed=discord.Embed(description=f\"Ticket transferred to {member.mention}.\", color=GOLD))\n\n# ---------------- Register persistent views on_ready and reattach to messages ----------------\nVIEWS_REGISTERED = False\n\n@bot.event\nasync def on_ready():\n    global VIEWS_REGISTERED\n    if not VIEWS_REGISTERED:\n        try:\n            bot.add_view(TicketView())\n            bot.add_view(TicketActionView())\n            VIEWS_REGISTERED = True\n            print(f\"Registered persistent views as {bot.user}\")\n        except Exception as e:\n            print(\"Failed to register persistent views on startup:\", e)\n\n    # re-attach views to existing messages (action messages + panel messages)\n    # This helps the bot \"remember\" embeds and make buttons work after restart\n    # Migrate any existing ticket channels (that use naming convention) into DB if missing\n    try:\n        # migrate channels that look like tickets and are not yet in DB\n        for channel in bot.get_all_channels():\n            if not isinstance(channel, discord.TextChannel):\n                continue\n            if channel.name.startswith((\"buying-ticket-\", \"support-ticket-\")):\n                key = str(channel.id)\n                if key not in _tickets_db.get(\"tickets\", {}):\n                    # try to infer creator/claimer from topic\n                    creator_id = None\n                    claimer_id = None\n                    if channel.topic:\n                        parts = channel.topic.split(\";\")\n                        if parts and parts[0].isdigit():\n                            creator_id = int(parts[0])\n                        if len(parts) > 1 and parts[1].isdigit():\n                            claimer_id = int(parts[1])\n                    # try to find the bot's action message in recent history\n                    action_msg_id = None\n                    async for msg in channel.history(limit=200):\n                        if msg.author == bot.user and msg.embeds:\n                            action_msg_id = msg.id\n                            break\n                    _tickets_db.setdefault(\"tickets\", {})[key] = {\n                        \"creator_id\": creator_id,\n                        \"claimer_id\": claimer_id,\n                        \"action_message_id\": action_msg_id,\n                        \"created_at\": datetime.datetime.utcnow().isoformat()\n                    }\n                    await save_db()\n\n        # reattach views to action messages\n        for ch_id, meta in list(_tickets_db.get(\"tickets\", {}).items()):\n            try:\n                channel = bot.get_channel(int(ch_id))\n                if not channel:\n                    continue\n                msg_id = meta.get(\"action_message_id\")\n                if not msg_id:\n                    continue\n                try:\n                    msg = await channel.fetch_message(int(msg_id))\n                    # attach the persistent view to this message so interactions work after restart\n                    await msg.edit(view=TicketActionView())\n                except Exception as e:\n                    print(f\"Could not reattach TicketActionView to message {msg_id} in channel {ch_id}:\", e)\n            except Exception:\n                continue\n\n        # reattach views to panel messages\n        for panel in _tickets_db.get(\"panels\", []):\n            try:\n                channel = bot.get_channel(int(panel.get(\"channel_id\")))\n                if not channel:\n                    continue\n                msg = await channel.fetch_message(int(panel.get(\"message_id\")))\n                await msg.edit(view=TicketView())\n            except Exception as e:\n                # don't crash startup on bad panels\n                print(\"Could not reattach TicketView to panel message:\", e)\n    except Exception as e:\n        print(\"Error during on_ready reattach/migrate:\", e)\n\n# ---------------- End of Ticket System block ----------------\n# Keep your customizations (emojis, gold color, thumbnails), this version fixes:\n#  - persistent views properly re-registered on_ready\n#  - action / panel message ids stored on-disk so views can be re-attached after restart\n#  - ticket creator/claimer metadata stored on-disk (tickets.json) and migrated from existing channel topics when possible\n#  - show_confirmation will attempt to recover the original embed from the stored action message if the interaction message lacks it\n\n# Note: run the bot as usual: bot.run(\"YOUR_TOKEN\") in your main runner script.\n\n# ---------------- Bot wrapper class ----------------\nclass DiscordBot:\n    def __init__(self):\n        self.bot = bot\n\n    async def start(self, token):\n        await self.bot.start(token)\n\n    async def close(self):\n        await self.bot.close()\n\n# Load pet data immediately when module is imported\ntry:\n    load_pet_data()\nexcept Exception as e:\n    logger.error(f\"Failed to load pet data at module import: {e}\")","size_bytes":216349},"main.py":{"content":"import asyncio\nimport threading\nimport logging\nimport os\nfrom fixed_bot import DiscordBot\nfrom web_server import create_app\nfrom database import mod_db\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('bot.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\ndef run_discord_bot():\n    \"\"\"Run the Discord bot in a separate thread\"\"\"\n    try:\n        import time\n        time.sleep(3)  # Wait 3 seconds before connecting to avoid rate limits\n        \n        bot = DiscordBot()\n        discord_token = os.getenv('DISCORD_TOKEN')\n        if not discord_token:\n            logger.error(\"DISCORD_TOKEN environment variable not found\")\n            return\n        \n        logger.info(\"Starting Discord bot...\")\n        asyncio.run(bot.bot.start(discord_token))\n    except Exception as e:\n        logger.error(f\"Error running Discord bot: {e}\")\n        # Wait before retrying\n        import time\n        time.sleep(10)\n        logger.info(\"Retrying Discord bot connection...\")\n        try:\n            bot = DiscordBot()\n            asyncio.run(bot.bot.start(discord_token))\n        except Exception as retry_error:\n            logger.error(f\"Retry failed: {retry_error}\")\n\ndef run_flask_server():\n    \"\"\"Run the Flask server for uptime monitoring\"\"\"\n    try:\n        app = create_app()\n        logger.info(\"Starting Flask server on port 5000...\")\n        app.run(host='0.0.0.0', port=5000, debug=False)\n    except Exception as e:\n        logger.error(f\"Error running Flask server: {e}\")\n\nif __name__ == \"__main__\":\n    logger.info(\"Starting Discord bot with Flask uptime endpoint...\")\n    \n    # Initialize database tables\n    try:\n        logger.info(\"Initializing database tables...\")\n        mod_db.init_database()\n        logger.info(\"Database tables initialized successfully!\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize database: {e}\")\n        # Continue anyway - bot can still work without moderation features\n    \n    # Start Discord bot in a separate thread\n    discord_thread = threading.Thread(target=run_discord_bot, daemon=True)\n    discord_thread.start()\n    \n    # Start Flask server in the main thread\n    run_flask_server()\n","size_bytes":2324},"pet_calculator.py":{"content":"from flask import Flask, render_template, request, jsonify\nimport math\n\napp = Flask(__name__)\n\n# Pet weight formula - base weights at each age\nBASE_WEIGHTS = {\n    1: 1.00, 2: 1.09, 3: 1.18, 4: 1.27, 5: 1.36, 6: 1.45, 7: 1.55, 8: 1.64, 9: 1.73, 10: 1.82,\n    11: 1.91, 12: 2.00, 13: 2.09, 14: 2.18, 15: 2.27, 16: 2.36, 17: 2.45, 18: 2.55, 19: 2.64, 20: 2.73,\n    21: 2.82, 22: 2.91, 23: 3.00, 24: 3.09, 25: 3.18, 26: 3.27, 27: 3.36, 28: 3.45, 29: 3.55, 30: 3.64,\n    31: 3.73, 32: 3.82, 33: 3.91, 34: 4.00, 35: 4.09, 36: 4.18, 37: 4.27, 38: 4.36, 39: 4.45, 40: 4.55,\n    41: 4.64, 42: 4.73, 43: 4.82, 44: 4.91, 45: 5.00, 46: 5.09, 47: 5.18, 48: 5.27, 49: 5.36, 50: 5.45,\n    51: 5.55, 52: 5.64, 53: 5.73, 54: 5.82, 55: 5.91, 56: 6.00, 57: 6.09, 58: 6.18, 59: 6.27, 60: 6.36,\n    61: 6.45, 62: 6.55, 63: 6.64, 64: 6.73, 65: 6.82, 66: 6.91, 67: 7.00, 68: 7.09, 69: 7.18, 70: 7.27,\n    71: 7.36, 72: 7.45, 73: 7.55, 74: 7.64, 75: 7.73, 76: 7.82, 77: 7.91, 78: 8.00, 79: 8.09, 80: 8.18,\n    81: 8.27, 82: 8.36, 83: 8.45, 84: 8.55, 85: 8.64, 86: 8.73, 87: 8.82, 88: 8.91, 89: 9.00, 90: 9.09,\n    91: 9.18, 92: 9.27, 93: 9.36, 94: 9.45, 95: 9.55, 96: 9.64, 97: 9.73, 98: 9.82, 99: 9.91, 100: 10.00\n}\n\ndef calculate_weight_multiplier(current_age, current_weight):\n    \"\"\"Calculate the multiplier based on current age and weight\"\"\"\n    if current_age not in BASE_WEIGHTS:\n        return None\n    \n    base_weight_at_current_age = BASE_WEIGHTS[current_age]\n    multiplier = current_weight / base_weight_at_current_age\n    return multiplier\n\ndef predict_weights(current_age, current_weight):\n    \"\"\"Predict weights for all ages based on current data\"\"\"\n    multiplier = calculate_weight_multiplier(current_age, current_weight)\n    if multiplier is None:\n        return None\n    \n    predictions = {}\n    for age in range(1, 101):\n        if age in BASE_WEIGHTS:\n            predicted_weight = BASE_WEIGHTS[age] * multiplier\n            predictions[age] = round(predicted_weight, 2)\n    \n    return predictions\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/calculate', methods=['POST'])\ndef calculate():\n    try:\n        data = request.get_json()\n        current_age = int(data['age'])\n        current_weight = float(data['weight'])\n        \n        if current_age < 1 or current_age > 100:\n            return jsonify({'error': 'Age must be between 1 and 100'}), 400\n        \n        if current_weight <= 0:\n            return jsonify({'error': 'Weight must be greater than 0'}), 400\n        \n        predictions = predict_weights(current_age, current_weight)\n        \n        if predictions is None:\n            return jsonify({'error': 'Invalid age provided'}), 400\n        \n        return jsonify({\n            'current_age': current_age,\n            'current_weight': current_weight,\n            'predictions': predictions\n        })\n    \n    except (ValueError, KeyError) as e:\n        return jsonify({'error': 'Invalid input data'}), 400\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=3000, debug=False)","size_bytes":3051},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"discord-py>=2.6.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-dateutil>=2.9.0.post0\",\n    \"email-validator>=2.3.0\",\n]\n","size_bytes":341},"replit.md":{"content":"# Overview\n\nThis is a Discord bot with triple functionality: it monitors a specific channel for messages containing \"WFL\" (Want For Less - a trading term) and reacts with custom emojis, tracks pet values from a dedicated values channel, and provides a pet weight calculator command. The bot includes a Flask web server for uptime monitoring and health checks, making it suitable for deployment on platforms that require HTTP endpoints to keep services alive.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# Recent Changes\n\n## August 19, 2025 - Successfully Migrated from Replit Agent to Replit\n- **MIGRATION COMPLETE**: Successfully migrated Discord bot project from Replit Agent environment to standard Replit environment\n- **Dependencies Installed**: All required Python packages installed via uv package manager (discord.py, flask, psycopg2-binary, python-dateutil)\n- **Database Setup**: PostgreSQL database created with proper environment variables (DATABASE_URL, PGPORT, PGUSER, etc.)\n- **Discord Token Configuration**: DISCORD_TOKEN secret properly configured in environment variables\n- **Bot Connection Verified**: Discord bot successfully connected and actively processing messages\n- **Pet Database Active**: Bot scanning Discord channels and updating pet database in real-time (103+ pets tracked)\n- **Flask Server Running**: Web server operational on port 5000 for uptime monitoring\n- **All Features Operational**: WFL reactions, pet value tracking, weight calculator, moderation system all working\n- **Migration Benefits**: Enhanced security with proper client/server separation, better environment management, and Replit compatibility\n\n## August 22, 2025 - Successfully Migrated from Replit Agent to Replit\n- **MIGRATION COMPLETE**: Successfully migrated Discord bot project from Replit Agent environment to standard Replit environment\n- **Dependencies Installed**: All required Python packages installed via uv package manager (discord.py, flask, psycopg2-binary, python-dateutil)\n- **Database Setup**: PostgreSQL database created with proper environment variables (DATABASE_URL, PGPORT, PGUSER, etc.)\n- **Discord Token Configuration**: DISCORD_TOKEN secret properly configured in environment variables\n- **Bot Connection Verified**: Discord bot successfully connected and actively processing messages\n- **Pet Database Active**: Bot scanning Discord channels and updating pet database in real-time (103+ pets tracked)\n- **Flask Server Running**: Web server operational on port 5000 for uptime monitoring\n- **All Features Operational**: WFL reactions, pet value tracking, weight calculator, moderation system all working\n- **Migration Benefits**: Enhanced security with proper client/server separation, better environment management, and Replit compatibility\n\n## August 14, 2025 - Complete Bot Enhancement and Admin Protection Update\n- Successfully migrated project from Replit Agent to standard Replit environment\n- FIXED: Pet similarity matching algorithm causing incorrect search results (t-rex vs turtle issue)\n- Enhanced pet search error messages with helpful examples and suggestions\n- Increased similarity threshold from 20% to 50% for more accurate matching\n- Bot now properly handles non-existent pets with clear, actionable error messages\n- FIXED: Auto-pick feature now works for all scenarios - automatically selects best match even when multiple pets have same percentage\n- FIXED: Removed \"lossless\" prefix from appearing in pet names during value scanning\n- Enhanced auto-selection with 5-point threshold and always picks first match when tied\n- Installed all required dependencies: discord.py, flask, psycopg2-binary, python-dateutil\n- Created PostgreSQL database with moderation system tables\n- Configured Discord bot token in environment variables\n- Updated moderation commands with gs. prefix and improved styling:\n  - gs.warn @user reason - Warn a user with confirmation\n  - gs.mute @user duration reason - Mute user with Discord timeout\n  - gs.ban @user duration reason - Ban user with optional duration\n  - gs.kick @user reason - Kick user from server\n  - gs.unmute @user reason - Remove timeout from user\n  - gs.removewarn action_id reason - Remove/revoke moderation actions\n- Added separate history commands:\n  - gs.warns @user - Show warning history only\n  - gs.mutes @user - Show mute history only \n  - gs.bans @user - Show ban history only\n  - gs.kicks @user - Show kick history only\n  - gs.history @user - Show complete moderation history\n- Enhanced DM notifications with Game Services branding and appeal process\n- Added comprehensive user reporting system:\n  - gs.report @user reason - Members can report users to moderation team\n  - **WARNING: \"FALSE REPORTS WILL GET YOU MUTED\"** prominently displayed\n  - Two-step confirmation process with Submit/Cancel buttons\n  - Reports sent to dedicated channel (1403179951431094404) with detailed user information\n  - Staff can Approve/Deny reports with permission checks\n  - When approved, staff get quick action buttons: Warn, Mute (5m/10m/20m), Kick\n  - All actions logged to database with DM notifications and appeal process\n  - Prevents self-reporting and bot reporting with validation\n  - Beautiful gold-styled embeds with account age and server join information\n- Added comprehensive invite tracking system:\n  - Automatic invite detection with fake invite filtering (accounts < 7 days)\n  - Rejoin detection and tracking\n  - Bonus invite management (addinvite/removeinvite commands)\n  - Invite leaderboard (invtop) with top 10 users\n  - Individual invite stats (invites command) showing valid/fake/rejoins/bonus\n- Added message tracking system:\n  - Daily, weekly, and monthly message counting with automatic resets\n  - Message statistics command (gs.m) showing user activity\n  - Message leaderboards (msgtop daily/weekly/monthly) \n  - Last message timestamp tracking\n- All embeds now use consistent gold color scheme (0xFFC916)\n- Added comprehensive game filtering to prevent false pet detections:\n  - Filters out Wordbomb, Trivia, and other Discord game messages\n  - Enhanced message validation requiring pet-related keywords\n  - Fixed issues with random words being counted as pets\n- Implemented <:GsWrong:1414561861352816753>   reaction system for incorrect pet value searches\n- Added admin protection to automoderation system:\n  - Users with manage_guild or administrator permissions bypass automod\n  - Prevents accidental moderation of server administrators\n- Fixed all image handling issues:\n  - Only assigns images to single-pet messages to avoid confusion\n  - Proper Discord CDN URL formatting with size parameters\n  - Multi-pet messages skip image assignment entirely\n- Bot is now fully operational with all features working:\n  - WFL reactions in target channel\n  - Pet value tracking and database (71 pets loaded with proper filtering)\n  - Pet weight calculator commands\n  - Complete moderation system with admin protection\n  - User reporting system with channel integration\n  - Comprehensive invite tracking with fake detection\n  - Message activity tracking and leaderboards\n  - Auto-pick pet matching with 50% similarity threshold\n  - Game message filtering and validation\n  - Flask server for uptime monitoring on port 5000\n\n# System Architecture\n\n## Bot Architecture\n- **Discord.py Framework**: Uses the discord.py library with commands extension for Discord API interaction\n- **Event-Driven Design**: Implements `on_ready` and `on_message` event handlers to respond to Discord events\n- **Regex Pattern Matching**: Uses compiled regex patterns for case-insensitive \"WFL\" detection in messages\n- **Rate Limiting**: Built-in cooldown system to prevent spam reactions (1-second cooldown between reactions)\n\n## Multi-Threading Design\n- **Dual Service Architecture**: Runs Discord bot and Flask server concurrently using Python threading\n- **Thread Separation**: Discord bot runs in a daemon thread while Flask server runs in the main thread\n- **Error Isolation**: Each service has independent error handling to prevent cascading failures\n\n## Web Server Component\n- **Flask Framework**: Lightweight web server for HTTP endpoints\n- **Health Monitoring**: Multiple endpoints (`/`, `/uptime`, `/status`) for different monitoring needs\n- **Uptime Tracking**: Tracks bot start time and calculates running duration\n- **JSON API**: All endpoints return structured JSON responses for easy integration with monitoring tools\n\n## Configuration Management\n- **Environment Variables**: Uses `DISCORD_TOKEN` environment variable for secure token storage\n- **Channel Configuration**: \n  - WFL reactions channel: 1401169397850308708\n  - Pet values monitoring channel: 1391477739680301187\n- **Logging System**: Comprehensive logging to both file (`bot.log`) and console with timestamp formatting\n- **Data Storage**: Pet values stored in `pet_values.json` file\n\n## Message Processing Pipeline\n1. **Message Filtering**: Ignores bot messages and filters by target channel\n2. **Pattern Detection**: Searches for \"WFL\" pattern using case-insensitive regex\n3. **Rate Limiting**: Checks cooldown before processing reactions\n4. **Reaction Application**: Adds custom server emojis (:W1:, :F1:, :L1:) to matching messages\n\n## Command System\n- **Pet Weight Calculator**: `!petweight` command calculates pet weight predictions\n- **Pet Value Lookup**: `!petvalue` (aliases: `!v`, `!value`, `!val`) command looks up pet values from database\n- **Pet Database Listing**: `!petlist` command shows all pets in the database with pagination\n- **Command Processing**: Uses discord.py commands extension for structured command handling\n- **Input Validation**: Validates age (1-100) and weight (>0) parameters for weight calculations\n- **Flexible Output**: Shows weight progression or specific target age predictions\n- **Weight Formula**: Uses predefined formula with base weights from age 1-100\n\n## Pet Values System\n- **Automatic Scanning**: Scans pet values channel on startup for existing pet data\n- **Real-time Monitoring**: Monitors pet values channel (1391477739680301187) for new pet information\n- **Pattern Matching**: Uses multiple regex patterns to extract pet name, value, and demand from messages\n- **Database Storage**: Stores pet data in JSON file with automatic saving\n- **Search Functionality**: Supports exact and partial matching for pet names\n- **Data Persistence**: Pet values persist between bot restarts\n\n# External Dependencies\n\n## Discord Integration\n- **Discord API**: Primary integration through discord.py library for bot functionality\n- **Discord Gateway**: Real-time message event streaming from Discord servers\n- **Bot Permissions**: Requires message content intent and reaction permissions\n\n## Python Libraries\n- **discord.py**: Core Discord bot framework with commands extension\n- **Flask**: Web framework for HTTP server functionality\n- **threading**: Standard library for concurrent execution\n- **logging**: Built-in logging system for monitoring and debugging\n- **re**: Regular expression library for pattern matching\n- **os**: Environment variable access\n- **datetime**: Timestamp and uptime calculations\n\n## Deployment Requirements\n- **Environment Variables**: `DISCORD_TOKEN` must be configured\n- **Port Access**: Requires access to port 8000 for Flask server\n- **File System**: Needs write access for `bot.log` file creation\n- **Network Access**: Requires outbound HTTPS for Discord API communication","size_bytes":11430},"web_server.py":{"content":"from flask import Flask, jsonify\nimport logging\nimport datetime\nimport os\n\nlogger = logging.getLogger(__name__)\n\ndef create_app():\n    \"\"\"Create and configure Flask application\"\"\"\n    app = Flask(__name__)\n    \n    # Store bot start time\n    start_time = datetime.datetime.utcnow()\n    \n    @app.route('/')\n    def health_check():\n        \"\"\"Basic health check endpoint\"\"\"\n        return jsonify({\n            'status': 'healthy',\n            'service': 'Discord WFL Bot',\n            'timestamp': datetime.datetime.utcnow().isoformat(),\n            'uptime_seconds': (datetime.datetime.utcnow() - start_time).total_seconds()\n        })\n    \n    @app.route('/uptime')\n    def uptime():\n        \"\"\"Uptime monitoring endpoint\"\"\"\n        uptime_delta = datetime.datetime.utcnow() - start_time\n        uptime_seconds = uptime_delta.total_seconds()\n        \n        return jsonify({\n            'status': 'online',\n            'uptime_seconds': uptime_seconds,\n            'uptime_human': str(uptime_delta),\n            'start_time': start_time.isoformat(),\n            'current_time': datetime.datetime.utcnow().isoformat()\n        })\n    \n    @app.route('/status')\n    def status():\n        \"\"\"Detailed status endpoint\"\"\"\n        return jsonify({\n            'bot_name': 'Discord WFL Bot',\n            'version': '1.0.0',\n            'status': 'running',\n            'monitoring_channel': '1401169397850308708',\n            'reaction_emojis': [':W1:', ':F1:', ':L1:'],\n            'uptime_seconds': (datetime.datetime.utcnow() - start_time).total_seconds(),\n            'environment': {\n                'python_version': os.sys.version.split()[0],\n                'discord_token_configured': bool(os.getenv('DISCORD_TOKEN'))\n            }\n        })\n    \n    @app.route('/ping')\n    def ping():\n        \"\"\"Simple ping endpoint for monitoring\"\"\"\n        return jsonify({\n            'status': 'pong',\n            'timestamp': datetime.datetime.utcnow().isoformat(),\n            'bot_active': True\n        })\n    \n    @app.errorhandler(404)\n    def not_found(error):\n        \"\"\"Handle 404 errors\"\"\"\n        return jsonify({'error': 'Endpoint not found'}), 404\n    \n    @app.errorhandler(500)\n    def internal_error(error):\n        \"\"\"Handle 500 errors\"\"\"\n        logger.error(f'Internal server error: {error}')\n        return jsonify({'error': 'Internal server error'}), 500\n    \n    # Add request logging\n    @app.before_request\n    def log_request():\n        from flask import request\n        logger.info(f'Incoming request: {request.method} {request.path} from {request.remote_addr}')\n    \n    return app\n","size_bytes":2603}},"version":1}